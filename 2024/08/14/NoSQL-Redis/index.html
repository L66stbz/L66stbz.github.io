<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NoSQL-Redis | L66</title><meta name="description" content="Redis 缓存数据库[TOC] 前言缓存数据库是一种位于应用程序与主要后端数据库之间的中间层，用于提高数据访问速度的技术。  以下是一些关于缓存数据库的详细介绍：   作用：缓存数据库主要用于存储那些频繁访问或计算成本较高的数据副本。这些数据通常被放置在高速、低延迟的存储介质上，如内存中，以便快速访问。加快访问速度 ,缓解关系型数据库的读压力。 使用场景：当应用程序需要数据时，首先会从缓存中查询"><meta name="keywords" content="Linux,Redis,RDB,AOF,Sentinel"><meta name="author" content="L66"><meta name="copyright" content="L66"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/3.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="NoSQL-Redis"><meta name="twitter:description" content="Redis 缓存数据库[TOC] 前言缓存数据库是一种位于应用程序与主要后端数据库之间的中间层，用于提高数据访问速度的技术。  以下是一些关于缓存数据库的详细介绍：   作用：缓存数据库主要用于存储那些频繁访问或计算成本较高的数据副本。这些数据通常被放置在高速、低延迟的存储介质上，如内存中，以便快速访问。加快访问速度 ,缓解关系型数据库的读压力。 使用场景：当应用程序需要数据时，首先会从缓存中查询"><meta name="twitter:image" content="https://l66stbz.github.io/2024/08/14/NoSQL-Redis/1.png"><meta property="og:type" content="article"><meta property="og:title" content="NoSQL-Redis"><meta property="og:url" content="https://l66stbz.github.io/2024/08/14/NoSQL-Redis/"><meta property="og:site_name" content="L66"><meta property="og:description" content="Redis 缓存数据库[TOC] 前言缓存数据库是一种位于应用程序与主要后端数据库之间的中间层，用于提高数据访问速度的技术。  以下是一些关于缓存数据库的详细介绍：   作用：缓存数据库主要用于存储那些频繁访问或计算成本较高的数据副本。这些数据通常被放置在高速、低延迟的存储介质上，如内存中，以便快速访问。加快访问速度 ,缓解关系型数据库的读压力。 使用场景：当应用程序需要数据时，首先会从缓存中查询"><meta property="og:image" content="https://l66stbz.github.io/2024/08/14/NoSQL-Redis/1.png"><meta property="article:published_time" content="2024-08-14T14:50:00.000Z"><meta property="article:modified_time" content="2024-08-17T07:53:47.741Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://l66stbz.github.io/2024/08/14/NoSQL-Redis/"><link rel="prev" title="Redis-Cluster集群" href="https://l66stbz.github.io/2024/08/15/Redis-Cluster%E9%9B%86%E7%BE%A4/"><link rel="next" title="LVS-NAT-Keepalived" href="https://l66stbz.github.io/2024/08/13/LVS-NAT-Keepalived/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="L66" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/2.jpg" onerror="onerror=null;src='/img/2.jpg'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">46</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">29</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Photo</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-缓存数据库"><span class="toc-number">1.</span> <span class="toc-text">Redis 缓存数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、简介"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、NoSQL的优点-缺点"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、NoSQL的优点&#x2F;缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、关系型数据库与非关系型数据库的区别：———面试高频率问题"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、关系型数据库与非关系型数据库的区别：———面试高频率问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、Memcached"><span class="toc-number">1.2.</span> <span class="toc-text">2、Memcached</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-特点"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-服务框架"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 服务框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-配置安装Memcached"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 配置安装Memcached</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Redis服务"><span class="toc-number">1.3.</span> <span class="toc-text">3、Redis服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-介绍"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-redis的特点"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 redis的特点:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-Redis和memcached区别（面试题）"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 Redis和memcached区别（面试题）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、安装Redis"><span class="toc-number">1.4.</span> <span class="toc-text">4、安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-安装单机版redis"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1  安装单机版redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-redis的相关工具"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2  redis的相关工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、Redis设置密码的两种方式"><span class="toc-number">1.5.</span> <span class="toc-text">5、Redis设置密码的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-命令行临时修改密码"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 命令行临时修改密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-配置文件永久修改密码"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 配置文件永久修改密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Redis配置文件详解"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 Redis配置文件详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、数据持久化"><span class="toc-number">1.6.</span> <span class="toc-text">6、数据持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-redis持久化-–-两种方式"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 redis持久化 – 两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-RDB"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">6.1.1  RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-RDB持久化配置"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text">1.  RDB持久化配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-RDB持久化数据恢复"><span class="toc-number">1.6.1.1.2.</span> <span class="toc-text">2. RDB持久化数据恢复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-RDB持久化的优缺点"><span class="toc-number">1.6.1.1.3.</span> <span class="toc-text">3. RDB持久化的优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-AOF"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">6.1.2 AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-AOF持久化策略"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">1. AOF持久化策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-AOF的触发方式"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text">2. AOF的触发方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-AOF的重写机制"><span class="toc-number">1.6.1.2.3.</span> <span class="toc-text">3. AOF的重写机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-Redis-AOF-重写机制原理"><span class="toc-number">1.6.1.2.3.1.</span> <span class="toc-text">3.1 Redis AOF 重写机制原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-AOF的优点和缺点"><span class="toc-number">1.6.1.2.4.</span> <span class="toc-text">4. AOF的优点和缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、Redis主从配置"><span class="toc-number">1.7.</span> <span class="toc-text">7、Redis主从配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-主从简介"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 主从简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-主从复制的意义"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 主从复制的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-主从同步原理偏移"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 主从同步原理偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1主n从的同步说明"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 1主n从的同步说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-部署三台机器Redis—主从同步"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 部署三台机器Redis—主从同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-主从同步保证数据一致性"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6 主从同步保证数据一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-总结"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.7 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、Redis-sentinel—哨兵模式"><span class="toc-number">1.8.</span> <span class="toc-text">8、Redis-sentinel—哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-哨兵简介-Redis-Sentinel"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 哨兵简介:Redis Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、Redis哨兵集群的角色划分"><span class="toc-number">1.8.1.0.1.</span> <span class="toc-text">1、Redis哨兵集群的角色划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、作用"><span class="toc-number">1.8.1.0.2.</span> <span class="toc-text">2、作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、工作模式"><span class="toc-number">1.8.1.0.3.</span> <span class="toc-text">3、工作模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、主观下线和客观下线"><span class="toc-number">1.8.1.0.4.</span> <span class="toc-text">4、主观下线和客观下线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、配置哨兵模式"><span class="toc-number">1.8.1.0.5.</span> <span class="toc-text">5、配置哨兵模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6、Redis故障Master选举算法（了解）"><span class="toc-number">1.8.1.0.6.</span> <span class="toc-text">6、Redis故障Master选举算法（了解）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试"><span class="toc-number">1.9.</span> <span class="toc-text">面试:</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://l66stbz.github.io/2024/08/14/NoSQL-Redis/1.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">L66</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Photo</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">NoSQL-Redis</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2024-08-14 22:50:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2024-08-14</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2024-08-17 15:53:47"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2024-08-17</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Redis-缓存数据库"><a href="#Redis-缓存数据库" class="headerlink" title="Redis 缓存数据库"></a>Redis 缓存数据库</h1><p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>缓存数据库是一种<strong><code>位于应用程序与主要后端数据库之间的中间层，用于提高数据访问速度的技术</code></strong>。</p>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405131854766.png" alt="image-20240513185433565"></p>
<p>以下是一些关于缓存数据库的详细介绍： </p>
<ol>
<li><strong>作用</strong>：缓存数据库主要用于存储那些<code>频繁访问</code>或计算成本较高的数据副本。这些数据通常被放置在高速、低延迟的存储介质上，如内存中，以便快速访问。<code>加快访问速度 ,缓解关系型数据库的读压力</code>。</li>
<li><strong>使用场景</strong>：当应用程序需要数据时，首先会从<code>缓存</code>中查询。如果所需数据在<code>缓存</code>中存在，则可以直接获取，从而避免了<code>直接访问</code>主数据库的步骤，这可以显著减少数据<code>检索</code>的时间，并减轻主数据库的<code>负载</code>。</li>
<li><strong>常见类型</strong>：<ul>
<li><strong><code>Redis</code></strong>：它是一种非关系型（NoSQL）<code>内存键值</code>存储数据库，支持多种数据结构，包括字符串、哈希、列表等。Redis以其快速的读写能力和丰富的功能而闻名，适用于缓存、消息传递、会话存储等多种场景。</li>
<li><strong>Memcached</strong>：同样是键值对形式的内存缓存系统，设计相对简单，主要用于缓存常用数据，特别适应于分布式环境中的数据缓存需求。</li>
</ul>
</li>
<li><strong>优势</strong>：缓存数据库的使用可以减少数据库的<code>读取次数</code>，加快数据的处理速度，改善用户体验，并在高流量环境下保持系统的响应性和稳定性。</li>
</ol>
<blockquote>
<p><strong>注意事项</strong>：缓存数据库固然提供了许多好处，但也要注意数据一致性和缓存失效的问题。必须确保在适当的时候更新或清除缓存，以避免过时或错误的数据被使用。</p>
</blockquote>
<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a><strong>1、简介</strong></h3><p>NoSQL产品: <strong>Redis</strong>、<strong>MongoDB</strong>、<strong>Memcached</strong></p>
<ul>
<li>MongoDB：<ul>
<li><strong>基于文档的数据存储</strong>：MongoDB使用BSON（类似JSON）格式存储数据，这使得数据结构灵活且易于扩展。</li>
</ul>
</li>
</ul>
<p>NOSQL名词解释：非关系型数据库;<code>通常</code>是以键值对的方式存储数据（<strong>Key-Value</strong>）的形式。</p>
<h3 id="2、NoSQL的优点-缺点"><a href="#2、NoSQL的优点-缺点" class="headerlink" title="2、NoSQL的优点/缺点"></a>2、NoSQL的优点/缺点</h3><p>优点：</p>
<ul>
<li><strong>数据模型灵活性</strong><ul>
<li>NoSQL数据库不需要<code>预先定义表结构</code>，可以根据实际需求动态调整<code>数据类型</code>。</li>
</ul>
</li>
<li><strong>高可扩展性</strong><ul>
<li>NoSQL数据库采用<code>分布式</code>架构，可以通过水平扩展来处理<code>大规模</code>数据和<code>高并发</code>读写。通过在集群中添加更多的节点，可以提高数据库的性能和容量。这种高可扩展性使得NoSQL数据库适用于大规模数据处理和高并发场景，可以满足业务的快速增长需求。</li>
</ul>
</li>
<li><strong>高性能</strong><ul>
<li>NoSQL数据库通常采用<code>内存存储</code>，以及并行计算和<code>分布式</code>计算技术，可以提供高性能的数据存储和查询能力。在对数据进行读取和写入操作时，NoSQL数据库可以快速响应，提供低延迟的数据访问。</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>一致性问题</code><ul>
<li>NoSQL数据库通常采用最终一致性的策略，即在一段时间内达到一致状态，可以容忍一定的数据不一致性。在数据更新和复制过程中，可能会出现数据不一致的情况。</li>
</ul>
</li>
<li>查询能力限制<ul>
<li>NoSQL数据库的查询能力相对较弱，通常只支持基本的查询操作。与传统关系型数据库相比，NoSQL数据库缺少复杂的查询操作和聚合函数。在需要进行复杂的数据查询和分析的场景中，NoSQL数据库的查询能力可能无法满足需求。</li>
</ul>
</li>
<li>缺乏标准化<ul>
<li>NoSQL数据库的种类繁多，没有一个统一的标准化规范。不同的NoSQL数据库具有不同的查询语言。</li>
</ul>
</li>
</ul>
<h3 id="3、关系型数据库与非关系型数据库的区别：———面试高频率问题"><a href="#3、关系型数据库与非关系型数据库的区别：———面试高频率问题" class="headerlink" title="3、关系型数据库与非关系型数据库的区别：———面试高频率问题"></a>3、关系型数据库与非关系型数据库的区别：———面试高频率问题</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.首先了解一下 什么是关系型数据库？</span><br><span class="line">关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">1、易于维护：都是使用表结构，格式一致；</span><br><span class="line">2、使用方便：SQL语言通用，可用于复杂查询；</span><br><span class="line">3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</span><br><span class="line">缺点：</span><br><span class="line">1、读写性能比较差，尤其是海量数据的高效率读写；</span><br><span class="line">2、固定的表结构，灵活度稍欠；</span><br><span class="line">3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈；</span><br><span class="line"></span><br><span class="line">二 非关系型数据库</span><br><span class="line">什么非关系型数据库呢？</span><br><span class="line"></span><br><span class="line">非关系型数据是一种数据结构化存储方法的集合，可以是文档或者键值对等</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</span><br><span class="line">2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；</span><br><span class="line">3、高扩展性；</span><br><span class="line">4、成本低：nosql数据库部署简单，基本都是开源软件。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1、不提供sql支持，学习和使用成本较高；</span><br><span class="line">2、无事务处理；</span><br><span class="line">3、数据结构相对复杂，复杂查询方面稍欠。</span><br></pre></td></tr></table></figure>

<h2 id="2、Memcached"><a href="#2、Memcached" class="headerlink" title="2、Memcached"></a>2、Memcached</h2><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ol>
<li><code>分布式缓存</code><br>Memcached是一个分布式的缓存系统，可以将<code>数据存储</code>在多个服务器上，从而提供更高的<code>可用性</code>和<code>可扩展</code>性。</li>
<li><code>内存存储</code><br>Memcached将缓存数据存储在<code>内存</code>中，因此读取速度<code>非常快</code>，适用于需要快速访问的数据。由于数据存储在内存中，读取速度非常快，适用于缓存热点数据。但是服务器重启后，数据会丢失。</li>
<li>键值存储<br>Memcached采用键值对存储数据，通过键(key)快速定位和检索数据值(value)。</li>
<li>自动过期<br>缓存数据可以设置过期时间，过期后自动从缓存中移除，避免数据过时或脏数据的问题。</li>
<li><code>缓存逐出策略</code><br>当内存不足时，Memcached会根据一定的策略逐出部分数据，为新数据腾出空间。</li>
</ol>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405131914933.png" alt></p>
<h3 id="2-2-服务框架"><a href="#2-2-服务框架" class="headerlink" title="2.2 服务框架"></a>2.2 服务框架</h3><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405131914275.png" alt></p>
<p><strong>原理</strong></p>
<p>1、检查客户端的请求数据是否在memcached中，如有，直接把请求2数据返回，不再对数据库进行任何操作，路径操作为①②③⑦。<br>2、如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现），路径操作为①②④⑤⑦⑥。</p>
<p>3、保持缓存的<code>新鲜性</code>，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步更新的缓存信息，确保用户不会在缓存取到旧的数据。</p>
<h3 id="2-3-配置安装Memcached"><a href="#2-3-配置安装Memcached" class="headerlink" title="2.3 配置安装Memcached"></a>2.3 配置安装Memcached</h3><p>memcache能存放多少数据，取决于服务器本身的内存有多大。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1.安装----准备一台服务器</span><br><span class="line">[root@memcached ~]# yum install memcached -y</span><br><span class="line">[root@memcached ~]# systemctl start memcached  #启动</span><br><span class="line">2.修改配置文件</span><br><span class="line">[root@memcached ~]# vim /etc/sysconfig/memcached</span><br><span class="line">PORT="11211"    ---监听的端口，默认11211可以修改</span><br><span class="line">USER="memcached"  -----用户</span><br><span class="line">MAXCONN="1024"   -----默认并发，可以修改</span><br><span class="line">CACHESIZE="64"    ------给的内存。默认是M</span><br><span class="line">OPTIONS=""       ----监听的网络地址</span><br><span class="line">然后把ip地址发给开发人员，开发的会使用api接口连接memcached.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装telent,Telnet是一种用于远程登录的协议。传输数据是明文的，存在安全性问题。</span></span><br><span class="line">[root@memcached ~]# yum install -y telnet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 测试</span></span><br><span class="line">[root@memcached ~]# telnet 192.168.246.188 11211</span><br><span class="line">Trying 192.168.246.188...</span><br><span class="line">Connected to 192.168.246.188.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">set name 0 60 10    # key名   标记位(id号)   过期时间  大小</span><br><span class="line">helloworld        #  name的key值</span><br><span class="line">STORED         # 出现stoped表示已经存储成功。</span><br><span class="line">get name       #查询key值</span><br><span class="line">VALUE name 0 10</span><br><span class="line">helloword</span><br><span class="line">END</span><br><span class="line">quit   ---退出</span><br><span class="line">参数解释:</span><br><span class="line"><span class="meta">#</span><span class="bash"> name：key的名字 自己定义</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0：key的id号，需要和其他的key不一样</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 60：缓存过期时间,单位为秒，0为永远</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9：字符串最大长度</span></span><br><span class="line"></span><br><span class="line">不用它的原因：存储的数据类型单一，而且数据只能存储在内存中。无法实现数据的持久化，服务器重启，数据将消失。</span><br><span class="line">========================================================================</span><br><span class="line">扩展:安装php支持memcached的扩展模块: 安装php7.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装PHP依赖的epel源</span></span><br><span class="line">[root@memcached ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装PHP yum源</span></span><br><span class="line">[root@memcached ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装PHP</span></span><br><span class="line">[root@memcached ~]# yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 php70w-devel zlib-devel make gcc zlib-devel libmemcached-devel git php70w-fpm -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 下载PHP Memcache 扩展包</span></span><br><span class="line">[root@memcached ~]# yum install libmemcached php70w-pecl-memcached -y</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装nginx</span></span><br><span class="line">[root@memcached ~]# yum -y install nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 配置默认界面</span></span><br><span class="line">[root@memcached ~]# vim /etc/nginx/conf.d/default.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        root           /usr/share/nginx/html;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编辑php页面</span></span><br><span class="line">[root@memcached ~]# cd /usr/share/nginx/html/index.php</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动服务</span></span><br><span class="line">[root@memcached ~]# systemctl enable --now nginx php-fpm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>游览器访问：<a href="http://192.168.174.38/index.php" target="_blank" rel="noopener">http://192.168.174.38/index.php</a></p>
</blockquote>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408131446837.png" alt="image-20240813144523867"></p>
<h2 id="3、Redis服务"><a href="#3、Redis服务" class="headerlink" title="3、Redis服务"></a>3、Redis服务</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p><strong>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库</strong>，它支持多种数据结构，如<code>字符串</code>（strings）、<code>散列</code>（hashes）、列表</p>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/4c8ac61a7ac746b693b4237ed8b9b7f5.png" alt="img"></p>
<p><strong>redis的官网：</strong><a href="http://www.redis.io" target="_blank" rel="noopener">www.redis.io</a></p>
<h4 id="3-1-1-redis的特点"><a href="#3-1-1-redis的特点" class="headerlink" title="3.1.1 redis的特点:"></a>3.1.1 redis的特点:</h4><ul>
<li><strong>高性能</strong>：由于数据存储在内存中，Redis能够实现<code>微秒级</code>的读写速度。</li>
<li><strong>持久化</strong>：虽然数据主要<code>存储</code>在<code>内存</code>中，但Redis提供了数据<code>持久化</code>的功能，可以将内存中的数据定期保存到<code>磁盘</code>中，以防止<code>数据丢失</code>。</li>
<li><strong>支持丰富数据类型</strong>：除了基本的键值对存储，Redis还支持列表、集合、有序集合等多种数据结构，这使得它能够适应更多样的应用场景。</li>
<li><strong>原子性操作</strong>：Redis的所有操作都是<code>原子性</code>的，这意味着每一个操作都将完整地执行，不会被其他客户端的命令所干扰，确保了数据的一致性和完整性。</li>
</ul>
<h4 id="3-1-2-Redis和memcached区别（面试题）"><a href="#3-1-2-Redis和memcached区别（面试题）" class="headerlink" title="3.1.2 Redis和memcached区别（面试题）"></a>3.1.2 Redis和memcached区别（面试题）</h4><ul>
<li><strong>数据结构</strong>：Redis提供了更丰富的数据类型，包括<code>字符串</code>、<code>列表</code>、<code>集合</code>、<code>有序集合</code>和<code>散列</code>等，而Memcached主要支持简单的<code>键值对结构</code>。这使得Redis能够支持更复杂的数据操作，减少网络IO次数和数据体积。</li>
<li><strong>数据持久化</strong>：Memcached不支持数据<code>持久化</code>，服务器重启后数据会<code>丢失</code>，但这使得它在运行时拥有更高的性能。相比之下，Redis支持数据持久化到磁盘，提供了数据的恢复能力，但这也意味着它需要承担额外的<code>性能开销</code>。</li>
<li><strong>性能考虑</strong>：Memcached在存储大数据时性能更高，因为它的<code>内存管理</code>机制简单高效。而Redis虽然在处理大量数据时性能有所下降，但它提供了更多的<code>数据结构</code>和操作。</li>
<li><strong>应用场景</strong>：Memcached通常用于<code>缓存系统</code>中，以减轻数据库的读负载，适合<code>多读少写</code>的场景。而Redis不仅适用于缓存，还适用于对<code>读写效率</code>要求高、数据处理复杂和对<code>安全</code>性要求较高的系统。</li>
</ul>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2350b528a088429d972d2fdcfe6e18d3.jpeg" alt="img"></p>
<h2 id="4、安装Redis"><a href="#4、安装Redis" class="headerlink" title="4、安装Redis"></a>4、安装Redis</h2><h3 id="4-1-安装单机版redis"><a href="#4-1-安装单机版redis" class="headerlink" title="4.1  安装单机版redis"></a>4.1  安装单机版redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 下载redis安装包</span></span><br><span class="line">[root@redis-master ~]# wget https://download.redis.io/releases/redis-6.2.7.tar.gz   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 解压安装包到指定目录</span></span><br><span class="line">[root@redis-master ~]# tar xzf redis-6.2.7.tar.gz -C /usr/local/ &amp;&amp; cd /usr/local   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建软链接</span></span><br><span class="line">[root@localhost local]# ln -s redis-6.2.7 redis</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 切换redis家目录</span></span><br><span class="line">[root@localhost local]# cd redis/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装编译环境</span></span><br><span class="line">[root@redis-master redis]# yum install -y gcc make</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编译</span></span><br><span class="line">[root@redis-master redis]# make</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 备份文件</span></span><br><span class="line">[root@redis-master redis]# cp redis.conf redis.conf.bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-master redis]# vim redis.conf</span><br><span class="line">bind 192.168.246.202     # 只监听内网IP</span><br><span class="line">daemonize yes            # 开启后台模式将no改为yes</span><br><span class="line">port 6379                # 端口号</span><br><span class="line">dir /data/redis/data     # 本地数据库存放持久化数据的目录该目录需要存在创建存放数据的目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 配置systemctl的redis启动脚本</span></span><br><span class="line">[root@redis-master redis]# cat &gt;&gt; /lib/systemd/system/redis.service &lt;&lt;-EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/redis/src/redis-server /usr/local/redis/redis.conf  --daemonize no</span><br><span class="line">ExecStop=/usr/local/redis/src/redis-cli -h 127.0.0.1 -p 6379 shutdown</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">E</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 重新加载并且启动服务</span></span><br><span class="line">[root@redis-master system]# systemctl daemon-reload</span><br><span class="line">[root@redis-master system]# systemctl enable --now redis</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564302473951.png#id=m3S85&originHeight=202&originWidth=1195&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 登陆redis</span></span><br><span class="line">[root@redis-master system]# cd /usr/local/redis/src/</span><br><span class="line">[root@redis-master src]# ./redis-cli -h 192.168.246.202 -p 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 测试redis是否可以用</span></span><br><span class="line">192.168.246.202:6379&gt; ping    </span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 设置key--name，并设置值</span></span><br><span class="line">192.168.246.202:6379&gt; set name xiaoming    </span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 获取到key</span></span><br><span class="line">192.168.246.202:6379&gt; get name    </span><br><span class="line">"xiaoming"</span><br><span class="line"></span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">192.168.246.202:6379&gt; set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释：</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> EX seconds ： 将键的过期时间设置为 seconds 秒。默认为秒；</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。默认为毫秒；</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> NX ： 只在键不存在时， 才对键进行设置操作。</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> XX ： 只在键已经存在时， 才对键进行设置操作。会覆盖原有的values值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash">&gt;&gt;&gt; 使用 EX 选项：</span></span><br><span class="line">[root@localhost src]# ./redis-cli -h 192.168.62.231 -p 6379</span><br><span class="line">192.168.62.231:6379&gt; set name1 xiaohong EX 10</span><br><span class="line">OK</span><br><span class="line">192.168.62.231:6379&gt; get name1</span><br><span class="line">"xiaohong"</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash">&gt;&gt;&gt; 等待10s，再次查看</span></span><br><span class="line">192.168.62.231:6379&gt; get name1</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash">&gt;&gt;&gt; 使用 PX 选项：</span></span><br><span class="line">192.168.62.231:6379&gt; set name2 xiaohong PX 3233</span><br><span class="line">OK</span><br><span class="line">192.168.62.231:6379&gt; get name2</span><br><span class="line">"xiaohong"</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash">&gt;&gt;&gt; 等待3s，再次查看</span></span><br><span class="line">192.168.62.231:6379&gt; get name2</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash">&gt;&gt;&gt;  NX 选项：</span></span><br><span class="line">192.168.62.231:6379&gt; set class 2204 NX</span><br><span class="line">OK # 键不存在，设置成功</span><br><span class="line">192.168.62.231:6379&gt; get class</span><br><span class="line">"2204"</span><br><span class="line">192.168.62.231:6379&gt; set class 2205 NX</span><br><span class="line">(nil)  # 键已经存在，设置失败</span><br><span class="line">192.168.62.231:6379&gt; get class</span><br><span class="line">"2204"  # 维持原值不变</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash">&gt;&gt;&gt; XX 选项：</span></span><br><span class="line">192.168.62.231:6379&gt; set home taikang XX</span><br><span class="line">(nil)  # 因为键不存在，设置失败</span><br><span class="line">192.168.62.231:6379&gt; set home taikang</span><br><span class="line">OK # 先给键设置一个值</span><br><span class="line">192.168.62.231:6379&gt; set home zhengzhou XX</span><br><span class="line">OK # 设置新值成功</span><br><span class="line">192.168.62.231:6379&gt; get home</span><br><span class="line">"zhengzhou"</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash">&gt;&gt;&gt; 删除key</span></span><br><span class="line">192.168.62.231:6379&gt; del class</span><br><span class="line">(integer) 1</span><br><span class="line">192.168.62.231:6379&gt; get class</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 切换数据库</span></span><br><span class="line">127.0.0.1:6379[1]&gt; SELECT 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看当前库所有的数据</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br></pre></td></tr></table></figure>



<h3 id="4-2-redis的相关工具"><a href="#4-2-redis的相关工具" class="headerlink" title="4.2  redis的相关工具"></a><strong>4.2  redis的相关工具</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli           # redis的客户端</span><br><span class="line">./redis-server        # redis的服务端</span><br><span class="line">./redis-check-aof     # 用于修复出问题的AOF文件</span><br><span class="line">./redis-sentinel      # 用于集群管理</span><br></pre></td></tr></table></figure>





<h2 id="5、Redis设置密码的两种方式"><a href="#5、Redis设置密码的两种方式" class="headerlink" title="5、Redis设置密码的两种方式"></a>5、Redis设置密码的两种方式</h2><p>Redis修改密码的方式主要有两种：使用<code>redis-cli</code>命令行工具和通过配置文件。</p>
<h3 id="5-1-命令行临时修改密码"><a href="#5-1-命令行临时修改密码" class="headerlink" title="5.1 命令行临时修改密码"></a><strong>5.1 命令行临时修改密码</strong></h3><ol>
<li><strong>登录Redis</strong>：首先，你需要使用当前没有密码的Redis客户端登录到Redis服务器。</li>
<li><strong>设置新密码</strong>：使用<code>CONFIG SET</code>命令来设置新的密码。例如，要设置密码为<code>qfyyds</code>，你可以执行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET requirepass <span class="string">"qfyyds"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 密码使用方式</span></span><br><span class="line">	<span class="comment">#&gt;&gt;&gt; 方式一：</span></span><br><span class="line">192.168.174.48:6379&gt; AUTH qfyyds</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">	<span class="comment">#&gt;&gt;&gt; 方式二：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># redis-cli  -h 192.168.174.48  -p 6379 -a qfyyds</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意：这种方式设置的密码只会<code>临时生效</code>，重启Redis服务后密码会失效。</p>
</blockquote>
<h3 id="5-2-配置文件永久修改密码"><a href="#5-2-配置文件永久修改密码" class="headerlink" title="5.2 配置文件永久修改密码"></a><strong>5.2 配置文件永久修改密码</strong></h3><ol>
<li><strong>找到Redis配置文件</strong>：通常，Redis的配置文件名为<code>redis.conf</code>，它位于Redis安装目录或数据目录中。</li>
<li><strong>编辑配置文件</strong>：编辑<code>redis.conf</code>。</li>
<li><strong>设置密码</strong>：在配置文件中找到<code># requirepass foobared</code>这一行（没有<code>#</code>注释符号），将<code>foobared</code>替换为你想要设置的新密码。例如，设置为<code>afyyds</code>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># vim redis.conf</span></span><br><span class="line">···</span><br><span class="line">requirepass qfyyds</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重启服务</span></span><br><span class="line">[root@localhost redis]<span class="comment"># systemctl restart redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看服务状态</span></span><br><span class="line">[root@localhost redis]<span class="comment"># systemctl status redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试</span></span><br><span class="line">[root@localhost src]<span class="comment"># ./redis-cli </span></span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth qfyyds</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line"><span class="string">"zhangsan"</span></span><br></pre></td></tr></table></figure>

<p><strong>保存并重启Redis</strong>：保存配置文件并重启Redis服务，新的密码设置就会生效。</p>
<blockquote>
<p>注意事项：在修改密码后，确保所有客户端都已更新为使用新密码进行<code>连接</code>，否则可能会出现认证失败的问题。</p>
</blockquote>
<hr>
<h3 id="5-3-Redis配置文件详解"><a href="#5-3-Redis配置文件详解" class="headerlink" title="5.3 Redis配置文件详解"></a>5.3 Redis配置文件详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># egrep -v "^#|^$" redis.conf</span></span><br><span class="line"><span class="comment"># 设置Redis服务器监听所有IP地址，即允许任何客户端连接。</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 关闭保护模式，允许非本机客户端连接。</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 设置Redis服务器监听的端口号为6379。</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 设置TCP连接队列的大小为511，即允许最多有511个连接等待被处理。</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"><span class="comment"># 设置超时时间</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="comment"># 设置TCP心跳间隔为300秒。</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"><span class="comment"># 以守护进程方式运行Redis服务器。</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 指定Redis服务器的进程ID文件路径。</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"><span class="comment"># 设置日志级别为notice，只记录警告和错误信息。</span></span><br><span class="line">loglevel notice</span><br><span class="line"><span class="comment"># 指定日志文件的路径。</span></span><br><span class="line">logfile <span class="string">"/var/log/redis.log"</span></span><br><span class="line"><span class="comment"># 设置Redis支持的数据库数量为16个。</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="comment"># 在后台保存出错时停止写入操作。</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="comment"># rdbcompression yes：启用RDB文件压缩。</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment"># 在RDB文件中包含CRC64校验和</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="comment"># 指定RDB文件的名称。</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># 不删除同步生成的RDB文件。</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"><span class="comment"># 指定RDB文件和AOF文件的存储目录。</span></span><br><span class="line">dir /data/redis/data</span><br><span class="line"><span class="comment"># 设置副本节点为只读模式。</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"><span class="comment"># 设置密码为"qfyyds"，用于验证客户端连接。</span></span><br><span class="line">requirepass qfyyds</span><br><span class="line"><span class="comment"># 禁用AOF持久化。</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># 指定AOF文件的名称。</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"><span class="comment"># 每秒执行一次fsync操作，将缓冲区的数据写入磁盘。</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>



<h2 id="6、数据持久化"><a href="#6、数据持久化" class="headerlink" title="6、数据持久化"></a>6、数据持久化</h2><p>Redis是一个内存数据库，一旦断电或服务器进程退出，内存数据库中的数据将<code>全部丢失</code>，所以需要redis持久化；Redis持久化就是把<code>数据保存在磁盘上</code>，利用<code>永久性存储介质</code>将数据保存，在特定的时间将保存的数据进行恢复的工作机制。</p>
<h3 id="6-1-redis持久化-–-两种方式"><a href="#6-1-redis持久化-–-两种方式" class="headerlink" title="6.1 redis持久化 – 两种方式"></a><strong>6.1 redis持久化 – 两种方式</strong></h3><h4 id="6-1-1-RDB"><a href="#6-1-1-RDB" class="headerlink" title="6.1.1  RDB"></a>6.1.1  RDB</h4><p>​    在指定的时间间隔内将内存中的数据集写入磁盘，也就是<code>快照</code>(Snapshot),数据恢复是将快照文件直接读到<code>内存中</code>redis会单独创建(<code>fork</code>)一个<code>子进程</code>来进行<code>持久化</code>，会先将数据写入一个到一个<code>临时文件</code>(dump.rdb)中,待持久化过程结束后，再用本次的临时文件替换上次持久化后的文件。</p>
<p><code>fork函数</code>的作用是复制一个与当前进程一样的进程，新进程的所有数据数值都和原进程一致，但是一个全新的进程，并作为<code>原进程的子进程</code>。</p>
<p>redis服务器在处理<code>bgsave</code>采用<code>子线程</code>进行IO写入，而主进程仍然可以接收其他请求，但创建子进程是同步阻塞的，此时不接受其他请求。</p>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2231965-20221006153432205-771654931.png" alt="img"></p>
<blockquote>
<p><code>save</code>: 该命令会阻塞当前redis服务器，执行save命令期间，redis不能处理其他命令，直到RDB过程结束为止(会造成长时间阻塞，不建议使用)</p>
<p> <code>bgsave</code>:该命令执行后，redis会在后台异步进行快照操作，快照同时还可以响应客户端的请求，阻塞只发生在fork阶段，基本上redis内部的所有RDB操作都是采用bgsave命令。</p>
</blockquote>
<h5 id="1-RDB持久化配置"><a href="#1-RDB持久化配置" class="headerlink" title="1.  RDB持久化配置"></a>1.  RDB持久化配置</h5><p>​    RDB持久化默认开启，但是需要配置触发规则。如下列代码所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@redis-master redis]<span class="comment"># vim /usr/local/redis/redis.conf</span></span><br><span class="line">···</span><br><span class="line"><span class="comment"># dbfilename：持久化数据存储在本地的文件</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir：持久化数据存储在本地的路径,可自定义</span></span><br><span class="line">dir /data/redis/data</span><br><span class="line"></span><br><span class="line"><span class="comment">##snapshot触发的时机，save &lt;seconds&gt; &lt;changes&gt; </span></span><br><span class="line"><span class="comment">##对于此值的设置，需要谨慎，评估系统的变更操作密集程度  </span></span><br><span class="line"><span class="comment">##可以通过save “”来关闭snapshot功能  </span></span><br><span class="line"><span class="comment"># 900秒内如果至少有一个key进行了修改则进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 300秒内如果至少有10个key进行了修改则进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 60秒内，如果至少有10000个key进行了修改则进行持久化操作</span></span><br><span class="line">save 60 10000 </span><br><span class="line"></span><br><span class="line"><span class="comment">##yes代表当使用bgsave命令持久化出错时候停止写RDB快照文件,no表明忽略错误继续写文件，“错误”可能因为磁盘已满/磁盘故障/OS级别异常等</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment">##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，同时也意味着较短的网络传输时间  </span></span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>

<h5 id="2-RDB持久化数据恢复"><a href="#2-RDB持久化数据恢复" class="headerlink" title="2. RDB持久化数据恢复"></a>2. RDB持久化数据恢复</h5><p>​    将备份文件(dump.rdb)移动到redis路径下(可以配置文件的存放路径)启动服务即可，redis启动会将文件数据加载到内存，在此期间redis会处于阻塞状态，直到全部数据存入内存。</p>
<h5 id="3-RDB持久化的优缺点"><a href="#3-RDB持久化的优缺点" class="headerlink" title="3. RDB持久化的优缺点"></a>3. RDB持久化的优缺点</h5><ul>
<li><p>优点：</p>
<ul>
<li><p>数据恢复快；</p>
</li>
<li><p>体积小；</p>
</li>
<li><p>数据备份使用子进程，对redis服务性能影响小。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>在一定时间间隔进行备份，当redis意外宕机，将会丢失最后一次修改的数据，无法做到秒级持久化；</li>
<li>fork进程时，会占用一定的内存空间；</li>
<li>RDB文件是二进制的没有可读性。</li>
</ul>
</li>
</ul>
<h4 id="6-1-2-AOF"><a href="#6-1-2-AOF" class="headerlink" title="6.1.2 AOF"></a>6.1.2 AOF</h4><p>​    将客户端的每一个<strong>写操作命令</strong>以日志的形式记录下来，追加到<code>appendonly.aof</code>的文件末尾，在redis服务器重启时，会加载aof文件中的所有命令，来达到数据恢复的目的。</p>
<p>当有写命令请求时，会追加到AOF缓冲区内，AOF缓冲区根据AOF持久化策略[<code>always</code>,<code>everysec</code>,<code>no</code>]将操作同步到磁盘的AOF文件中，当AOF文件大小超过重写策略或手动重写时，会对AOF文件进行重写来压缩AOF文件容量，redis服务重启时，会重新加载AOF文件中的写操作来进行数据恢复。</p>
<img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2231965-20221006153451739-1327556975.png" alt="img">

<h5 id="1-AOF持久化策略"><a href="#1-AOF持久化策略" class="headerlink" title="1. AOF持久化策略"></a>1. AOF持久化策略</h5><ul>
<li><code>always</code>: 把每个写命令立即同步到AOF文件，很慢但安全；</li>
<li><code>everysec</code>: 每秒同步一次，默认配置；</li>
<li><code>no</code>: redis不执行写入磁盘。</li>
</ul>
<h5 id="2-AOF的触发方式"><a href="#2-AOF的触发方式" class="headerlink" title="2. AOF的触发方式"></a>2. AOF的触发方式</h5><ol>
<li>手动触发<code>bgrewriteaof</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGREWRITEAOF</span><br><span class="line">Background append only file rewriting started</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost data]<span class="comment"># stat appendonly.aof </span></span><br><span class="line">  文件：<span class="string">"appendonly.aof"</span></span><br><span class="line">  大小：112       	块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fd00h/64768d	Inode：17874728    硬链接：1</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">最近访问：2024-05-14 22:03:51.707774066 +0800</span><br><span class="line">最近更改：2024-05-14 22:03:51.707774066 +0800</span><br><span class="line">最近改动：2024-05-14 22:03:51.818774763 +0800</span><br></pre></td></tr></table></figure>



<p><strong>默认情况，redis是没有开启AOF(默认使用RDB持久化)，需要通过配置文件开启。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 是否开启 Redis AOF持久化，默认为no</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; AOF持久化文件名</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; AOF持久化策略，默认为eveysec，每秒同步一次</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Always</strong>：每次执行<code>写入操作</code>后，都会立即调用fsync将数据<code>同步到磁盘</code>。这确保了极高的数据<code>持久性</code>，因为即使在系统崩溃的情况下，也最多只会丢失一次写入操作的数据。然而，这种模式会对性能产生较大影响，因为在每次写入后都进行fsync会导致较高的I/O开销。</li>
<li><strong>Everysec</strong>：这是默认设置，<code>每秒</code>执行一次fsync。它在性能和持久性之间取得了平衡，既保证了较好的数据安全性，又避免了频繁的I/O操作对性能的影响。</li>
<li><strong>No</strong>：不做持久化</li>
</ul>
<h5 id="3-AOF的重写机制"><a href="#3-AOF的重写机制" class="headerlink" title="3. AOF的重写机制"></a>3. AOF的重写机制</h5><p>​    AOF持久化，会把每次写命令都<code>追加</code>到<code>appendonly.aof</code>文件中，当文件过大，redis的数据恢复时间就会变长，因此加入重写策略对aof文件进行重写，生成一个恢复当前数据的最少命令集。<code>通过压缩AOF文件里面的相同指令保留最新的一个数据操作指令，即将存储了某个key的多次变更记录。只是存储最新的变更记录即可，丢弃历史变更记录 。</code></p>
<p>​        <img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2231965-20221006153525610-1156564768.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis 重写机制配置</span></span><br><span class="line">[root@localhost redis]<span class="comment">#  vim redis.conf</span></span><br><span class="line">···</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><strong>auto-aof-rewrite-percentage</strong>：当前 AOF 文件大小超过上次重写后 AOF 文件大小的百分比时，触发 AOF 重写机制<strong>，默认值为 100 。</strong></li>
<li><strong>auto-aof-rewrite-min-size</strong>：表示当当前 AOF 文件大小超过指定值时，才可能触发 AOF 重写机制，<strong>默认值为 64 MB 。</strong></li>
</ol>
<ul>
<li>系统自动触发 AOF 重写机制还需要满足以下条件 ：<ul>
<li><code>当前没有正在执行 BGSAVE 或 BGREWRITEAOF 的子进程</code></li>
<li><code>当前没有正在执行 SAVE 的主进程</code></li>
<li><code>当前没有正在进行集群切换或故障转移</code></li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="3-1-Redis-AOF-重写机制原理"><a href="#3-1-Redis-AOF-重写机制原理" class="headerlink" title="3.1 Redis AOF 重写机制原理"></a>3.1 Redis AOF 重写机制原理</h6><p>Redis AOF（Append Only File）重写流程是一个<code>用于优化</code>和<code>压缩AOF文件</code>的过程，以减少存储空间和提高写入效率。以下是AOF重写的流程：</p>
<ol>
<li><p>触发条件：当满足一定条件时，Redis会自动触发AOF重写。常见的触发条件包括<code>文件大小超过阈值</code>、系统负载较低等。</p>
</li>
<li><p>创建子进程：<code>Redis启动一个子进程进行AOF重写操作。这个子进程与主进程并行运行，不会阻塞主进程的处理</code>。</p>
</li>
<li><p>遍历数据库：<code>子进程开始遍历Redis数据库中的所有键值对</code>。这个过程中，子进程会记录下每个键值对的操作命令，但不会执行这些命令。</p>
</li>
<li><p>生成重写缓冲区：在遍历数据库的过程中，<code>子进程会将记录的操作命令写入一个临时文件，即重写缓冲区。这个临时文件最终会成为新的AOF文件。</code></p>
</li>
<li><p>同步命令到主进程：<code>在重写过程中，子进程会将部分命令同步回主进程，以确保主进程和子进程的数据一致性。</code>这是通过Redis的内部机制实现的，确保在重写过程中主进程的数据不会被破坏。</p>
</li>
<li><p>重写AOF文件：当子进程遍历完整个数据库并生成重写缓冲区后，它会根据一定的规则对缓冲区中的命令进行优化和压缩，生成新的AOF文件。这个<code>新文件会替换原有的AOF文件，具有更小的体积和更高的写入效率</code>。</p>
</li>
<li><p>更新配置：<code>一旦新的AOF文件生成并替换原有的文件，Redis会更新其配置信息，将新的AOF文件名写入配置文件中。</code>这样，在下次启动时，Redis就会使用新的AOF文件作为持久化存储。</p>
</li>
<li><p><strong>AOF重写机制带来优点</strong></p>
</li>
</ol>
<p>通过AOF重写流程，Redis可以有效地优化和压缩AOF文件，减少存储空间的使用，并提高写入效率。同时，由于重写过程是在子进程中进行的，不会阻塞主进程的处理，因此对Redis的性能影响较小。</p>
<p><strong>白话文解释：</strong></p>
<ul>
<li>旧AOF文件过大触发重写机制</li>
<li>创建子进程构建一个新的aof文件</li>
<li>子进程读取当前redis里面的数据，写入到新的aof文件里面</li>
<li>读取redis数据期间，主进程如果有其他新的操作指令则写入重写缓存中</li>
<li>重写完成以后，将重写缓存追加到新的aof文件中</li>
<li>用新的aof文件覆盖现有的aof文件 </li>
</ul>
<h5 id="4-AOF的优点和缺点"><a href="#4-AOF的优点和缺点" class="headerlink" title="4. AOF的优点和缺点"></a>4. AOF的优点和缺点</h5><p>​    优点：</p>
<ul>
<li><p>数据安全性高，不易丢数据；</p>
</li>
<li><p>AOF文件有序保存了所有写操作，可读性强。</p>
<p>缺点：</p>
</li>
<li><p>AOF方式生成文件体积大；</p>
</li>
<li><p>数据恢复速度比RDB慢。</p>
</li>
</ul>
<p>持久化配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3、AOF默认关闭--开启</span><br><span class="line">[root@redis-master src]# cd ..</span><br><span class="line">[root@redis-master redis]# vim redis.conf</span><br><span class="line">修改如下:</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564304309935.png#id=WCMEC&originHeight=149&originWidth=362&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能,只有在“yes”下，aof重写/文件同步等特性才会生效</span><br><span class="line">====================================</span><br><span class="line">2、指定aof文件名称</span><br><span class="line">appendfilename appendonly.aof  </span><br><span class="line">====================================</span><br><span class="line">3、指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec</span><br><span class="line">appendfsync everysec</span><br><span class="line">always     #每次有数据修改发生时都会写入AOF文件</span><br><span class="line">everysec   #每秒钟同步一次，该策略为AOF的缺省策略/默认策略</span><br><span class="line">no         #从不同步。高效但是数据不会被持久化</span><br></pre></td></tr></table></figure>

<p><strong>开启持久化功能后，重启redis后，数据会自动通过持久化文件恢复。<code>RDB是默认持久化方式，但 Redis 允许 RDB 与 AOF 两种持久化技术同时开启。不过如果同时存在两种持久化方式，会默认采取AOF的方式，AOF持久化方式的优先级更高。</code></strong></p>
<p><strong>拓展RDB快照备份恢复：</strong></p>
<p>redis数据库备份与恢复（dump.rdb快照方式），两台机器</p>
<p><strong>备份Redis实例配置</strong></p>
<ol>
<li><strong>备份redis实例操作</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 备份机器的redis.conf配置文件内容</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim  /usr/local/redis/redis.conf </span></span><br><span class="line">···</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /data/redis/data</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ./src/redis-cli </span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zhangsan</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BGSAVE </span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls /data/redis/data</span></span><br><span class="line">dump.rdb</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># scp /data/redis/data/dump.rdb 192.168.174.49:/data/redis/data/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>恢复Redis实例配置</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 配置文件修改</span></span><br><span class="line">[root@redis-backup ~]<span class="comment"># vim /usr/local/redis/redis.conf </span></span><br><span class="line">···</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /data/redis/data/</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">daemonize yes</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;启动实例</span></span><br><span class="line">[root@redis-backup ~]<span class="comment"># cd /usr/local/redis/src/</span></span><br><span class="line">[root@redis-backup redis]<span class="comment"># ./src/redis-server redis.conf </span></span><br><span class="line">[root@redis-backup redis]<span class="comment"># ./src/redis-cli </span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br></pre></td></tr></table></figure>





<h2 id="7、Redis主从配置"><a href="#7、Redis主从配置" class="headerlink" title="7、Redis主从配置"></a>7、Redis主从配置</h2><h3 id="7-1-主从简介"><a href="#7-1-主从简介" class="headerlink" title="7.1 主从简介"></a>7.1 主从简介</h3><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240418113140326.png" alt="image-20240418113140326" style="zoom:50%;">

<p>持久化技术只是解决了Redis服务故障之后，快速数据恢复的问题。宕机和数据恢复的过程中整个业务系统来说，还是有损失的，并没有根本上提升可用性问题，而且持久化技术对于Redis服务性能来说是有损的。我们需要的是保障<code>Redis的高可用</code>，减少甚至避免Redis服务<code>发生宕机</code>的可能。</p>
<p>目前实现Redis高可用的模式主要有三种： <code>主从模式</code>、<code>哨兵模式</code>、<code>集群模式</code>。我们先来聊一下主从模式。<br>Redis 提供的主从模式，是通过复制的方式，将主服务器上的Redis的数据同步复制一份到从 Redis 服务器，这种做法很常见，MySQL通过binlog进行的主从复制也是这么做的。<br>主节点的Redis我们称之为master，从节点的Redis我们称之为slave，<code>主从复制为单向复制，只能由主到从，不能由从到主。</code>可以有多个从节点，比如1主3从甚至n从，从节点的多少根据实际的业务需求来判断。</p>
<p>主从结构，一是为了纯粹的<code>冗余备份</code>，二是为了<code>提升读性能</code>，比如很消耗性能的操作就可以由从服务器来处理。<br>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。<br><strong><code>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</code></strong></p>
<h3 id="7-2-主从复制的意义"><a href="#7-2-主从复制的意义" class="headerlink" title="7.2 主从复制的意义"></a>7.2 主从复制的意义</h3><ul>
<li><p><strong>故障隔离和恢复</strong></p>
<p>无论主节点或者从节点<code>宕机</code>，其他节点依然可以保证服务的正常运行，并可以手动或自动切换主从。</p>
<ul>
<li>如果Slave库故障，则读写操作全部走到Master库中</li>
<li>如果Master库故障，则将Slave转成Master库，仅丢失Master库来不及同步到Slave的小部分数据</li>
</ul>
</li>
<li><p><strong>读写隔离</strong>：Master 节点提供写服务，Slave 节点提供读服务，分摊流量压力，均衡流量的负载。</p>
</li>
<li><p><strong>提供高可用保障</strong>：主从模式是高可用的最基础版本，也是 <code>sentinel 哨兵模式</code>和<code>cluster 集群模式</code>实施的前置条件。</p>
</li>
</ul>
<h3 id="7-3-主从同步原理偏移"><a href="#7-3-主从同步原理偏移" class="headerlink" title="7.3 主从同步原理偏移"></a><strong>7.3 主从同步原理</strong>偏移</h3><ol>
<li>从服务器会向主服务器发出<code>SYNC指令</code>；</li>
<li>当主服务器接到此命令后，就会调用<code>BGSAVE</code>指令来<code>fork</code>一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入<code>RDB文件</code>中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中；</li>
<li>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，</li>
<li>从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。</li>
<li>这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</li>
</ol>
<p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个从服务器。</p>
<img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240418113526905.png" alt="image-20240418113526905" style="zoom: 200%;">



<p>2.8版本之后，redis支持了效率更高的<code>增量同步策略</code>，这大大降低了连接断开的恢复成本。主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，主服务器就会向从服务器发送增量内容。增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。<img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240418114706094.png" alt="image-20240418114706094" style="zoom:67%;"></p>
<p><code>扩展内容</code>：</p>
<p><strong>1. 首次配置完成主从库之后的全量复制</strong>：在从库第一次连接到主库时，将采用psync复制方式进行全量复制。 这意味着从库会从头开始复制主库中的全部数据。<br><strong>2. 主从正常运行期间，准实时同步</strong>：在正常运行状态下，从库通过读取主库的<code>缓冲区来</code>进行增量复制。 这个过程涉及复制主库上发生的新的数据变更。<br><strong>3. 从库第二次启动（异常或主从网络断开后恢复）</strong>： Append增量数据 + 准实时同步将通过读取主库的缓冲区进行部分复制。 这种方式能够快速同步中断期间发生的数据变更，而不会对主库造成重大影响。</p>
<img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/167509-20240327210817418-1726205885.png" alt="image" style="zoom: 50%;">

<p><code>PSYNC</code> 命令是Redis中用于从节点与主节点之间数据同步的关键命令。它的工作原理包括以下几个步骤：</p>
<p><strong>1. 启动或重连判断：</strong><br>当从节点（Slave）启动或与主节点（Master）的连接断开后重连时，从节点需要确定是否曾经同步过。如果从节点没有保存任何主节点的运行ID（runid），它将视为第一次连接到主节点。</p>
<p><strong>2. 首次同步处理：</strong><br>如果是第一次同步的情况下，从节点会发送 <code>PSYNC -1</code> 命令给主节点，代表请求全量数据同步。 全量同步是指主节点将其所有数据完整地<code>Copy</code>一份给从节点。</p>
<p><strong>3. 主从重连后的处理：</strong><br>对于之前已经同步过的从节点，它会发送 <code>PSYNC runid offset</code> 命令，其中runid是主节点的唯一标识符，offset是从节点上次同步数据的偏移量。这样本质就是增量同步。</p>
<p><strong>4. 主节点响应：</strong><br>主节点接收到PSYNC命令后，会检查runid是否匹配，以及offset是否在复制积压缓冲区的范围内。如果匹配且offset有效，主节点将回复<code>CONTINUE</code>，并发送自从节点上次断开连接以来的所有写命令。</p>
<p><strong>5. 触发全量同步的条件：</strong><br>如果runid不匹配，或offset超出了积压缓冲区的范围，主节点将通知从节点执行全量同步，回复<code>FULLRESYNC runid offset</code>。</p>
<p><strong>6. 积压缓冲区的作用：</strong><br>主节点会在处理写命令的同时，将这些命令存入复制积压队列（缓冲池），同时记录队列中存放命令的全局offset。<br>这样做法是保证了效率。当从节点断线重连，且条件允许时（runid和offset都具备），它可以通过offset从积压队列中进行增量复制，而不是全量复制，这样复制的成本就低很多。</p>
<p><strong>7. 保障数据一致性：</strong><br>PSYNC机制允许从节点在网络不稳定或其他意外断开连接的情况下，能够以增量方式重新同步数据。这也是它的一大优势，那就是保持主从节点数据的一致性。</p>
<p><strong>8. 什么时候启动重连工作</strong><br>判断是否进行全量同步，需要考虑两个关键因素：首先，确认这是否是第一次进行数据同步；其次，检查缓存区是否已经达到或超过其容量上限。只有在是第一次同步，或者缓存区已溢出的情况下，才会执行全量同步。</p>
<h3 id="7-4-1主n从的同步说明"><a href="#7-4-1主n从的同步说明" class="headerlink" title="7.4 1主n从的同步说明"></a>7.4 1主n从的同步说明</h3><p>如果你有多个从库，则在每次连接的时候需要注意一些细节，如下:</p>
<ul>
<li><p>多个从库情况下，每个从库都会记录自己的 <code>slave_repl_offset</code>，各自复制的进度也不相同。</p>
</li>
<li><p>重连主库进行恢复时，从库会通过<code>psync</code>命令将 slave_repl_offset 告知主库，主库判断从库的状态，来决定进行增量复制，还是全量复制。</p>
</li>
<li><p>replication buffer(复制缓冲区) 和 repl_backlog 的说明</p>
<ul>
<li><code>replication buffer</code>： 与每个从节点（slave）相关联的缓冲区，存在于主节点（master）上。当主从连接稳定时，主节点会将其接收到的所有写命令放入这个缓冲区中，并异步地发送给从节点。这样，从节点就可以通过执行这些写命令来更新自己的数据集。可以通过<code>client-output-buffer-limit</code>配置来设定其大小限制，以防止因从节点处理速度慢而导致主节点内存溢出。</li>
</ul>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405102015164.webp" alt></p>
<ul>
<li><code>repl_backlog_buffer</code>：是为了解决从库断连后找不到主从差异数据而设立的环形缓冲区，从而避免全量同步带来的性能开销。在redis.conf配置文件中可以设置大小，如果从库断开时间过长，repl_backlog_buffer<code>环形缓冲区</code>会被主库的写命令覆盖，那么从库重连后只能全量同步，所以repl_backlog_size配置尽量大一点可以降低从库连接后全量同步的频率。</li>
</ul>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405102014054.webp" alt></p>
</li>
<li><p>主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，需要将自己的复制进度（slave_repl_offset）发给主库，主库才可以按照偏移量取数据跟它同步。</p>
</li>
</ul>
<img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240422111235791.png" alt="image-20240422111235791" style="zoom: 33%;">

<h3 id="7-5-部署三台机器Redis—主从同步"><a href="#7-5-部署三台机器Redis—主从同步" class="headerlink" title="7.5 部署三台机器Redis—主从同步"></a>7.5 部署三台机器Redis—主从同步</h3><ol>
<li><strong>集群环境准备</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 三台服务器关闭防火墙</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">disable</span> --now firewalld &amp;&amp; setenforce 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 三台服务器添加本地解析</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &gt;&gt; /etc/hosts &lt;&lt;-EOF</span></span><br><span class="line">redis-master	192.168.174.38		</span><br><span class="line">redis-slave-1	192.168.174.39</span><br><span class="line">redis-slave-2	192.168.174.40</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>redis-master</code>节点配置</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-master ~]# vim /usr/local/redis/redis.conf</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 设置Redis监听的IP地址和端口号，默认监听所有IP地址和6379端口</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 关闭保护模式，允许远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 指定Redis监听的端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 增加Redis的最大内存限制，以容纳更多数据</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">maxmemory 16GB   增加内存限制，根据您的服务器实际内存调整</span></span><br><span class="line">maxmemory 20480mb</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动主节点redis服务</span></span><br><span class="line">[root@redis-master ~]# cd /usr/local/redis/src</span><br><span class="line">[root@redis-master src]# ./redis-server ../redis.conf &amp;   会加载此文件中的配置信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看端口</span></span><br><span class="line">[root@redis-master src]# ss -tunlp | grep  6379</span><br><span class="line">tcp    LISTEN     0      128       *:6379                  *:*                   users:(("redis-server",pid=1360,fd=6))</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 关闭protected-mode模式，此时外部网络可以直接访问</p>
<p>开启protected-mode保护模式，需配置bind ip或者设置访问密码</p>
</blockquote>
<ol start="3">
<li><strong><code>redis-slave01</code>配置</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-slave01 ~]# vim /usr/local/redis/redis.conf</span><br><span class="line">...</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 设置Redis监听的IP地址和端口号，默认监听所有IP地址和6379端口</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 添加需要同步的主库信息</span></span><br><span class="line">replicaof 192.168.174.39 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 关闭保护模式，允许远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 自定义数据目录</span></span><br><span class="line">dir /data/redis</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动redis服务</span></span><br><span class="line">[root@redis-slave-1 ~]# cd /usr/local/redis/src/</span><br><span class="line">[root@redis-slave-1 src]# ./redis-server ../redis.conf &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看端口</span></span><br><span class="line">[root@redis-slave01 src]# ss -tunlp | grep  6379</span><br><span class="line">tcp    LISTEN     0      128       *:6379                  *:*                   users:(("redis-server",pid=1360,fd=6))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以通过 <code>replicaof（Redis 5.0 之前使用 slaveof）</code>命令形成主库和从库的关系。</p>
</blockquote>
<ol start="4">
<li><strong><code>redis-slave02</code>配置</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-slave01 ~]# vim /usr/local/redis/redis.conf</span><br><span class="line">...</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 设置Redis监听的IP地址和端口号，默认监听所有IP地址和6379端口</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 添加需要同步的主库信息</span></span><br><span class="line">replicaof 192.168.174.48 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 关闭保护模式，允许远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 自定义数据目录</span></span><br><span class="line">dir /data/redis</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动redis服务</span></span><br><span class="line">[root@redis-slave-1 ~]# cd /usr/local/redis/src/</span><br><span class="line">[root@redis-slave-1 src]# ./redis-server ../redis.conf &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看端口</span></span><br><span class="line">[root@redis-slave01 src]# ss -tunlp | grep  6379</span><br><span class="line">tcp    LISTEN     0      128       *:6379                  *:*                   users:(("redis-server",pid=1360,fd=6))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>测试主从复制</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; redis-master执行</span></span><br><span class="line">[root@redis-master redis]# cd src/</span><br><span class="line">[root@redis-master src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; set name jack</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"jack"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 分别在slave-1和slave-2上面执行</span></span><br><span class="line">[root@redis-slave01 redis]# cd src/</span><br><span class="line">[root@redis-slave01 src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"jack"</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">[root@redis-slave-2 src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"jack"</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; redis-master查看复制状态</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.246.203,port=6379,state=online,offset=490,lag=0</span><br><span class="line">slave1:ip=192.168.246.204,port=6379,state=online,offset=490,lag=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; redis-slave执行</span></span><br><span class="line">127.0.0.1:6379&gt; info replication	</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.246.202</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br></pre></td></tr></table></figure>

<p><strong>注意：从服务器一般默认禁止写入操作：<code>slave-read-only yes</code></strong></p>
<p><code>redis-master</code>执行<code>info repliaction</code>参数解释</p>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408132333247.png" alt="image-20240813233259506"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示当前节点的角色是主节点</span></span><br><span class="line">role:master</span><br><span class="line"><span class="comment"># 表示当前主节点连接了两个从节点。</span></span><br><span class="line">connected_slaves:2</span><br><span class="line"><span class="comment"># 表示第一个从节点的IP地址为192.168.174.49，端口号为6379，状态为在线（online），复制偏移量为3276，与主节点的延迟为1。</span></span><br><span class="line">slave0:ip=192.168.174.49,port=6379,state=online,offset=3276,lag=1</span><br><span class="line"><span class="comment"># 表示第二个从节点的IP地址为192.168.174.50，端口号为6379，状态为在线（online），复制偏移量为3276，与主节点的延迟为1。</span></span><br><span class="line">slave1:ip=192.168.174.50,port=6379,state=online,offset=3276,lag=1</span><br><span class="line"><span class="comment"># 表示当前没有进行故障转移。</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line"><span class="comment"># 表示主节点的复制ID。</span></span><br><span class="line">master_replid:169726e22cc9736afd05f50b7fef4d8b6e48b47a</span><br><span class="line"><span class="comment"># 表示主节点的第二个复制ID，这里为全零。</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line"><span class="comment"># 表示主节点当前的复制偏移量。</span></span><br><span class="line">master_repl_offset:3276</span><br><span class="line"><span class="comment"># 表示第二个从节点的复制偏移量，这里为-1，表示没有设置。</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区是否处于活动状态，1表示活动。</span></span><br><span class="line">repl_backlog_active:1</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区的大小，单位为字节。</span></span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区中第一个字节的偏移量。</span></span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区的历史长度。</span></span><br><span class="line">repl_backlog_histlen:3276</span><br></pre></td></tr></table></figure>

<p><code>redis-slave</code>执行<code>info replication</code>参数解释</p>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408132336143.png" alt="image-20240813233652087"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> slave 节点执行 info replication 命令回显参数解释</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前节点的角色是从节点。</span></span><br><span class="line">role:slave</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的IP地址为192.168.174.48。</span></span><br><span class="line">master_host:192.168.174.48</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的端口号为6379。</span></span><br><span class="line">master_port:6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示与主节点的连接状态为正常（up）。</span></span><br><span class="line">master_link_status:up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示距离上一次与主节点进行IO操作的时间过去了8秒。</span></span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前没有正在进行的主从同步操作。</span></span><br><span class="line">master_sync_in_progress:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点读取复制数据时的偏移量。</span></span><br><span class="line">slave_read_repl_offset:3794</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点当前的复制偏移量。</span></span><br><span class="line">slave_repl_offset:3794</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点的优先级为100。</span></span><br><span class="line">slave_priority:100</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点以只读模式运行。</span></span><br><span class="line">slave_read_only:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点已经向其他节点宣告自己是复制节点。</span></span><br><span class="line">replica_announced:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前从节点没有连接其他从节点。</span></span><br><span class="line">connected_slaves:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前没有进行故障转移。</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的复制ID。</span></span><br><span class="line">master_replid:169726e22cc9736afd05f50b7fef4d8b6e48b47a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的第二个复制ID，这里为全零。</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点当前的复制偏移量。</span></span><br><span class="line">master_repl_offset:3794</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示第二个从节点的复制偏移量，这里为-1，表示没有设置。</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区是否处于活动状态，1表示活动。</span></span><br><span class="line">repl_backlog_active:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区的大小，单位为字节。</span></span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区中第一个字节的偏移量。</span></span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区的历史长度。</span></span><br><span class="line">repl_backlog_histlen:3794</span><br></pre></td></tr></table></figure>



<h3 id="7-6-主从同步保证数据一致性"><a href="#7-6-主从同步保证数据一致性" class="headerlink" title="7.6 主从同步保证数据一致性"></a>7.6 主从同步保证数据一致性</h3><p>​    为了保证主服务器Redis的数据和从服务器Redis的数据的一致性，也为了分担访问压力，均衡负载，应用层面一般采取读写分离的模式。读操作：主、从库都可以执行，一般是在从库上读数据，对实时性和准确性有100%高真要求的部分业务，在谨慎评估之后也可以读主库，前提是不能给Master带来高压力和风险。写操作：只在主库上写数据，写完之后将写操作指令同步到从库。</p>
<h3 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7 总结"></a>7.7 总结</h3><ul>
<li>主从复制的作用一个是为分担读写压力，均衡负载，另一个是为了保证部分实例宕机之后服务的持续可用性，所以Redis演变出主从架构和读写分离。</li>
<li>主从复制的步骤包括：建立连接的阶段、数据同步的阶段、基于长连接的命令传播阶段。</li>
<li>数据同步可以分为<code>全量复制</code>和<code>部分复制</code>，全量复制一般为第一次全量或者长时间主从连接断开。</li>
<li>主从模式是比较低级的可用性优化，要做到故障自动转移，异常预警，高保活，还需要更为复杂的哨兵或者集群模式，这个后面我们继续介绍。</li>
</ul>
<h2 id="8、Redis-sentinel—哨兵模式"><a href="#8、Redis-sentinel—哨兵模式" class="headerlink" title="8、Redis-sentinel—哨兵模式"></a><strong>8、Redis-sentinel—哨兵模式</strong></h2><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405141432953.png" alt="img"></p>
<h3 id="8-1-哨兵简介-Redis-Sentinel"><a href="#8-1-哨兵简介-Redis-Sentinel" class="headerlink" title="8.1 哨兵简介:Redis Sentinel"></a>8.1 哨兵简介:Redis Sentinel</h3><p><strong>Sentinel(哨兵)进程</strong>是用于监控redis集群中Master主服务器工作的状态，在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用。</p>
<p>哨兵(Sentinel) 是一个分布式系统，你可以在一个架构中运行<code>多个哨兵(sentinel) 进程</code>，这些进程使用<code>流言协议</code>来接收关于Master主服务器是否下线的信息，并使用<code>投票协议</code>来决定是否执行<code>自动故障迁移</code>,以及选择哪个Slave作为新的Master。</p>
<p>流言协议：</p>
<p>​    流言协议是一种<code>去中心化</code>的信息传播方式，其工作原理类似于人们在日常生活中传播流言：<strong>每个节点都将自己所知的信息告诉给它所连接的其他节点，这些节点再将信息传播给它们所连接的节点，以此类推，直到所有节点都获得了这条信息。</strong></p>
<h5 id="1、Redis哨兵集群的角色划分"><a href="#1、Redis哨兵集群的角色划分" class="headerlink" title="1、Redis哨兵集群的角色划分"></a>1、Redis哨兵集群的角色划分</h5><ul>
<li><strong>主节点（Master）：</strong> 处理客户端的读写请求。</li>
<li><strong>从节点（Slave）：</strong> 复制主节点的数据，用于提供读取服务和备份。</li>
<li><strong>哨兵节点（Sentinel）：</strong> 监控集群中各节点的健康状态，负责选举和故障转移。</li>
</ul>
<h5 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h5><ul>
<li><strong><code>监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</code></strong></li>
<li>提醒(Notification)：当被 监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作，它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</li>
</ul>
<p><strong>哨兵之间如何通信</strong></p>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408150827546.png" alt="image-20240815082655417"></p>
<p>哨兵实例之间可以相互发现，要归功于 Redis 提供的 <strong>pub/sub</strong> 机制，也就是发布 / 订阅机制。</p>
<p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p>
<p>为了区分不同应用的消息，Redis 会以<strong>频道</strong>的形式，对这些消息进行分门别类的管理。<strong>所谓的频道，实际上就是消息的类别。</strong>当消息类别相同时，它们就属于同一个频道。反之，就属于不同的频道。<strong>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换</strong>。</p>
<p>在主从集群中，主库上有一个名为<strong><code>“sentinel:hello”</code></strong>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p>
<p>在上图图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到“<strong><code>sentinel:hello</code></strong>”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。</p>
<p>然后，哨兵 2、3 可以和哨兵 1 建立网络连接。通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。</p>
<p><strong>哨兵如何知道从库的ip地址和端口呢？</strong></p>
<p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408150832516.png" alt="image-20240815083231411"></p>
<p>由哨兵向主库发送 INFO 命令来完成的。就像上图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p>
<h5 id="3、工作模式"><a href="#3、工作模式" class="headerlink" title="3、工作模式"></a>3、工作模式</h5><ul>
<li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。并通过实例返回的结果来判断实例是否在线。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 <code>down-after-milliseconds</code> 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</li>
<li>如果一个Master主服务器被标记为<strong>主观下线</strong>（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了<strong>主观下线状态</strong>。</li>
<li>当有足够数量的 Sentinel（哨兵）进程（<strong>大于等于配置文件指定的值</strong>）在指定的时间范围内确认Master主服务器进入了<strong>主观下线</strong>状态（SDOWN）， 则Master主服务器会被标记为<strong>客观下线</strong>（ODOWN）。</li>
<li>在一般情况下， 每个 Sentinel（哨兵）进程会以<strong>每 10 秒一次</strong>的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li>
<li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 <strong>Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次</strong>。</li>
<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线操作就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li>
</ul>
<h5 id="4、主观下线和客观下线"><a href="#4、主观下线和客观下线" class="headerlink" title="4、主观下线和客观下线"></a>4、主观下线和客观下线</h5><p>主观下线：<code>Subjectively Down</code>，简称 <code>SDOWN</code>，指的是当前一个Sentinel 实例对某个redis服务器做出的下线判断。<br>客观下线：<code>Objectively Down</code>， 简称<code>ODOWN</code>，指的是多个 Sentinel 实例在对Master Server做出 SDOWN  判断，并且通过<code>SENTINEL is-master-down-by-addr</code> 命令互相交流之后，得出的Master  Server下线判断，然后开启failover/故障转移</p>
<h5 id="5、配置哨兵模式"><a href="#5、配置哨兵模式" class="headerlink" title="5、配置哨兵模式"></a>5、配置哨兵模式</h5><ul>
<li>每台机器上修改redis主配置文件<code>redis.conf</code>文件设置：<code>bind 0.0.0.0</code></li>
<li>每台机器上修改<code>sentinel.conf</code>配置文件：修改如下配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@redis-master ~]#  cd /usr/local/redis/</span><br><span class="line"></span><br><span class="line">[root@redis-master redis]# vim sentinel.conf</span><br><span class="line">...</span><br><span class="line">sentinel monitor mymaster 192.168.174.48 6379 2 </span><br><span class="line">sentinel down-after-milliseconds mymaster 3000 </span><br><span class="line">sentinel failover-timeout mymaster 10000 </span><br><span class="line">protected-mode no </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每台机器启动哨兵服务：</span></span><br><span class="line">[root@redis-master redis]# ./src/redis-sentinel sentinel.conf </span><br><span class="line">注意:在生产环境下将哨兵模式启动放到后台执行:     ./src/redis-sentinel sentinel.conf &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数解释：</p>
<p><code>sentinel down-after-milliseconds mymaster 3000</code>：</p>
<p>​    当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了。 (slave上面写的是master的ip，master写自己ip)</p>
<p><code>sentinel down-after-milliseconds mymaster 3000</code>： </p>
<p>​    表示如果名为 <code>mymaster</code> 的主节点在3秒（3000毫秒）内未对 Sentinel 的 PING 命令做出有效响应，那么 Sentinel 会开始考虑该主节点可能已经出现故障，并做好相应的故障转移准备。</p>
<p><code>sentinel failover-timeout mymaster 10000</code> ：</p>
<p>​    表示在进行名为 <code>mymaster</code> 的主节点的故障转移操作时，Sentinel 最多允许花费10秒（10000毫秒）的时间来完成整个操作。</p>
<p><code>protected-mode no</code>：</p>
<p>​    关闭加密保护模式</p>
</blockquote>
<p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564310139143.png#id=T6LR2&originHeight=666&originWidth=1751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p>
<p><strong>将master的哨兵模式退出（Crtl+c），再将redis服务stop了，在两台slave上面查看其中一台是否切换为master:(没有优先级，为随机切换)</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^C4854:signal-handler (1564349039) Received SIGINT scheduling shutdown...</span><br><span class="line">4854:X 29 Jul 05:23:59.592 # User requested shutdown...</span><br><span class="line">4854:X 29 Jul 05:23:59.592 # Sentinel is now ready to exit, bye bye...</span><br><span class="line">[root@redis-master redis]# systemctl stop redis.service</span><br><span class="line">或者用kill命令杀死</span><br></pre></td></tr></table></figure>

<p>在slave机器上面查看:</p>
<p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564320905579.png#id=Cshe1&originHeight=594&originWidth=1882&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p>
<p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564320763210.png#id=UPfuL&originHeight=339&originWidth=1897&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p>
<h5 id="6、Redis故障Master选举算法（了解）"><a href="#6、Redis故障Master选举算法（了解）" class="headerlink" title="6、Redis故障Master选举算法（了解）"></a>6、Redis故障Master选举算法（了解）</h5><ul>
<li><strong>优先级：</strong> 每个节点都有一个优先级，选择优先级最高的节点作为新的主节点。</li>
<li><strong>复制偏移量：</strong> 选择复制偏移量最大的从节点，确保数据同步性。</li>
<li><strong>运行ID：</strong> 选择运行ID最大的节点，确保节点唯一性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisSentinelPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.exceptions.JedisException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterElection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">        Set&lt;String&gt; sentinels = Set.of(<span class="string">"sentinel1:26379"</span>, <span class="string">"sentinel2:26379"</span>, <span class="string">"sentinel3:26379"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels)) &#123;</span><br><span class="line">            Jedis jedis = sentinelPool.getResource();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取当前主节点</span></span><br><span class="line">            String currentMaster = jedis.sentinelGetMasterAddrByName(masterName).getHost();</span><br><span class="line">            System.out.println(<span class="string">"Current Master: "</span> + currentMaster);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 模拟主节点故障</span></span><br><span class="line">            simulateMasterFailure(jedis, masterName);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 等待哨兵节点进行选举</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取新的主节点</span></span><br><span class="line">            String newMaster = jedis.sentinelGetMasterAddrByName(masterName).getHost();</span><br><span class="line">            System.out.println(<span class="string">"New Master: "</span> + newMaster);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simulateMasterFailure</span><span class="params">(Jedis jedis, String masterName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟主节点故障，停止主节点</span></span><br><span class="line">        jedis.sentinelFailover(masterName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试"><a href="#面试" class="headerlink" title="面试:"></a>面试:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis有哪些优点</span><br><span class="line">(1) 速度快，因为数据存在内存中。</span><br><span class="line">(2) 支持丰富数据类型，支持string，list，set，hash等</span><br><span class="line">(3) 支持事务，操作都是原子性，就是对数据的更改要么全部执行，要么全部不执行</span><br><span class="line">(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</span><br><span class="line"></span><br><span class="line">redis相比memcached有哪些优势</span><br><span class="line">(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</span><br><span class="line">(2) redis可以持久化其数据</span><br><span class="line"></span><br><span class="line">redis常见性能问题和解决方案</span><br><span class="line">(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</span><br><span class="line">(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</span><br><span class="line">(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</span><br><span class="line">(4) 尽量避免在压力很大的主库上增加从库</span><br><span class="line">(5) 主从复制不要用树状结构，用单向链表结构更为稳定，即：Master（写） &lt;- Slave1（读） &lt;- Slave2（读） &lt;- Slave3（读）...</span><br><span class="line">这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</span><br><span class="line">redis集群的工作原理</span><br><span class="line">主多从+哨兵模式</span><br></pre></td></tr></table></figure>

<p>了解:</p>
<p>redis–快照</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">快照，主要涉及的是redis的RDB持久化相关的配置</span><br><span class="line"></span><br><span class="line">用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：</span><br><span class="line"></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">举例</span><br><span class="line">save 900 1 //表示每15分钟且至少有1个key改变，就触发一次持久化</span><br><span class="line">save 300 10 //表示每5分钟且至少有10个key改变，就触发一次持久化</span><br><span class="line">save 60 10000 //表示每60秒至少有10000个key改变，就触发一次持久化</span><br><span class="line"></span><br><span class="line">如果想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果，就像这样：</span><br><span class="line"></span><br><span class="line">save ""</span><br></pre></td></tr></table></figure>

<p>安全:为redis加密：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以要求redis客户端在向redis-server发送请求之前，先进行密码验证。当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。</span><br><span class="line"></span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line">这里我们通过requirepass将密码设置成“123456”。</span><br></pre></td></tr></table></figure>



<p>修改了Redis的哨兵配置文件后，先把文件拷贝到从机再启动，否则会出现myid冲突的情况。</p>
<p>解决方法：将哨兵停掉，哨兵配置文件删除后，重新弄一份新的，然后再启动即可。</p>
<p>+slave ：取消主观下线<br>-slave ：标记为主观下线</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">L66</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://l66stbz.github.io/2024/08/14/NoSQL-Redis/">https://l66stbz.github.io/2024/08/14/NoSQL-Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://l66stbz.github.io" target="_blank">L66</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/RDB/">RDB</a><a class="post-meta__tags" href="/tags/AOF/">AOF</a><a class="post-meta__tags" href="/tags/Sentinel/">Sentinel</a></div><div class="post_share"><div class="social-share" data-image="https://l66stbz.github.io/2024/08/28/ELK日志收集平台/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2024/08/15/Redis-Cluster%E9%9B%86%E7%BE%A4/"><img class="prev_cover" src="https://l66stbz.github.io/2024/08/15/Redis-Cluster集群/1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis-Cluster集群</div></div></a></div><div class="next-post pull_right"><a href="/2024/08/13/LVS-NAT-Keepalived/"><img class="next_cover" src="https://l66stbz.github.io/2024/08/13/LVS-NAT-Keepalived/1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LVS-NAT-Keepalived</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2024/08/16/RabbitMQ消息队列/" title="RabbitMQ消息队列"><img class="relatedPosts_cover" src="https://l66stbz.github.io/2024/08/16/RabbitMQ消息队列/1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2024-08-16</div><div class="relatedPosts_title">RabbitMQ消息队列</div></div></a></div><div class="relatedPosts_item"><a href="/2024/08/15/Redis-Cluster集群/" title="Redis-Cluster集群"><img class="relatedPosts_cover" src="https://l66stbz.github.io/2024/08/15/Redis-Cluster集群/1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2024-08-15</div><div class="relatedPosts_title">Redis-Cluster集群</div></div></a></div><div class="relatedPosts_item"><a href="/2024/05/19/作业_zabbix监控内存/" title="作业_zabbix监控内存"><img class="relatedPosts_cover" src="https://l66stbz.github.io/2024/05/19/作业_zabbix监控内存/1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2024-05-19</div><div class="relatedPosts_title">作业_zabbix监控内存</div></div></a></div><div class="relatedPosts_item"><a href="/2024/08/13/LVS-NAT-Keepalived/" title="LVS-NAT-Keepalived"><img class="relatedPosts_cover" src="https://l66stbz.github.io/2024/08/13/LVS-NAT-Keepalived/1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2024-08-13</div><div class="relatedPosts_title">LVS-NAT-Keepalived</div></div></a></div><div class="relatedPosts_item"><a href="/2024/07/27/Mysql高可用-MHA/" title="Mysql高可用-MHA"><img class="relatedPosts_cover" src="https://l66stbz.github.io/2024/07/27/Mysql高可用-MHA/1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2024-07-27</div><div class="relatedPosts_title">Mysql高可用-MHA</div></div></a></div><div class="relatedPosts_item"><a href="/2024/08/08/Tomcat运维实战/" title="Tomcat运维实战"><img class="relatedPosts_cover" src="https://l66stbz.github.io/2024/08/08/Tomcat运维实战/1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2024-08-08</div><div class="relatedPosts_title">Tomcat运维实战</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By L66</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script></body></html>