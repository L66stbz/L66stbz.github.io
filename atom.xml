<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L66</title>
  
  <subtitle>胜天半子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://l66stbz.github.io/"/>
  <updated>2024-09-03T12:07:16.020Z</updated>
  <id>https://l66stbz.github.io/</id>
  
  <author>
    <name>L66</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>study</title>
    <link href="https://l66stbz.github.io/2024/09/03/study/test/"/>
    <id>https://l66stbz.github.io/2024/09/03/study/test/</id>
    <published>2024-09-03T13:50:00.000Z</published>
    <updated>2024-09-03T12:07:16.020Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://192.168.100.150:80" target="_blank" rel="noopener">http://192.168.100.150:80</a><br>默认用户: admin  默认密码: ChangeMe</p><p>你仨低价阿萨德</p><p><img src="/2024/09/03/study/test/1.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Ansible" scheme="https://l66stbz.github.io/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>ELK日志收集平台</title>
    <link href="https://l66stbz.github.io/2024/08/28/ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%B9%B3%E5%8F%B0/"/>
    <id>https://l66stbz.github.io/2024/08/28/ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%B9%B3%E5%8F%B0/</id>
    <published>2024-08-28T13:50:00.000Z</published>
    <updated>2024-08-31T02:30:55.772Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h2 id="1、日志收集所解决的问题"><a href="#1、日志收集所解决的问题" class="headerlink" title="1、日志收集所解决的问题"></a>1、日志收集所解决的问题</h2><ol><li>⽣产环境出现问题后，需要查看各种⽇志进⾏分析排错；</li><li>日常运维工作，日志文件分散，运维工作繁琐。可以实现日志聚合；</li><li>开发⼈员没有登陆服务器的权限。开发人员可以通过web界面查看日志；</li><li>面对大量的访问日志，可以统计出各项指标，比如PV UV。<h2 id="2、-Elastic-Stack-组件介绍"><a href="#2、-Elastic-Stack-组件介绍" class="headerlink" title="2、 Elastic Stack 组件介绍"></a>2、 Elastic Stack 组件介绍</h2></li></ol><ul><li>Elasticsearch（简称ES）是一个分布式、<strong>RESTful</strong>风格的开源搜索和数据分析引擎，专为全文搜索、结构化搜索、分析、和数据可视化而设计。支持几乎实时的搜索，并且具有高扩展性，能够处理PB级别的数据。<ul><li><strong>Index（索引）</strong>： 索引类似于关系型数据库中的表，它存储着相似结构的数据。在Elasticsearch中，每个索引包含一个或多个文档（Document）。</li><li><strong>Document（文档）</strong>： 文档是Elasticsearch的基本数据单位，相当于关系型数据库中的一行记录。文档以JSON格式存储，包含字段和值的对。</li><li><strong>Shards（分片）和Replicas（副本）</strong>： Elasticsearch将数据分为多个分片存储，每个索引可以包含一个或多个分片。分片可以提高并行查询的性能。副本是分片的备份，保证了数据的高可用性和容错性。</li><li><strong>Cluster（集群）</strong>： Elasticsearch集群由一个或多个节点（Node）组成。每个节点负责存储部分数据，并参与集群中的索引和搜索操作。集群有一个主节点，用于管理集群状态。</li><li><strong>Node（节点）</strong>： 节点是Elasticsearch的运行实例，每个节点属于某个集群。节点可以充当主节点、数据节点。</li><li><strong>使用场景：</strong><ul><li><strong>日志和事件数据分析</strong>： Elasticsearch常用于集中化日志管理和分析，帮助企业在海量日志中快速定位问题。</li><li><strong>电商网站的搜索功能</strong>： Elasticsearch被广泛用于电商网站的产品搜索，提供快速、相关性高的搜索结果。</li><li><strong>数据存储与检索</strong>： Elasticsearch能有效存储和检索结构化或非结构化数据，适用于大规模数据的管理。</li></ul></li></ul></li><li><strong>Logstash</strong><ul><li>Logstash 是一个开源的数据收集、处理和传输引擎，主要用于实时的数据管道管理。它是 Elastic Stack（ELK Stack：Elasticsearch、Logstash、Kibana）的重要组成部分，负责将各种来源的数据收集起来，进行过滤和格式化处理，并最终将其输出到指定的目标，如 Elasticsearch、文件或其他存储系统。</li></ul></li><li><strong>Kibana</strong><ul><li>Kibana 提供强大的数据可视化能力，使用户可以在浏览器中实时查看、搜索和分析存储在 Elasticsearch 中的数据。它提供丰富的可视化选项，如图表、地图和表格，支持构建交互式仪表板。</li></ul></li><li><strong>Filebeat</strong><ul><li>Filebeat 是一个轻量级的日志收集和传输工具。它通常用于从各种数据源收集日志，并将这些日志传输到 Logstash 或 Elasticsearch 进行进一步处理和分析。Filebeat 是一个边车代理，安装在需要监控的服务器上，用于高效地读取和转发日志数据。它旨在减少资源消耗，提供可靠的日志传输，并确保在出现故障时不会丢失日志数据。<h2 id="一、安装JAVA环境（所有es节点，logstash节点，kinbana节点）"><a href="#一、安装JAVA环境（所有es节点，logstash节点，kinbana节点）" class="headerlink" title="一、安装JAVA环境（所有es节点，logstash节点，kinbana节点）"></a>一、安装JAVA环境（所有es节点，logstash节点，kinbana节点）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 上传jdk1.8安装包</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># ll jdk-8u381-linux-x64.tar.gz </span></span><br><span class="line">-rw-r--r--. 1 root root 139273048 7月  31 10:23 jdk-8u381-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 解压jdk到指定目录</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># tar xf jdk-8u381-linux-x64.tar.gz  -C /usr/local/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建软链接</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># cd /usr/local/</span></span><br><span class="line">[root@elk03 <span class="built_in">local</span>]<span class="comment"># ln -s jdk1.8.0_381/ java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 声明Java环境变量</span></span><br><span class="line">[root@elk03 <span class="built_in">local</span>]<span class="comment"># cat  &gt;&gt; /etc/profile.d/jdk.sh &lt;&lt;-EOF</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java</span><br><span class="line"><span class="built_in">export</span> PATH=\<span class="variable">$PATH</span>:\<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载配置文件</span></span><br><span class="line">[root@elk03 <span class="built_in">local</span>]<span class="comment"># source /etc/profile.d/jdk.sh </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试java</span></span><br><span class="line">[root@elk03 <span class="built_in">local</span>]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">"1.8.0_381"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_381-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.381-b09, mixed mode)</span><br></pre></td></tr></table></figure><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405282051529.png#id=LinjU&originHeight=287&originWidth=1568&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><h2 id="二、-安装ES集群"><a href="#二、-安装ES集群" class="headerlink" title="二、 安装ES集群"></a>二、 安装ES集群</h2><h3 id="1、单节点部署"><a href="#1、单节点部署" class="headerlink" title="1、单节点部署"></a>1、单节点部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 解压es安装包到指定目录</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># tar xf elasticsearch-7.17.11-linux-x86_64.tar.gz  -C /usr/local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建es软链接</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># cd /usr/local/</span></span><br><span class="line">[root@elk01 <span class="built_in">local</span>]<span class="comment"># ln -s elasticsearch-7.17.11/ es</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 声明ES环境变量</span></span><br><span class="line">[root@elk01 loacl]<span class="comment"># cat &gt;&gt; /etc/profile.d/es.sh &lt;&lt;-EOF</span></span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">export</span> ES_HOME=/usr/<span class="built_in">local</span>/es</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:\<span class="variable">$ES_HOME</span>/bin</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载环境变量</span></span><br><span class="line">[root@elk01 <span class="built_in">local</span>]<span class="comment"># source /etc/profile.d/es.sh </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动es实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># elasticsearch</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>此时启动会有报错信息，记住详细看报错信息哟！</strong><code>嘿嘿</code><strong>。报错信息如下：此服务不能以超级管理员的身份运行，需要单独创建es普通用户。</strong><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405282057083.png#id=hPod8&originHeight=524&originWidth=2323&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p></blockquote></li></ul></li></ul><p><strong>解决方法如下操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建用于启动ES的用户</span></span><br><span class="line">[root@elk01 <span class="built_in">local</span>]<span class="comment"># useradd es</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看用户是否创建</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># id es</span></span><br><span class="line">uid=1000(es) gid=1000(es) 组=1000(es)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改elasticsearch属主和数组</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># chown  -R es.es /usr/local/elasticsearch-7.17.11/</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看是否修改成功</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># ll /usr/local/elasticsearch-7.17.11/</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 切换es工作目录</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># cd /usr/local/elasticsearch-7.17.11/config/</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 备份es配置文件</span></span><br><span class="line">[root@elk01 config]<span class="comment"># cp elasticsearch.yml&#123;,.bak&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改文件相关参数</span></span><br><span class="line">[root@elk01 config]<span class="comment"># egrep -v  "^(#|$)" elasticsearch.yml</span></span><br><span class="line">···</span><br><span class="line"><span class="comment"># es集群名称</span></span><br><span class="line">cluster.name: study-elk-cluster</span><br><span class="line"><span class="comment"># 节点名称(一般以当前主机名一致)</span></span><br><span class="line">node.name: elk01</span><br><span class="line"><span class="comment"># 监听地址，，配置IP则知允许基于IP地址进行访问</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="comment"># 自动发现节点IP</span></span><br><span class="line">discovery.seed_hosts: [<span class="string">"192.168.100.160"</span>]</span><br><span class="line"><span class="comment"># 初始化master节点</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"192.168.100.160"</span>] </span><br><span class="line"><span class="comment"># 添加以下参数关闭geoip数据库的更新,减少对带宽和存储的消耗，禁用自动更新。GeoIP根据IP地址确定地理位置的技术，用于日志分析、用户活动追踪等场景。</span></span><br><span class="line">ingest.geoip.downloader.enabled: <span class="literal">false</span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试启动ES</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># su -c "elasticsearch" es</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>虽然es能够正常启动，但是启动日志会出下报错信息，需要我们修改启动的内核参数，第一个为修改系最大的文件描述符，第二个修改系统的虚拟内存。</strong></p></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405282123794.png#id=Yu4ws&originHeight=300&originWidth=2519&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 修改es需要的limits参数（重新连接会话框才能成功加载参数）</span></span><br><span class="line">[root@elk01 logs]<span class="comment"># cat &gt;&gt;/etc/security/limits.d/elk.conf &lt;&lt;EOF</span></span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 131070</span><br><span class="line">EOF</span><br><span class="line">    <span class="comment"># 参数解释：</span></span><br><span class="line">        soft nofile 65535表示将文件描述符的软限制设置为65535。</span><br><span class="line">        hard nofile 131070表示将文件描述符的硬限制设置为131070。</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看limits参数是否加载</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># ulimit -Sn</span></span><br><span class="line">65535</span><br><span class="line">[root@elk01 ~]<span class="comment"># ulimit -Hn</span></span><br><span class="line">131070</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改内核参数</span></span><br><span class="line">[root@elk01 config]<span class="comment"># cat &gt;&gt; /etc/sysctl.d/elk.conf &lt;&lt;'EOF'</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line">EOF</span><br><span class="line">    <span class="comment"># 参数解释</span></span><br><span class="line">        vm.max_map_count = 262144 用于设置单个进程可以拥有的内存映射的最大数量。</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 加载内核参数</span></span><br><span class="line">[root@elk01 config]<span class="comment"># sysctl -f /etc/sysctl.d/elk.conf</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line">[root@elk01 config]<span class="comment"># sysctl -q vm.max_map_count</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试启动ES</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># su -c "elasticsearch" es</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 或者使用一下的参数实现后台运行</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># su -c "elasticsearch -d" es</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试节点</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># curl   192.168.100.160:9200</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"elk01"</span>,  <span class="comment"># 节点的名称,一般以当前主机名命名。</span></span><br><span class="line">  <span class="string">"cluster_name"</span> : <span class="string">"study-elk-cluster"</span>,<span class="comment">#  Elasticsearch集群的名称，多个节点可以组成一个集群，共同提供搜索和存储功能。</span></span><br><span class="line">  <span class="string">"cluster_uuid"</span> : <span class="string">"EyOTgfNNSHOvUsQNLQ9f7Q"</span>, <span class="comment"># 集群的唯一标识符（UUID）。每个Elasticsearch集群都有一个唯一的cluster_uuid，用于在集群内识别和管理节点之间的关系。</span></span><br><span class="line">  <span class="string">"version"</span> : &#123;</span><br><span class="line">    <span class="string">"number"</span> : <span class="string">"7.17.11"</span>,  <span class="comment"># Elasticsearch 实例的版本</span></span><br><span class="line">    <span class="string">"build_flavor"</span> : <span class="string">"default"</span>,  <span class="comment"># 示这个版本没有特殊的自定义修改或变化。</span></span><br><span class="line">    <span class="string">"build_type"</span> : <span class="string">"tar"</span>,  <span class="comment"># Elasticsearch 是通过 tar 包安装的。</span></span><br><span class="line">    <span class="string">"build_hash"</span> : <span class="string">"eeedb98c60326ea3d46caef960fb4c77958fb885"</span>,  <span class="comment"># Git提交哈希。</span></span><br><span class="line">    <span class="string">"build_date"</span> : <span class="string">"2023-06-23T05:33:12.261262042Z"</span>, <span class="comment"># 版本的构建日期和时间。</span></span><br><span class="line">    <span class="string">"build_snapshot"</span> : <span class="literal">false</span>,  <span class="comment"># 此版本适用于生产</span></span><br><span class="line">    <span class="string">"lucene_version"</span> : <span class="string">"8.11.1"</span>,  <span class="comment"># Lucene版本</span></span><br><span class="line">    <span class="string">"minimum_wire_compatibility_version"</span> : <span class="string">"6.8.0"</span>, <span class="comment"># lasticsearch实例能够与运行 6.8.0 及以上版本的其他节点进行通讯。</span></span><br><span class="line">    <span class="string">"minimum_index_compatibility_version"</span> : <span class="string">"6.0.0-beta1"</span>  <span class="comment"># Elasticsearch兼容的最低索引版本。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span> <span class="comment">#  Elasticsearch的标语或宣传口号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>端口解释：</strong></p><ul><li>*<em>9200 对外暴露端口，使用的HTTP协议， Elasticsearch 的 REST API 服务的默认端口。开发者和应用程序通过 HTTP 协议与 Elasticsearch 进行交互，发送查询、索引文档、管理集群等操作。  *</em></li><li>*<em>9300 集群内部通讯端口。使用TCP协议。 用于集群内的节点间同步和协调。节点之间通过这个端口交换数据，包括集群管理信息、索引和搜索操作等。  *</em><h3 id="2、ES-JAVA调优-堆-heap-内存大小"><a href="#2、ES-JAVA调优-堆-heap-内存大小" class="headerlink" title="2、ES JAVA调优 堆(heap)内存大小"></a>2、ES JAVA调优 堆(heap)内存大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 查看运行的JAVA程序</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># jps  </span></span><br><span class="line">14917 Jps</span><br><span class="line">14713 Elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看ES堆内存大小</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># jmap -heap 14713(pid)</span></span><br></pre></td></tr></table></figure><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405282346087.png#id=mf04i&originHeight=619&originWidth=1348&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 修改堆内存大小（最大设置为32G，要么内存的一半）</span></span><br><span class="line">[root@elk01 config]<span class="comment"># vim /usr/local/elasticsearch-7.17.11/config/jvm.options</span></span><br><span class="line">···</span><br><span class="line">-Xms256m</span><br><span class="line">-Xmx256m</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 删除数据、日志</span></span><br><span class="line">[root@elk01 config]<span class="comment"># rm -rf /usr/local/es/&#123;data,logs&#125;/*</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 删除缓存数据</span></span><br><span class="line">[root@elk01 config]<span class="comment"># rm -rf /tmp/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 准备ES启动脚本并启动（加入systemd）</span></span><br><span class="line">[root@elk01 config]<span class="comment"># cat &gt;&gt; /usr/lib/systemd/system/es.service &lt;&lt;EOF</span></span><br><span class="line">[Unit]</span><br><span class="line"><span class="comment"># 描述服务的简短说明，这里描述为 "ELK"。</span></span><br><span class="line">Description=ELK</span><br><span class="line"><span class="comment"># 指定服务的启动顺序。表示该服务在网络目标 (network.target) 之后启动，确保网络服务已启动并可用。</span></span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="comment"># 指定服务的启动类型为 forking，表示服务启动后会产生一个子进程，并且主进程会在启动完成后退出。这通常用于后台运行的守护进程。</span></span><br><span class="line">Type=forking</span><br><span class="line"><span class="comment"># 指定启动服务的命令</span></span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/es/bin/elasticsearch -d</span><br><span class="line"><span class="comment"># 指定服务在退出后不重启。可以根据需要将其更改为 always 或 on-failure，以确保服务在失败后自动重启。</span></span><br><span class="line">Restart=no</span><br><span class="line"><span class="comment"># 指定以 es 用户的身份运行服务。</span></span><br><span class="line">User=es</span><br><span class="line"><span class="comment"># 指定服务所属的组为 es。</span></span><br><span class="line">Group=es</span><br><span class="line"><span class="comment"># 设置进程打开文件的最大数量（文件描述符限制）</span></span><br><span class="line">LimitNOFILE=131070</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="comment"># 指定服务的目标，表示该服务在多用户模式下可用。</span></span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载systemd配置文件</span></span><br><span class="line">[root@elk01 config]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动es</span></span><br><span class="line">[root@elk01 config]<span class="comment"># systemctl restart es</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、部署ES集群"><a href="#3、部署ES集群" class="headerlink" title="3、部署ES集群"></a>3、部署ES集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建用于启动ES的用户</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># useradd es </span></span><br><span class="line">[root@elk01 opt]<span class="comment"># id es</span></span><br><span class="line">uid=1000(elasticsearch) gid=1000(elasticsearch) 组=1000(elasticsearch)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建ES数据目录和日志目录存放目录</span></span><br><span class="line">[root@elk01 usr]<span class="comment"># mkdir -p /opt/&#123;data,logs&#125;</span></span><br><span class="line">[root@elk01 usr]<span class="comment"># install -d /opt/&#123;data,logs&#125;/es -o es -g es</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 解压es安装包到指定目录</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># tar xf elasticsearch-7.17.11-linux-x86_64.tar.gz  -C /opt/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 更改目录名</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># cd /opt/ &amp;&amp; mv  elasticsearch-7.17.11  es</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建ES环境变量</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># vim  &gt;&gt; /etc/profile.d/es.sh &lt;&lt;-EOF</span></span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">export</span> ES_HOME=/opt/es</span><br><span class="line"><span class="built_in">export</span> PATH=\<span class="variable">$PATH</span>:\<span class="variable">$ES_HOME</span>/bin</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载环境变量</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># source /etc/profile.d/es.sh </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改elasticsearch属主和数组</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># chown -R  es,es  /opt/es</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改es需要的limits参数（重新连接会话框才能成功加载参数）</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># cat &gt;&gt; /etc/security/limits.d/elk.conf &lt;&lt;-EOF</span></span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 131070</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看limits参数是否加载</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># ulimit -Sn</span></span><br><span class="line">65535</span><br><span class="line">[root@elk01 opt]<span class="comment"># ulimit -Hn</span></span><br><span class="line">131070</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改内核参数</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># cat &gt; /etc/sysctl.d/elk.conf &lt;&lt;EOF</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line">EOF</span><br><span class="line">    </span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 加载内核参数</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># sysctl -f /etc/sysctl.d/elk.conf</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line">[root@elk01 opt]<span class="comment"># sysctl -q vm.max_map_count</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改堆内存大小（最大设置为32G，要么内存的一半）</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># vim /opt/elasticsearch-7.17.11/config/jvm.options</span></span><br><span class="line">···</span><br><span class="line">-Xms256m</span><br><span class="line">-Xmx256m</span><br><span class="line">···</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; elk01修改配置文件</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># egrep -v "^(#|$)" /opt/es/config/elasticsearch.yml </span></span><br><span class="line">cluster.name: study-elk-cluster</span><br><span class="line">node.name: elk01</span><br><span class="line">path.data: /opt/data/es<span class="comment"># 指定数据目录</span></span><br><span class="line">path.logs: /opt/logs/es<span class="comment"># 指定日志目录</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">discovery.seed_hosts: [<span class="string">"192.168.100.160"</span>,<span class="string">"192.168.100.161"</span>,<span class="string">"192.168.100.162"</span>]</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"192.168.100.160"</span>,<span class="string">"192.168.100.161"</span>,<span class="string">"192.168.100.162"</span>]</span><br><span class="line">ingest.geoip.downloader.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; elk02修改配置文件</span></span><br><span class="line">[root@elk02 opt]<span class="comment"># egrep -v "^(#|$)" /opt/es/config/elasticsearch.yml </span></span><br><span class="line">cluster.name: study-elk-cluster</span><br><span class="line">node.name: elk02</span><br><span class="line">path.data: /opt/data/es</span><br><span class="line">path.logs: /opt/logs/es</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">discovery.seed_hosts: [<span class="string">"192.168.100.160"</span>,<span class="string">"192.168.100.161"</span>,<span class="string">"192.168.100.162"</span>]</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"192.168.100.160"</span>,<span class="string">"192.168.100.161"</span>,<span class="string">"192.168.100.162"</span>]</span><br><span class="line">ingest.geoip.downloader.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; elk03修改配置文件</span></span><br><span class="line">[root@elk03 opt]<span class="comment"># egrep -v "^#|^$" /opt/es/config/elasticsearch.yml </span></span><br><span class="line">cluster.name: study-elk-cluster</span><br><span class="line">node.name: elk03</span><br><span class="line">path.data: /opt/data/es</span><br><span class="line">path.logs: /opt/logs/es</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">discovery.seed_hosts: [<span class="string">"192.168.100.160"</span>,<span class="string">"192.168.100.161"</span>,<span class="string">"192.168.100.162"</span>]</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"192.168.100.160"</span>,<span class="string">"192.168.100.161"</span>,<span class="string">"192.168.100.162"</span>]</span><br><span class="line">ingest.geoip.downloader.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 所有节点添加elk启动脚本</span></span><br><span class="line">[root@elk03 opt]<span class="comment"># cat &gt; /usr/lib/systemd/system/es.service &lt;&lt;EOF</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=ELK</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/opt/es/bin/elasticsearch -d</span><br><span class="line">Restart=no</span><br><span class="line">User=es</span><br><span class="line">Group=es</span><br><span class="line">LimitNOFILE=131070</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 所有节点重新加载并启动</span></span><br><span class="line">[root@elk01 config]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@elk01 config]<span class="comment"># systemctl restart es</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试集群</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># curl 192.168.100.160:9200/_cat/nodes</span></span><br><span class="line">192.168.100.160 40 59  8 0.14 0.10 0.06 cdfhilmrstw * elk01</span><br><span class="line">192.168.100.161 54 30 11 0.55 0.29 0.11 cdfhilmrstw - elk02</span><br><span class="line">192.168.100.162 48 28  8 0.29 0.16 0.06 cdfhilmrstw - elk03</span><br><span class="line">  <span class="comment"># 参数解释：</span></span><br><span class="line">    第一列：每个节点的IP地址；</span><br><span class="line">    第二列：每个节点的CPU使用率；</span><br><span class="line">    第三列：每个节点的内存的使用率；</span><br><span class="line">    第四列：每个节点的活跃分片数量；</span><br><span class="line">    第五列：每个节点的1分钟、5分钟、15分钟平均负载；</span><br><span class="line">    第六列：每个节点在集群中的角色；</span><br><span class="line">    第七列：*代表主节点；主节点负责管理集群的元数据、分片分配和集群状态等任务。</span><br><span class="line">    第八列：节点的名称</span><br></pre></td></tr></table></figure><p>三、Kibana安装（elk03节点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 安装kibana</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># yum localinstall -y kibana-7.17.11-x86_64.rpm </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 备份配置文件</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># cd /etc/kibana/</span></span><br><span class="line">[root@elk03 kibana]<span class="comment"># cp kibana.yml kibana.yml.bak</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改kibana配置文件</span></span><br><span class="line">[root@elk03 kibana]<span class="comment"># egrep -v "^(#|$)" kibana.yml </span></span><br><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line">server.port: 5601</span><br><span class="line"><span class="comment"># 主机地址或者主机名</span></span><br><span class="line">server.host: <span class="string">"0.0.0.0"</span></span><br><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line">server.name: <span class="string">"study-elk-kibana"</span></span><br><span class="line"><span class="comment"># ES主机组地址</span></span><br><span class="line">elasticsearch.hosts: [<span class="string">"http://192.168.100.160:9200"</span>,<span class="string">"http://192.168.100.161:9200"</span>,<span class="string">"http://192.168.100.162:9200"</span>]</span><br><span class="line"><span class="comment"># 修改语言</span></span><br><span class="line">i18n.locale: <span class="string">"zh-CN"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 启动Kibana</span></span><br><span class="line">[root@elk03 kibana]<span class="comment"># systemctl enable --now kibana</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 游览器IP+5601访问</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405291424194.png#id=mXN3G&originHeight=1368&originWidth=2544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h2 id="四、Logstash安装（elk02）"><a href="#四、Logstash安装（elk02）" class="headerlink" title="四、Logstash安装（elk02）"></a>四、Logstash安装（elk02）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 安装Logstash</span></span><br><span class="line">[root@elk02 ~]<span class="comment"># yum localinstall -y logstash-7.17.11-x86_64.rpm </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建软连接</span></span><br><span class="line">[root@elk02 <span class="built_in">local</span>]<span class="comment"># ln -s /usr/share/logstash/bin/logstash   /usr/bin/logstash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 编写测试文件</span></span><br><span class="line">[root@elk02 ~]<span class="comment"># mkdir conf-logstash</span></span><br><span class="line">[root@elk02 ~]<span class="comment"># cat  conf-logstash/01-stdin-to-stdout.conf </span></span><br><span class="line">input &#123;</span><br><span class="line"> stdin &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line"> stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试Logstash</span></span><br><span class="line">[root@elk02 ~]<span class="comment"># logstash -f ~/conf-logstash/01-stdin-to-stdout.conf</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1724775298040-1170b872-9cec-4b44-8a9f-5f4336aad57a.png#averageHue=%23070706&clientId=u75f1b712-9c51-4&from=paste&height=294&id=uf9f627e0&originHeight=294&originWidth=1095&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21705&status=done&style=none&taskId=ud3c9e175-6ee9-419e-8bd5-8122d076e6e&title=&width=1095" alt="image.png"></p><h2 id="五、Filebeat安装（elk01）"><a href="#五、Filebeat安装（elk01）" class="headerlink" title="五、Filebeat安装（elk01）"></a>五、Filebeat安装（elk01）</h2><p>帮助文档：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/index.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 安装Filebeat</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># yum localinstall -y filebeat-7.17.11-x86_64.rpm </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试Filebeat</span></span><br><span class="line">[root@elk01 opt]<span class="comment"># cd filebeat</span></span><br><span class="line">[root@elk01 filebeat]<span class="comment"># mkdir filebeat-config</span></span><br><span class="line">[root@elk01 filebeat]<span class="comment"># cp filebeat.yml  filebeat-config/01-test.yml</span></span><br><span class="line">[root@elk01 filebeat]<span class="comment"># cat filebeat-config/01-test.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: stdin</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">output.console:</span><br><span class="line">  pretty: <span class="literal">true</span>    <span class="comment"># 启动美观格式输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 filebeat]<span class="comment"># filebeat -e -c /opt/filebeat/filebeat-config/01-test.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405291142027.png#from=url&id=FZw9q&originHeight=1186&originWidth=1471&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><h4 id="1、Filebeat架构"><a href="#1、Filebeat架构" class="headerlink" title="1、Filebeat架构"></a>1、Filebeat架构</h4><p>架构图：<br>    Input（数据源）收集方式：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/configuration-filebeat-options.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/configuration-filebeat-options.html</a><br>    Output（输出地）推送方式：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/configuring-output.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/configuring-output.html</a><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405291516016.png#id=NuwUn&originHeight=658&originWidth=1714&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h2 id="六、Filebeat日志收集"><a href="#六、Filebeat日志收集" class="headerlink" title="六、Filebeat日志收集"></a>六、Filebeat日志收集</h2><p><code>Input</code>方式：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/filebeat-input-stdin.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/filebeat-input-stdin.html</a></p><h4 id="1、Filebeat标准输入和输出"><a href="#1、Filebeat标准输入和输出" class="headerlink" title="1、Filebeat标准输入和输出"></a>1、Filebeat标准输入和输出</h4><p>​    标准输入官方文档：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/filebeat-input-stdin.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/filebeat-input-stdin.html</a><br>​    标准输出官方文档：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/console-output.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/console-output.html</a><br>​    <strong>简介</strong>：使用终端输入从标准输入读取事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Filebeat配置文件测试目录</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># mkdir filebeat-config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/01-stdin-on-stdout.yml </span></span><br><span class="line"><span class="comment"># 指定输入类型</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">  <span class="comment"># 终端标准输入</span></span><br><span class="line">- <span class="built_in">type</span>: stdin</span><br><span class="line"><span class="comment"># 标准输出类型：终端输出</span></span><br><span class="line"></span><br><span class="line">output.console:</span><br><span class="line">  <span class="comment">#如果设置为 true，则写入 stdout 的事件将采用良好的格式。默认值为 false。</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c /root/filebeat-config/01-stdin-on-stdout.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292047924.png#from=url&id=lfzKX&originHeight=1267&originWidth=1816&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><h4 id="2、-Filebeat-基于Log类型进行输入"><a href="#2、-Filebeat-基于Log类型进行输入" class="headerlink" title="2、 Filebeat 基于Log类型进行输入"></a>2、 Filebeat 基于Log类型进行输入</h4><p>​    <code>Log</code>方式类型输入：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/filebeat-input-log.html#input-paths" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/filebeat-input-log.html#input-paths</a><br>​    <strong>简介</strong>： <code>Log类型</code>输入将日志文件发送到输出。使用输入从日志文件中读取行。此类型<code>[ 7.16.0 ]</code>版本以后废弃，推荐使用<code>filestream input</code>类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 编写Log类型日志输入测试文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/02-log-on-stdout.yml </span></span><br><span class="line"><span class="comment"># 指定输入类型</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line"><span class="comment"># 日志输入类型</span></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  <span class="comment"># 日志存放路径</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/messages</span><br><span class="line">    - /var/<span class="built_in">log</span>/*.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 设置标准终端输出至屏幕</span></span><br><span class="line">output.console:</span><br><span class="line">  <span class="comment">#如果设置为 true，则写入stdout的事件将采用良好的格式。默认值为 false。</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c /root/filebeat-config/02-log-on-stdout.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292111651.png#id=xCb24&originHeight=1048&originWidth=2017&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="2-1-Filebeat-基于Log类型进行输入并且自定义字段"><a href="#2-1-Filebeat-基于Log类型进行输入并且自定义字段" class="headerlink" title="2.1 Filebeat 基于Log类型进行输入并且自定义字段"></a><strong>2.1 Filebeat 基于Log类型进行输入并且自定义字段</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@elk01 ~]<span class="comment"># vim  filebeat-config/02-log-on-stdout.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/messages</span><br><span class="line">  <span class="comment"># 开启自定义字段</span></span><br><span class="line">  fields:</span><br><span class="line">    <span class="comment"># 添加自定义字段</span></span><br><span class="line">    log_type: system</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  <span class="comment"># 开启自定义字段</span></span><br><span class="line">  fields:</span><br><span class="line">    <span class="comment"># 开启自定义字段</span></span><br><span class="line">    log_type: nginx_access</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">output.console:</span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 清除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 启动Filebeat实例</span></span><br><span class="line">[root@elk01 filebeat]<span class="comment"># filebeat  -e -c /root/filebeat-config/02-log-on-stdout.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292301452.png#id=f6HAq&originHeight=691&originWidth=1962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><blockquote><p>注意：<br>    如果fields_under_root设置为true，则自定义字段将作为顶级字段存储在输出文档中，而不是分组在字段子字典下。如果自定义字段名称与Filebeat添加的其他字段名称冲突，则自定义字段将覆盖其他字段。效果图如下：<br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292336305.png#from=url&id=Qq88e&originHeight=757&originWidth=1828&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p></blockquote><h5 id="2-2-Filebeat-基于Log类型进行输入并且自定义Tags"><a href="#2-2-Filebeat-基于Log类型进行输入并且自定义Tags" class="headerlink" title="2.2 Filebeat 基于Log类型进行输入并且自定义Tags"></a><strong>2.2 Filebeat 基于Log类型进行输入并且自定义Tags</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@elk01 ~]<span class="comment"># vim  filebeat-config/02-log-on-stdout.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/messages</span><br><span class="line">  <span class="comment"># 对当前的输入日志文件，指定独有的标签</span></span><br><span class="line">  tags: [<span class="string">"system logs"</span>,<span class="string">""</span>,<span class="string">""</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: system</span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  <span class="comment"># 对当前的输入日志文件，指定独有的标签 </span></span><br><span class="line">  tags: [<span class="string">"nginx access_log"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_access</span><br><span class="line"></span><br><span class="line">output.console:</span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># &gt; /var/lib/filebeat/registry/filebeat/log.json </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 filebeat]<span class="comment"># filebeat  -e -c /root/filebeat-config/02-log-on-stdout.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292322333.png#id=UMxF5&originHeight=1077&originWidth=2002&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><blockquote><p>对于Tags的设定，将Filebeat收集到的日志转发至ES集群时，可以针对不同的Tag设置不同的索引，方便查阅。</p></blockquote><h5 id="2-3-offset偏移量概念"><a href="#2-3-offset偏移量概念" class="headerlink" title="2.3 offset偏移量概念"></a>2.3 offset偏移量概念</h5><p><strong>简介</strong>：偏移量（offset）在 Filebeat 中指的是文件读取位置的标记，用于追踪文件中的读取进度。<br>在某些情况下，可能需要手动操作偏移量。例如：</p><ul><li>假如想要<code>重新读取</code>一个<code>日志文件</code>，可以删除对应的注册表条目或者编辑偏移量值。注意：请确保 Filebeat 暂停运行期间进行这些操作以防止冲突。</li></ul><p><code>RPM方式</code>安装的Filebeat offset存放路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># cd  /var/lib/filebeat/registry/filebeat/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">[root@elk01 filebeat]<span class="comment"># ls</span></span><br><span class="line">log.json  meta.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除偏移量文件，启动Filebeat重新读取日志文件</span></span><br><span class="line">[root@elk01 registry]<span class="comment"># &gt; log.json</span></span><br></pre></td></tr></table></figure><blockquote><p><code>log.json</code>为偏移量存放文件。清空偏移量后，再次启动Filebeat会<code>重新读取日志文件</code>。</p></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292210601.png#id=Q39yO&originHeight=135&originWidth=2296&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><strong>思考题：为什么Filebeat需要设置这个偏移量？</strong></p><h5 id="2-4-Filebeat-基于Log类型进行输入实现日志删除"><a href="#2-4-Filebeat-基于Log类型进行输入实现日志删除" class="headerlink" title="2.4 Filebeat 基于Log类型进行输入实现日志删除"></a>2.4 Filebeat 基于Log类型进行输入实现日志删除</h5><p>支持正则表达式：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/regexp-support.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/regexp-support.html</a><br>    <strong>简介</strong>：<code>exclude_lines</code>与要Filebeat排除的行匹配的正则表达式列表。Filebeat将删除列表中与正则表达式匹配的所有行。默认情况下，不会删除任何行。空行将被忽略。如果还指定了多行设置，则在通过exclude_lines过滤行之前，每条多行消息都将合并为一行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写测试日志文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># cat &gt;&gt; /tmp/test.log &lt;&lt; EOF</span></span><br><span class="line">hi cloud</span><br><span class="line">hello world</span><br><span class="line">Hello cloud</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写Filebeat配置文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/03-log-exclude-stdin.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line">  tags: [<span class="string">"test"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: <span class="built_in">test</span></span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 删除以hello开头的行，注意区分大小写</span></span><br><span class="line">  exclude_lines: [<span class="string">'^hello'</span>,<span class="string">'^haha'</span>,<span class="string">'^lala'</span>]</span><br><span class="line"></span><br><span class="line">output.console:</span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c /root/filebeat-config/03-log-exclude-stdin.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292358366.png#from=url&id=lsydL&originHeight=1264&originWidth=1980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt><br><strong>查看offset偏移量</strong><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292359570.png#id=B1zCR&originHeight=144&originWidth=2299&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><strong>查看文件字符</strong><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405292359075.png#id=DvN9D&originHeight=100&originWidth=1249&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><blockquote><p>此参数是在该日志文件阅读完成以后，在进行过滤删除，故在offset文件中还是有所体现。</p></blockquote><h5 id="2-5-Filebeat-基于Log类型进行输入实现匹配日志输出"><a href="#2-5-Filebeat-基于Log类型进行输入实现匹配日志输出" class="headerlink" title="2.5 Filebeat 基于Log类型进行输入实现匹配日志输出"></a>2.5 Filebeat 基于Log类型进行输入实现匹配日志输出</h5><p>支持正则表达式：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/regexp-support.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/regexp-support.html</a><br><strong>简介</strong>：<code>include_lines</code>希望Filebeat包含的行相匹配的正则表达式列表。Filebeat仅导出与列表中正则表达式匹配的行。默认情况下，将导出所有行。空行将被忽略。如果还指定了多行设置，则在通过include_lines过滤行之前，每条多行消息将合并为一行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备测试日志文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># cat &gt;&gt;/tmp/test02.log  &lt;&lt;EOF</span></span><br><span class="line">ERR haha</span><br><span class="line">WARN haha</span><br><span class="line">info haha</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写Filebeat测试文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/04-log-include-stdin.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test02.log</span><br><span class="line">  tags: [<span class="string">"test"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: <span class="built_in">test</span></span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 只过滤出以ERR WARN的行，区分大小写</span></span><br><span class="line">  include_lines: [<span class="string">'^ERR'</span>,<span class="string">'^WARN'</span>]</span><br><span class="line"></span><br><span class="line">output.console:</span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat -e -c  /root/filebeat-config/04-log-include-stdin.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300017494.png#from=url&id=tK5b7&originHeight=850&originWidth=1818&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><h5 id="2-6-include-lines和exclude-lines优先级"><a href="#2-6-include-lines和exclude-lines优先级" class="headerlink" title="2.6 include_lines和exclude_lines优先级"></a>2.6 include_lines和exclude_lines优先级</h5><p>​    如果同时定义了<code>include_lines</code>和<code>exclude_lines</code>，则Filebeat首先执行<code>include_lines</code>，然后执行<code>exclude_line</code>。定义这两个选项的顺序无关紧要。<code>include_lines</code>选项将始终在<code>exclude_lines</code>选项之前执行，即使<code>exclude_line</code>出现在配置文件中的<code>include_lines</code>之前也是如此。</p><h5 id="2-7-Nginx-error日志过滤处理实战"><a href="#2-7-Nginx-error日志过滤处理实战" class="headerlink" title="2.7 Nginx error日志过滤处理实战"></a>2.7 Nginx error日志过滤处理实战</h5><p><strong>简介</strong>：在公司中，对于应用的错误日志一般只关心包含<code>error</code>等相关内容的行，其它的我们都需要对其进行过滤处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 编写测试日志文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim  /var/log/nginx/error.log </span></span><br><span class="line">2024/05/30 01:55:13 [notice] 967<span class="comment">#967: worker process 976 exited with code 0</span></span><br><span class="line">2024/05/30 01:55:13 [notice] 967<span class="comment">#967: signal 29 (SIGIO) received</span></span><br><span class="line">2024/05/30 01:55:13 [notice] 967<span class="comment">#967: signal 17 (SIGCHLD) received from 977</span></span><br><span class="line">2024/05/30 01:55:13 [notice] 967<span class="comment">#967: worker process 977 exited with code 0</span></span><br><span class="line">2024/05/30 01:55:13 [notice] 967<span class="comment">#967: signal 17 (SIGCHLD) received from 975</span></span><br><span class="line">2024/05/30 01:55:13 [notice] 967<span class="comment">#967: worker process 975 exited with code 0</span></span><br><span class="line">2024/05/30 01:55:13 [notice] 967<span class="comment">#967: exit</span></span><br><span class="line">2024/05/30 01:55:33 [emerg] 2359<span class="comment">#2359: unexpected "&#125;" in /etc/nginx/nginx.conf:11</span></span><br><span class="line">2024/05/30 01:55:16 [emerg] 2384<span class="comment">#2384: "access_log" directive is not allowed here in /etc/nginx/nginx.conf:22</span></span><br><span class="line">2024/05/30 01:55:41 [notice] 2396<span class="comment">#2396: using the "epoll" event method</span></span><br><span class="line">2024/05/30 01:55:41 [notice] 2396<span class="comment">#2396: nginx/1.24.0</span></span><br><span class="line">2024/05/30 01:55:41 [notice] 2396<span class="comment">#2396: built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) </span></span><br><span class="line">2024/05/30 01:55:41 [notice] 2396<span class="comment">#2396: OS: Linux 3.10.0-1160.el7.x86_64</span></span><br><span class="line">2024/05/30 01:55:41 [notice] 2396<span class="comment">#2396: getrlimit(RLIMIT_NOFILE): 1024:4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 编写Filebeat测试文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/05-log-nginx-error-stdin.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/error.log</span><br><span class="line">  tags: [<span class="string">"nginx_error"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_error</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  include_lines: [<span class="string">'\[emerg\]'</span>]</span><br><span class="line"></span><br><span class="line">output.console:</span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat -e -c /root/filebeat-config/05-log-nginx-error-stdin.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300034705.png#id=PKtHd&originHeight=621&originWidth=2215&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="2-8-Filebeat输出数据至Elasticsearch集群"><a href="#2-8-Filebeat输出数据至Elasticsearch集群" class="headerlink" title="2.8 Filebeat输出数据至Elasticsearch集群"></a>2.8 Filebeat输出数据至Elasticsearch集群</h5><p>官方链接：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/elasticsearch-output.html#elasticsearch-output" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/elasticsearch-output.html#elasticsearch-output</a><br>    简介：Elasticsearch输出使用Elasticsearch <code>HTTP API</code>将事件直接发送到Elasticearch。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写Filebeat配置文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/06-log-nginx-access-es.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"nginx_access"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_access</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出至ES集群</span></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  <span class="comment"># ES集群地址</span></span><br><span class="line">  hosts: [<span class="string">"http://192.168.174.140:9200"</span>,<span class="string">"http://192.168.174.141:9200"</span>,<span class="string">"http://192.168.174.142:9200"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c /root/filebeat-config/06-log-nginx-access-es.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300051042.png#id=b1B1L&originHeight=457&originWidth=2308&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><strong>Kibana查看ES数据</strong><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300053155.png#id=M9HFQ&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300053167.png#id=J99r5&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300054359.png#id=i3BKi&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300056067.png" alt></p><blockquote><p>通过索引模式来匹配索引</p></blockquote><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300059360.png">![](https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300059590.png#id=b38Ds&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none)<h5 id="2-9-Filebeat输出数据至Elasticsearch集群并自定义单个索引"><a href="#2-9-Filebeat输出数据至Elasticsearch集群并自定义单个索引" class="headerlink" title="2.9 Filebeat输出数据至Elasticsearch集群并自定义单个索引"></a>2.9 Filebeat输出数据至Elasticsearch集群并自定义单个索引</h5><p>官网：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/elasticsearch-output.html#index-option-es" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/elasticsearch-output.html#index-option-es</a><br>    <strong>简介</strong>：使用每日索引时要将事件写入的索引名称。默认值为“filebeat-%｛[agent.version]｝-%｛+yyyy.MM.dd｝”，例如“filebeat-7.17.21-2024-05-22”。<code>在公司中一般会根据日志的类型设置不同的索引</code>。但是如果需要自定以索引，需要把索引的生命周期管理给禁用掉<code>setup.ilm.enabled: false</code>，否则自定以索引无法生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写Filebeat测试文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/07-log-nginx-access-es.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"nginx_access"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_access</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">"http://192.168.174.140:9200"</span>,<span class="string">"http://192.168.174.141:9200"</span>,<span class="string">"http://192.168.174.142:9200"</span>]</span><br><span class="line">  index: <span class="string">"web-nginx-access-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line"><span class="comment"># 禁用索引生命周期管理</span></span><br><span class="line">setup.ilm.enabled: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置索引模板的名称</span></span><br><span class="line">setup.template.name: <span class="string">"web"</span></span><br><span class="line"><span class="comment"># 设置索引模板的匹配模式 </span></span><br><span class="line">setup.template.pattern: <span class="string">"web*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat -e -c  /root/filebeat-config/07-log-nginx-access-es.yml</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>参数解释：</strong><br>setup.ilm.enabled: false        #  禁用了 Filebeat 的 索引生命周期管理， ILM 是 Elasticsearch 提供的一种功能，用于自动管理索引的生命周期。通过 ILM，管理员可以定义索引的创建、滚动（如每天创建一个新索引）、迁移（如将数据从热节点迁移到冷节点）、归档和删除等操作。<br>setup.template.name: “web”    #  指定了 Filebeat创建的索引模板的名称。索引模板定义了 Elasticsearch 中新创建的索引的默认设置和映射。每当一个新索引与指定的模板模式匹配时，Elasticsearch 会应用该模板中的设置和映射规则。<br>setup.template.pattern: web #  定义索引模板的 匹配模式。  web：表示 Filebeat创建的所有索引名称中，只要符合 web的模式，都会使用名为 web的模板。 是通配符，表示任意字符。</p></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300145654.png#id=GlOsK&originHeight=186&originWidth=2311&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><strong>kibana操作和查看</strong><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300145138.png#id=G65HQ&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300146998.png#id=c4WDn&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300146229.png#id=XsxCy&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300146120.png#id=kIljc&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300147625.png#id=Bux5a&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300147139.png#id=W7lQm&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300148550.png#id=gJChe&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300149819.png#id=kOa4s&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300149995.png#id=DjuYD&originHeight=1417&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="2-10-Filebeat输出数据至Elasticsearch集群并自定义多个索引"><a href="#2-10-Filebeat输出数据至Elasticsearch集群并自定义多个索引" class="headerlink" title="2.10 Filebeat输出数据至Elasticsearch集群并自定义多个索引"></a>2.10 Filebeat输出数据至Elasticsearch集群并自定义多个索引</h5><p>官网：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/elasticsearch-output.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/elasticsearch-output.html</a><br><strong>简介</strong>：每个规则都指定用于与该规则匹配的事件的索引。在发布过程中，Filebeat使用数组中的第一个匹配规则。规则可以包含条件、基于字符串的字段格式和名称映射。如果缺少索引设置或没有匹配的规则，则使用索引设置。与索引类似，定义自定义索引将禁用索引生命周期管理（ILM）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 编写Filebeat配置文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/08-log-nginx-log-es.yml </span></span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/.<span class="built_in">log</span></span><br><span class="line">  tags: [<span class="string">"nginx_access"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_access</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/error.log</span><br><span class="line">  tags: [<span class="string">"nginx_error"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_error</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  include_lines: [<span class="string">'\[emerg\]'</span>]</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">"http://192.168.174.140:9200"</span>,<span class="string">"http://192.168.174.141:9200"</span>,<span class="string">"http://192.168.174.142:9200"</span>] </span><br><span class="line">  indices:</span><br><span class="line">    <span class="comment"># 索引名称</span></span><br><span class="line">    - index: <span class="string">"web-nginx-access-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">      <span class="comment"># 匹配标签</span></span><br><span class="line">      when.contains:</span><br><span class="line">        tags: <span class="string">"nginx_access"</span></span><br><span class="line">    <span class="comment"># 索引名称</span></span><br><span class="line">    - index: <span class="string">"web-nginx-error-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">      <span class="comment"># 匹配标签</span></span><br><span class="line">      when.contains:</span><br><span class="line">        tags: <span class="string">"nginx_error"</span></span><br><span class="line"><span class="comment"># 禁索引命周期管理</span></span><br><span class="line">setup.ilm.enabled: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置索引模板的名称</span></span><br><span class="line">setup.template.name: <span class="string">"web"</span></span><br><span class="line"><span class="comment"># 设置索引模板的匹配模式 </span></span><br><span class="line">setup.template.pattern: <span class="string">"web*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat -e -c /root/filebeat-config/08-log-nginx-log-es.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300740915.png#id=JynSZ&originHeight=93&originWidth=2309&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><strong>kibana操作和查看</strong><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300741244.png#id=kqKes&originHeight=1339&originWidth=2558&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300741426.png#id=nzAhr&originHeight=1399&originWidth=2557&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300741233.png#id=mgB03&originHeight=1389&originWidth=2556&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" style="zoom:67%;"><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300743134.png#id=PIKA3&originHeight=1106&originWidth=2552&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405300743612.png#id=vqoCm&originHeight=856&originWidth=2556&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><blockquote><p>注意：日志是以索引的方式写入的！</p></blockquote><h5 id="2-11-Filebeat输出数据至Elasticsearch集群并设定副本分片"><a href="#2-11-Filebeat输出数据至Elasticsearch集群并设定副本分片" class="headerlink" title="2.11 Filebeat输出数据至Elasticsearch集群并设定副本分片"></a>2.11 Filebeat输出数据至Elasticsearch集群并设定副本分片</h5><p>官网：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/configuration-template.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/configuration-template.html</a><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302048641.png#id=QwD2a&originHeight=846&originWidth=1361&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><strong>简介</strong>：</p><ul><li><code>index.number_of_shards: 3</code>：主分片（primary shard）是将数据分割成较小部分以便分布存储和基础单位。设置主分片数为3意味着每个索引将分成3个主分片。主分片的数量在索引创建后无法更改。</li><li><code>index.number_of_replicas: 1</code>：副本分片（replica shard）是主分片的副本，用于提供高可用性和故障恢复能力。如果主分片所在的节点故障，副本分片可以作为备份继续提供数据服务。设置副本分片数为1意味着每个主分片将有1个副本分片。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写Filebeat测试文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/09-log-nginx-log-shard-es.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"nginx_access"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_access</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/error.log</span><br><span class="line">  tags: [<span class="string">"nginx_error"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_error</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  include_lines: [<span class="string">'\[emerg\]'</span>]</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">"http://192.168.174.140:9200"</span>,<span class="string">"http://192.168.174.141:9200"</span>,<span class="string">"http://192.168.174.142:9200"</span>] </span><br><span class="line">  indices:</span><br><span class="line">    <span class="comment"># 索引名称</span></span><br><span class="line">    - index: <span class="string">"web-nginx-access-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">      <span class="comment"># 匹配标签</span></span><br><span class="line">      when.contains:</span><br><span class="line">        tags: <span class="string">"nginx_access"</span></span><br><span class="line">    <span class="comment"># 索引名称</span></span><br><span class="line">    - index: <span class="string">"web-nginx-error-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">      <span class="comment"># 匹配标签</span></span><br><span class="line">      when.contains:</span><br><span class="line">        tags: <span class="string">"nginx_error"</span></span><br><span class="line"><span class="comment"># 禁索引命周期管理</span></span><br><span class="line">setup.ilm.enabled: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置索引模板的名称</span></span><br><span class="line">setup.template.name: <span class="string">"web"</span></span><br><span class="line"><span class="comment"># 设置索引模板的匹配模式 </span></span><br><span class="line">setup.template.pattern: <span class="string">"web*"</span></span><br><span class="line"><span class="comment"># 配置索引模板</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  <span class="comment"># 设置分片数量</span></span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line">  <span class="comment"># 设置副本数量，要求小于集群的数量</span></span><br><span class="line">  index.number_of_replicas: 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat -e -c /root/filebeat-config/09-log-nginx-error-shard-es.yml</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：三分片一副本，表示每个主分片都会有一个副本分片，分片数量一旦确定，不能修改(缩容/扩容)。会导致数据无法查找。副本分片可以扩容。</strong></p></blockquote></li></ul><p><code>记得把原有的模板给删除掉，否则分片和副本数量无法修改成功</code><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302104084.png#id=olh8D&originHeight=1530&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302104604.png#id=VZdWu&originHeight=1530&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="2-12-FIlebeat-收集JSON格式的nginx访问日志"><a href="#2-12-FIlebeat-收集JSON格式的nginx访问日志" class="headerlink" title="2.12 FIlebeat 收集JSON格式的nginx访问日志"></a>2.12 FIlebeat 收集JSON格式的nginx访问日志</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim /etc/yum.repos.d/nginx.repo</span></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># yum install -y nginx</span></span><br><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># systemctl enable --now nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改nginx访问日志格式</span></span><br><span class="line">[root@elk-01 ~]<span class="comment"># vim /etc/nginx/nginx.conf </span></span><br><span class="line">···</span><br><span class="line">   log_format  test_nginx_json <span class="string">'&#123;"@timestamp":"$time_iso8601",'</span></span><br><span class="line">                                <span class="string">'"host":"$server_addr",'</span></span><br><span class="line">                                <span class="string">'"clientip":"$remote_addr",'</span></span><br><span class="line">                                <span class="string">'"SendBytes":$body_bytes_sent,'</span></span><br><span class="line">                                <span class="string">'"responsetime":$request_time,'</span></span><br><span class="line"> </span><br><span class="line">   <span class="string">'"upstreamtime":"$upstream_response_time",'</span></span><br><span class="line">                                <span class="string">'"upstreamhost":"$upstream_addr",'</span></span><br><span class="line">                                <span class="string">'"http_host":"$host",'</span></span><br><span class="line">                                <span class="string">'"uri":"$uri",'</span></span><br><span class="line">                                <span class="string">'"domain":"$host",'</span></span><br><span class="line">                                <span class="string">'"xff":"$http_x_forwarded_for",'</span></span><br><span class="line">                                <span class="string">'"referer":"$http_referer",'</span></span><br><span class="line">                                <span class="string">'"tcp_xff":"$proxy_protocol_addr",'</span></span><br><span class="line">                                <span class="string">'"http_user_agent":"$http_user_agent",'</span></span><br><span class="line">                                <span class="string">'"status":"$status"&#125;'</span>;</span><br><span class="line">      access_log  /var/<span class="built_in">log</span>/nginx/access.log  test_nginx_json;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查语法格式</span></span><br><span class="line">[root@elk-01 ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启nginx</span></span><br><span class="line">[root@elk-01 ~]<span class="comment"># systemctl reload nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># curl localhost</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># cat /var/log/nginx/access.log</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302119292.png#id=RmNGX&originHeight=137&originWidth=2271&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改Filebeat配置(识别json格式日志，生成相关字段)</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-config/10-log-nginx-log-shard-json-es.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log*</span><br><span class="line">  tags: [<span class="string">"access"</span>]</span><br><span class="line"><span class="comment"># 启动json格式  </span></span><br><span class="line">  json.keys_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">"http://192.168.174.140:9200"</span>,<span class="string">"http://192.168.174.141:9200"</span>,<span class="string">"http://192.168.174.142:9200"</span>]</span><br><span class="line">  index: <span class="string">"web-nginx-access-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line"><span class="comment"># 禁索引命周期管理</span></span><br><span class="line">setup.ilm.enabled: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置索引模板的名称</span></span><br><span class="line">setup.template.name: <span class="string">"web"</span></span><br><span class="line"><span class="comment"># 设置索引模板的匹配模式 </span></span><br><span class="line">setup.template.pattern: <span class="string">"web*"</span></span><br><span class="line"><span class="comment"># 覆盖已有的索引模板，如果为true，则会直接覆盖现有的索引模板，如果为false则不覆盖!</span></span><br><span class="line">setup.template.overwrite: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 配置索引模板</span></span><br><span class="line">setup.template.settings:</span><br><span class="line"><span class="comment"># 设置分片数量</span></span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line"><span class="comment"># 设置副本数量，要求⼩于集群的数量</span></span><br><span class="line">  index.number_of_replicas: 1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除filebeat的指针偏移，用于从第一行重新读取日志文件</span></span><br><span class="line">[root@elk-01 <span class="built_in">log</span>]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清楚以前的ES nginx索引，防止出现脏数据</span></span><br><span class="line">略</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启filebeat</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat -e -c ~/filebeat-config/10-log-nginx-log-shard-json-es.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302132161.png#id=FYhqo&originHeight=1530&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h2 id="七、Logstash-日志收集"><a href="#七、Logstash-日志收集" class="headerlink" title="七、Logstash 日志收集"></a>七、Logstash 日志收集</h2><p>官网：<a href="https://www.elastic.co/guide/en/logstash/7.17/" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/</a><br>简介：Logstash是一个具有实时流水线功能的开源数据收集引擎。Logstash可以动态地统一来自不同来源的数据，并将数据规范化为您选择的目的地。为各种高级下游分析和可视化用例清理和民主化您的所有数据。<br>虽然Logstash最初推动了日志收集的创新，但其功能远远超出了该用例。任何类型的事件都可以通过广泛的输入、过滤和输出插件进行丰富和转换。</p><h3 id="1、Logstash安装"><a href="#1、Logstash安装" class="headerlink" title="1、Logstash安装"></a>1、Logstash安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># yum install -y logstash-7.17.11-x86_64.rpm </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明软连接</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># ln -s /usr/share/logstash/bin/logstash   /sbin/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Logstash 测试文件目录</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># mkdir logstash-config</span></span><br></pre></td></tr></table></figure><h4 id="2、Logstash-标准输入输出"><a href="#2、Logstash-标准输入输出" class="headerlink" title="2、Logstash 标准输入输出"></a>2、Logstash 标准输入输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写Logstash配置文件</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># cd logstash-config/</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># vim 01_test.conf</span></span><br><span class="line">input &#123;</span><br><span class="line">  stdin &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置文件语法</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># logstash  -tf ~/logstash-config/01_test.conf</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302310091.png#id=WRB0E&originHeight=392&originWidth=2283&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Logstash</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># logstash  -f ~/logstash-config/01_test.conf</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302312127.png#id=qkBSN&originHeight=266&originWidth=1027&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h4 id="3、Logstash基于File的形式进行input"><a href="#3、Logstash基于File的形式进行input" class="headerlink" title="3、Logstash基于File的形式进行input"></a>3、Logstash基于File的形式进行input</h4><p>官网：<a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-inputs-file.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-inputs-file.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写配置文件</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># vim 02-file-input.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">  <span class="comment"># 指定日志文件收集的路径</span></span><br><span class="line">  path =&gt; [<span class="string">"/tmp/*.txt"</span>]</span><br><span class="line">  <span class="comment"># 从日志文件的第一行进行读取，只会在第一次启动时从头读取</span></span><br><span class="line">  start_position =&gt; <span class="string">"beginning"</span> </span><br><span class="line">  <span class="comment"># 从日志文件的尾行读取日志，且偏移指针文件对原日志文件偏移量未记录</span></span><br><span class="line">  <span class="comment"># start_position =&gt; "end" </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备测试日志文件</span></span><br><span class="line">[root@elk01 stduy-logstash-config]<span class="comment"># ech0 1111 &gt; /tmp/1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk01 stduy-logstash-config]<span class="comment"># logstash -f /root/stduy-logstash-config/02_input_file.conf</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405302324437.png#id=PA09v&originHeight=887&originWidth=2284&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看偏移量</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># cat /usr/share/logstash/data/plugins/inputs/file/.sincedb_820ddbbd098cfece4b56f4fcbf67a9bb</span></span><br><span class="line">16789540 0 64768 4 1717082577.147625 /tmp/1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志文件</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># ll -i /tmp/1.txt </span></span><br><span class="line">16789540 -rw-r--r-- 1 root root 4 5月  30 23:20 /tmp/1.txt</span><br></pre></td></tr></table></figure><h4 id="4、Logstash基于Filebeat形式进行input"><a href="#4、Logstash基于Filebeat形式进行input" class="headerlink" title="4、Logstash基于Filebeat形式进行input"></a>4、Logstash基于Filebeat形式进行input</h4><p>Filebeat output Logstash官网：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/logstash-output.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/logstash-output.html</a><br>Logstash input Fliebeat官网：<a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-inputs-beats.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-inputs-beats.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改Filebeat配置文件</span></span><br><span class="line">[root@elk01 filebeat-config]<span class="comment"># vim /root/filebeat-config/output-logstash.yml </span></span><br><span class="line"></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /tmp/test.log</span><br><span class="line">  tags: [<span class="string">"test"</span>]</span><br><span class="line">  fields:</span><br><span class="line">    log_type: <span class="built_in">test</span></span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  <span class="comment"># Logstash主机地址</span></span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">#启动Filebeat实例</span></span><br><span class="line">[root@elk01 <span class="built_in">test</span>]<span class="comment"># filebeat -e -c /root/filebeat-conifg/output-logstash.yml</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改Logstash配置文件</span></span><br><span class="line">[root@elk01 stduy-logstash-config]<span class="comment"># vim input-beats.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    <span class="comment"># 通讯端口号，默认5044</span></span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash</span></span><br><span class="line">[root@elk01 logstash-config]<span class="comment"># logstash -rf /root/logstash-config/input-beats.conf</span></span><br></pre></td></tr></table></figure><h4 id="5、Logstash基于ES形式进行output"><a href="#5、Logstash基于ES形式进行output" class="headerlink" title="5、Logstash基于ES形式进行output"></a>5、Logstash基于ES形式进行output</h4><p>官网：<a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-outputs-elasticsearch.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-outputs-elasticsearch.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改Logstash配置文件</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># cat 08_output_es.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    <span class="comment"># 通讯端口号，默认5044</span></span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="comment"># ES集群IP</span></span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>] </span><br><span class="line">    <span class="comment"># 索引模式名称</span></span><br><span class="line">    index =&gt; <span class="string">"test-log-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash</span></span><br><span class="line">[root@elk03 logstash-config]<span class="comment"># logstash -f /root/stduy-logstash-config/08_output_es.conf</span></span><br></pre></td></tr></table></figure><h4 id="6、Logstash-grok插件使用"><a href="#6、Logstash-grok插件使用" class="headerlink" title="6、Logstash grok插件使用"></a>6、Logstash grok插件使用</h4><p>官网： <a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-grok.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-grok.html</a><br>简介：解析任意文本并对其进行结构化。Grok 是将非结构化日志数据解析为结构化和可查询内容的好方法。该工具非常适合系统日志，apache和其他Web服务器日志，mysql 日志，以及通常为人类编写的任何日志格式。</p><h5 id="6-1-Logstash-内置正则使用"><a href="#6-1-Logstash-内置正则使用" class="headerlink" title="6.1 Logstash 内置正则使用"></a>6.1 Logstash 内置正则使用</h5><p>简介：将非结构化的日志格式通过Grok内置的正则转化为结构化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志格式</span></span><br><span class="line">192.168.174.1 - - [01/Jun/2024:10:37:16 +0800] <span class="string">"GET / HTTP/1.1"</span> 304 0 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0"</span> <span class="string">"-"</span></span><br><span class="line">192.168.174.1 - - [01/Jun/2024:10:37:16 +0800] <span class="string">"GET / HTTP/1.1"</span> 304 0 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0"</span> <span class="string">"-"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写Filebeat配置文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-out-logstash.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"access"</span>]</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"><span class="comment"># 启动Filebeat实例             </span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filebeat-out-logstash.yml </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写Logstash配置文件</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim filter_grok.yml </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"%&#123;HTTPD_COMMONLOG&#125;"</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>] </span><br><span class="line">    index =&gt; <span class="string">"test-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash  -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406011048944.png#id=sObcG&originHeight=510&originWidth=2279&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="6-2-Logstash基于内置正则实现日志结构化"><a href="#6-2-Logstash基于内置正则实现日志结构化" class="headerlink" title="6.2 Logstash基于内置正则实现日志结构化"></a>6.2 Logstash基于内置正则实现日志结构化</h5><p>官网： <a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-grok.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-grok.html</a><br>Logstash内置变量：<a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/legacy/httpd" target="_blank" rel="noopener">https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/legacy/httpd</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试日志准备</span></span><br><span class="line">55.3.244.1 GET /index.html 15824 0.043</span><br><span class="line">    <span class="comment"># 参数说明</span></span><br><span class="line">        55.3.244.1 <span class="comment"># 客户端IP</span></span><br><span class="line">        GET   <span class="comment"># 请求方式</span></span><br><span class="line">        /index.html<span class="comment"># 请求路径</span></span><br><span class="line">        15824<span class="comment"># 发送字节大小</span></span><br><span class="line">        0.043<span class="comment"># 相应时常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logstash 配置文件编写</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim stdin_grok_stdout.conf</span></span><br><span class="line">input &#123;</span><br><span class="line">  stdin &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"%&#123;IP:client_ip&#125; %&#123;WORD:Request_method&#125; %&#123;URIPATHPARAM:request_uri&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:response_time&#125;"</span> &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash  -rf ~/stdin_grok_stdout.conf</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406011104673.png#id=pHhH3&originHeight=511&originWidth=1485&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><blockquote><p>提示：<br>    %{IP:client} 变量解释： IP为内置变量，client为字段名称或者叫标识符。可以自行修改,例如：%{IP:req-client}</p></blockquote><h5 id="6-4-Logstash删除指定字段"><a href="#6-4-Logstash删除指定字段" class="headerlink" title="6.4 Logstash删除指定字段"></a>6.4 Logstash删除指定字段</h5><p>简介：如果此筛选器成功，请从此事件中删除任意字段。</p><p><code>未删除字段终端打印如下</code>：<br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406011154600.png#id=TRqxM&originHeight=1276&originWidth=2285&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filebeat配置文件编写</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-out-logstash.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"access"</span>]</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filebeat-out-logstash.yml </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logstash配置文件编写</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim filter_grok.yml </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"%&#123;HTTPD_COMMONLOG&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment"># You can also remove multiple fields at once: </span></span><br><span class="line">   remove_field =&gt; [ <span class="string">"type"</span>,<span class="string">"offset"</span>,<span class="string">"ecs"</span>,<span class="string">"input"</span>,<span class="string">"@version"</span>,<span class="string">"log"</span>,<span class="string">"agent"</span>,<span class="string">"tags"</span> ]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"test-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><p>删除指定字段后终端数据显示如下：<br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406011210897.png#id=A8WhB&originHeight=751&originWidth=2283&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="6-5-Logstash-添加指定字段"><a href="#6-5-Logstash-添加指定字段" class="headerlink" title="6.5 Logstash 添加指定字段"></a>6.5 Logstash 添加指定字段</h5><p>简介：如果此筛选成功，则向此事件添加任意字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filebeat配置文件编写</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-out-logstash.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"access"</span>]</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filebeat-out-logstash.yml </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logstash配置文件编写</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim filter_grok.yml </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"%&#123;HTTPD_COMMONLOG&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment"># You can also remove multiple fields at once: </span></span><br><span class="line">   remove_field =&gt; [ <span class="string">"type"</span>,<span class="string">"offset"</span>,<span class="string">"ecs"</span>,<span class="string">"input"</span>,<span class="string">"@version"</span>,<span class="string">"log"</span>,<span class="string">"agent"</span>,<span class="string">"tags"</span> ]</span><br><span class="line">    <span class="comment"># You can also add multiple fields at once:</span></span><br><span class="line">   add_field =&gt; &#123; </span><br><span class="line">     <span class="string">"host-name"</span> =&gt; <span class="string">"%&#123;host&#125;"</span></span><br><span class="line">     <span class="string">"service"</span> =&gt; <span class="string">"ELK stack"</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"test-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406011249952.png#id=UaKvc&originHeight=812&originWidth=2289&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="6-6-Logstash-自定义Tags"><a href="#6-6-Logstash-自定义Tags" class="headerlink" title="6.6 Logstash 自定义Tags"></a>6.6 Logstash 自定义Tags</h5><p>简介：如果此筛选成功，请向事件添加任意标记。 标记可以是动态的，并使用语法包含事件的某些部分。<code>%{field}</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filebeat配置文件编写</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-out-logstash.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"access"</span>]</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filebeat-out-logstash.yml </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logstash配置文件编写</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim filter_grok.yml </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"%&#123;HTTPD_COMMONLOG&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment"># You can also remove multiple fields at once: </span></span><br><span class="line">   remove_field =&gt; [ <span class="string">"type"</span>,<span class="string">"offset"</span>,<span class="string">"ecs"</span>,<span class="string">"input"</span>,<span class="string">"@version"</span>,<span class="string">"log"</span>,<span class="string">"agent"</span>,<span class="string">"tags"</span> ]</span><br><span class="line">    <span class="comment"># You can also add multiple fields at once:</span></span><br><span class="line">   add_field =&gt; &#123; </span><br><span class="line">     <span class="string">"host-name"</span> =&gt; <span class="string">"%&#123;host&#125;"</span></span><br><span class="line">     <span class="string">"service"</span> =&gt; <span class="string">"ELK stack"</span></span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment"># You can also add multiple tags at once:</span></span><br><span class="line">   add_tag =&gt; [ <span class="string">"Filebeat"</span>, <span class="string">"Logstash"</span>,<span class="string">"Nginx"</span>,<span class="string">"Tomcat"</span>,<span class="string">"Kibana"</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"test-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406011255129.png#id=mVQ7M&originHeight=1125&originWidth=2286&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h4 id="7、Logstash-geoip插件分析用户IP所属地"><a href="#7、Logstash-geoip插件分析用户IP所属地" class="headerlink" title="7、Logstash geoip插件分析用户IP所属地"></a>7、Logstash geoip插件分析用户IP所属地</h4><p>官方：<a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-geoip.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-geoip.html</a><br>简介：GeoIP 过滤器添加有关 IP 地址地理位置的信息， 基于 MaxMind GeoLite2 数据库的数据。 MaxMind GeoLite2 数据库：开源IP地址定位数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filebeat配置文件编写</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-out-logstash.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"access"</span>]</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filebeat-out-logstash.yml </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logstash配置文件编写</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim filter_grok.yml </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"%&#123;HTTPD_COMMONLOG&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment"># You can also remove multiple fields at once: </span></span><br><span class="line">   remove_field =&gt; [ <span class="string">"type"</span>,<span class="string">"offset"</span>,<span class="string">"ecs"</span>,<span class="string">"input"</span>,<span class="string">"@version"</span>,<span class="string">"log"</span>,<span class="string">"agent"</span>,<span class="string">"tags"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 指定geoip插件</span></span><br><span class="line">  geoip &#123;</span><br><span class="line">      <span class="comment"># 配置客户端IP字段名称</span></span><br><span class="line">      <span class="built_in">source</span> =&gt; <span class="string">"clientip"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"test-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><h4 id="8、Logstash-useragent插件分析用户客户端类型"><a href="#8、Logstash-useragent插件分析用户客户端类型" class="headerlink" title="8、Logstash useragent插件分析用户客户端类型"></a>8、Logstash useragent插件分析用户客户端类型</h4><p>​    官网：<a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-useragent.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-filters-useragent.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filebeat配置文件编写</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim filebeat-out-logstash.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  tags: [<span class="string">"access"</span>]</span><br><span class="line">  json.keys_under_root: <span class="literal">true</span>  </span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filebeat-out-logstash.yml </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logstash配置文件编写</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim filter_grok.yml </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123; </span><br><span class="line">   remove_field =&gt; [ <span class="string">"type"</span>,<span class="string">"offset"</span>,<span class="string">"ecs"</span>,<span class="string">"input"</span>,<span class="string">"@version"</span>,<span class="string">"log"</span>,<span class="string">"agent"</span>,<span class="string">"tags"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 指定geoip插件</span></span><br><span class="line">  geoip &#123;</span><br><span class="line">      <span class="comment"># 配置客户端IP字段名称</span></span><br><span class="line">      <span class="built_in">source</span> =&gt; <span class="string">"clientip"</span></span><br><span class="line">  &#125;</span><br><span class="line">  useragent &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">"http_user_agent"</span></span><br><span class="line">    target =&gt; <span class="string">"test_user_agent"</span></span><br><span class="line">    remove_field =&gt; [ <span class="string">"agent"</span>,<span class="string">"@version"</span>,<span class="string">"tags"</span>,<span class="string">"ecs"</span>,<span class="string">"log"</span>,<span class="string">"offset"</span>,<span class="string">"type"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"test-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><h4 id="9、Logstash-Filter多if分支"><a href="#9、Logstash-Filter多if分支" class="headerlink" title="9、Logstash Filter多if分支"></a>9、Logstash Filter多if分支</h4><p>官网：<a href="https://www.elastic.co/guide/en/logstash/7.17/event-dependent-configuration.html#metadata" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/event-dependent-configuration.html#metadata</a><br>简介： 针对不同的日志类型。filter去做不同的处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filebeat配置文件</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># vim  filebeat-out-logstash.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_access</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  json.keys_under_root: <span class="literal">true</span>   </span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/error.log</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_error</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/messages</span><br><span class="line">  fields:</span><br><span class="line">    log_type: system_log</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.174.142:5044"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除偏移量</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># rm -rf /var/lib/filebeat/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Filebeat实例</span></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filebeat-out-logstash.yml </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logstash 配置文件准备</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># vim filter_grok.yml </span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      <span class="string">"name"</span> =&gt; <span class="string">"ELK stack"</span> </span><br><span class="line">    &#125;</span><br><span class="line">    remove_field =&gt; [<span class="string">"agent"</span>,<span class="string">"ephemeral_id"</span>,<span class="string">"ecs"</span>,<span class="string">"@version"</span>,<span class="string">"tags"</span>,<span class="string">"input"</span>,<span class="string">"log"</span>,<span class="string">"offest"</span>]  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [log_type] == <span class="string">"nginx_access"</span> &#123;</span><br><span class="line">     geoip &#123;</span><br><span class="line">       <span class="built_in">source</span> =&gt; <span class="string">"clientip"</span></span><br><span class="line">     &#125;</span><br><span class="line">     useragent &#123;</span><br><span class="line">       <span class="built_in">source</span> =&gt; <span class="string">"http_user_agent"</span> </span><br><span class="line">       target =&gt; <span class="string">"study_user_agent"</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [log_type] == <span class="string">"nginx_access"</span> &#123;  </span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>] </span><br><span class="line">      index =&gt; <span class="string">"web-access-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> [log_type] == <span class="string">"nginx_error"</span> &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">          hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>]</span><br><span class="line">          index =&gt; <span class="string">"web-error-%&#123;+yyyy.MM.dd&#125;"</span>   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  <span class="keyword">else</span> <span class="keyword">if</span> [log_type] == <span class="string">"system_log"</span> &#123;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">         hosts =&gt; [<span class="string">"192.168.174.140:9200"</span>,<span class="string">"192.168.174.141:9200"</span>,<span class="string">"192.168.174.142:9200"</span>]</span><br><span class="line">         index =&gt; <span class="string">"system-log-%&#123;+yyyy.MM.dd&#125;"</span>     </span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash  -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><h2 id="八、Kibana操作使用"><a href="#八、Kibana操作使用" class="headerlink" title="八、Kibana操作使用"></a>八、Kibana操作使用</h2><h3 id="1、kibana手动创建索引模板"><a href="#1、kibana手动创建索引模板" class="headerlink" title="1、kibana手动创建索引模板"></a>1、kibana手动创建索引模板</h3><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405310044720.png#id=TjLJ0&originHeight=1260&originWidth=2507&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405310044170.png#id=Ty1KL&originHeight=1037&originWidth=2100&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405310045784.png#id=PjKWz&originHeight=1244&originWidth=1917&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405310047016.png#id=a7ORh&originHeight=1252&originWidth=2011&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"number_of_replicas"</span>:1,</span><br><span class="line"><span class="string">"number_of_shards"</span>:3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405310049148.png#id=CosFV&originHeight=1000&originWidth=2096&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h2 id="九、kafka简介和使用"><a href="#九、kafka简介和使用" class="headerlink" title="九、kafka简介和使用"></a>九、kafka简介和使用</h2><h3 id="1、MQ两种模式"><a href="#1、MQ两种模式" class="headerlink" title="1、MQ两种模式"></a>1、MQ两种模式</h3><h4 id="1-1-P2P模式"><a href="#1-1-P2P模式" class="headerlink" title="1.1 P2P模式"></a>1.1 P2P模式</h4><h5 id="1-1-1-架构图"><a href="#1-1-1-架构图" class="headerlink" title="1.1.1 架构图"></a>1.1.1 架构图</h5><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406020000698.png" alt></p><h5 id="1-1-2-简介"><a href="#1-1-2-简介" class="headerlink" title="1.1.2 简介"></a>1.1.2 简介</h5><p>​    在消息队列（MQ）系统中，==点对点模式==（Point-to-Point Model）是最基本的消息通信模式之一。在这种模式下，消息生产者发送消息到一个队列（Queue），而消息消费者从这个队列中接收和处理消息。每条消息只能被一个消费者消费一次，这与发布/订阅模式（Pub/Sub Model）中的多播机制不同。</p><h5 id="1-1-3-工作流程"><a href="#1-1-3-工作流程" class="headerlink" title="1.1.3 工作流程"></a>1.1.3 工作流程</h5><ol><li><strong>生产者发送消息</strong>：生产者创建一条消息，并将其发送到指定的<strong>队列</strong>（Queue）。</li><li><strong>队列暂存消息</strong>：队列接收到消息并<strong>存储</strong>，等待消费者来接收。</li><li><strong>消费者接收消息</strong>：消费者从<strong>队列</strong>中<strong>检索</strong>消息进行处理。如果有多个消费者，每条消息只会被其中一个消费者接收。</li><li><strong>消息确认</strong>：消费者处理完消息后，向队列发送确认，表示消息已经成功处理。MQ<strong>删除消费数据</strong>。<strong>如果消费者没有确认消息，消息可能会被重新投递到队列中供其他消费者处理。</strong></li></ol><h4 id="1-2-发布-订阅模式"><a href="#1-2-发布-订阅模式" class="headerlink" title="1.2 发布/订阅模式"></a>1.2 发布/订阅模式</h4><h5 id="1-2-1-架构图"><a href="#1-2-1-架构图" class="headerlink" title="1.2.1 架构图"></a>1.2.1 架构图</h5><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406020008444.png#id=wvuow&originHeight=609&originWidth=1648&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><h5 id="1-2-2-简介"><a href="#1-2-2-简介" class="headerlink" title="1.2.2 简介"></a>1.2.2 简介</h5><p>​    在消息队列（MQ）系统中，发布-订阅模式（Publish-Subscribe Model，简称Pub/Sub）是一种常见的消息通信模式。在这种模式下，消息生产者（发布者）将消息发布到一个主题（Topic），而消息消费者（订阅者）则订阅该主题，从而接收发布者发布的消息。与点对点模式不同，发布到主题的<strong>每条消息可以被多个订阅者接收和处理</strong>。</p><h5 id="1-2-3-工作流程"><a href="#1-2-3-工作流程" class="headerlink" title="1.2.3 工作流程"></a>1.2.3 工作流程</h5><ol><li><strong>发布者发布消息</strong>：发布者创建一条消息，并将其发布到指定的主题。</li><li><strong>主题广播消息</strong>：主题接收到消息，并将其广播给所有订阅了该主题的订阅者。</li><li><strong>订阅者接收消息</strong>：订阅者接收或者拉取主题广播的消息并进行处理。</li></ol><ul><li><strong>Pull方式</strong><ul><li><strong>优点</strong>：消费者根据自身消费数据的能力去队列中拉取数据。</li><li><strong>缺点</strong>：消费者需要长期打开一个进程来监视队列是否有数据产生。</li></ul></li><li><strong>Push方式</strong><ul><li><strong>优点</strong>：消息队列主动推送数据，例如：<strong>公众号话题推送，APP更新推送</strong>。</li><li><strong>缺点</strong>：消息队列自身需要维护一张订阅者名单。<strong>当订阅者过多时，特别消耗资源。</strong></li></ul></li></ul><h3 id="2、kafka相关概念"><a href="#2、kafka相关概念" class="headerlink" title="2、kafka相关概念"></a>2、kafka相关概念</h3><p>​    <strong>官网</strong>：<a href="https://kafka.apache.org/" target="_blank" rel="noopener">https://kafka.apache.org/</a></p><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><p>​    ==Apache Kafka==是一个开源的<strong>分布式</strong>事件流平台，由数以千计的公司提供高性能数据管道、流分析、 数据集成和任务关键型应用程序。</p><ul><li><p><strong>高吞吐量</strong>：使用延迟低至2ms的机器集群以网络有限的吞吐量传递消息。</p></li><li><p><strong>可伸缩</strong>：将生产集群扩展到1000个代理、每天数万亿条消息、PB的数据和数十万个分区。弹性扩展和收缩存储和处理。</p></li><li><p><strong>永久存储器</strong>：将数据流安全地存储在分布式、持久、容错的集群中。</p></li><li><p><strong>高可用性</strong>：在可用性区域上高效地扩展集群，或者跨地理区域连接单独的集群。</p><h4 id="2-2-Kafka相关专业术语"><a href="#2-2-Kafka相关专业术语" class="headerlink" title="2.2 Kafka相关专业术语"></a>2.2 Kafka相关专业术语</h4></li><li><p><strong>主题（Topic）</strong>：主题是Kafka中用于对消息进行分类的逻辑分组，每个主题可以看作是消息的分类器。主题是多订阅者模式，即一个主题可以有多个消费者订阅。</p></li><li><p><strong>分区（Partition）</strong>：每个主题被分成一个或多个分区。分区是消息存储的基本单元。分区内的消息是有序的，但不同分区之间无序。每个分区可以分布在不同的Kafka服务器上，从而实现水平扩展。</p><ul><li><strong>leader partition</strong> 负责对kafka集群的读写操作，和客户端进行交互</li><li><strong>follower partition</strong> 负责去leader partition 同步数据，不可以和客户端进行交互</li></ul></li><li><p><strong>偏移量（Offset）</strong>：偏移量是分区中每条消息的唯一标识符。它是一个递增的整数，记录了消息在分区中的位置。消费者使用偏移量来跟踪读取消息的位置。</p></li><li><p><strong>生产者（Producer）</strong>：生产者是负责向Kafka主题发布消息的客户端应用程序。生产者将消息发送到指定的主题和分区。</p></li><li><p><strong>消费者（Consumer）</strong>：消费者是负责从Kafka主题读取消息的客户端应用程序。消费者通过订阅一个或多个主题来读取消息，并使用偏移量来跟踪读取进度。</p></li><li><p><strong>消费者组（Consumer Group）</strong>：消费者组是一组消费者实例，共同消费一个或多个主题的消息。</p></li><li><p><strong>代理（Broker）</strong>：代理是Kafka集群中的一个服务器节点，负责存储和传输消息数据。一个Kafka集群由多个代理组成，每个代理可以处理多个分区。</p></li><li><p><strong>复制（Replication）</strong>：Kafka中的复制机制将分区数据复制到多个代理上，以确保数据的高可用性和容错性。每个分区有一个领导副本（Leader）和若干个跟随副本（Follower）。所有的读写操作都由领导副本处理，跟随副本只需同步领导副本的数据。但是Leader和Follwer都属于副本。创建时不能副本数不能为0。</p></li></ul><h3 id="3、Zookeeper使用和配置"><a href="#3、Zookeeper使用和配置" class="headerlink" title="3、Zookeeper使用和配置"></a>3、Zookeeper使用和配置</h3><p>官网链接：<a href="https://dlcdn.apache.org/zookeeper/" target="_blank" rel="noopener">https://dlcdn.apache.org/zookeeper/</a></p><p>下载链接：<a href="https://dlcdn.apache.org/zookeeper/zookeeper-3.8.4/apache-zookeeper-3.8.4-bin.tar.gz" target="_blank" rel="noopener">https://dlcdn.apache.org/zookeeper/zookeeper-3.8.4/apache-zookeeper-3.8.4-bin.tar.gz</a></p><h4 id="3-1-简介："><a href="#3-1-简介：" class="headerlink" title="3.1 简介："></a>3.1 简介：</h4><p>​    Zookeeper 是 Apache 旗下的一个开源<strong>分布式协调服务</strong>，用于管理和协调分布式应用程序中的各种服务和组件。它提供了一系列高效且可靠的分布式数据一致性和协调机制。</p><h4 id="3-2-zookeeper集群部署：三节点😀"><a href="#3-2-zookeeper集群部署：三节点😀" class="headerlink" title="3.2 zookeeper集群部署：三节点😀"></a>3.2 zookeeper集群部署：<code>三节点</code>😀</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 解压安装包到指定目录</span></span><br><span class="line">$ tar xf apache-zookeeper-3.8.2-bin.tar.gz  -C /opt/ &amp;&amp; <span class="built_in">cd</span> /opt/</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 更改目录名称</span></span><br><span class="line">$ mv apache-zookeeper-3.8.2-bin/   zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 配置zk环境变量</span></span><br><span class="line">$ cat &gt;&gt; /etc/profile.d/zookeeper.sh &lt;&lt;-EOF</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> ZK_HOME=/opt/zookeeper</span><br><span class="line"><span class="built_in">export</span> PATH=\<span class="variable">$PATH</span>:\<span class="variable">$ZK_HOME</span>/bin</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载环境变量 </span></span><br><span class="line">$ <span class="built_in">source</span> /etc/profile.d/zookeeper.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建zk数据存放目录</span></span><br><span class="line">$ mkdir -p /opt/data/zk</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改zk的配置文件(三节点)</span></span><br><span class="line">$ cp /opt/zookeeper/conf/zoo_sample.cfg  /opt/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">$ egrep -v <span class="string">"^(#|$)"</span> /opt/zookeeper/conf/zoo.cfg </span><br><span class="line"><span class="comment"># Zookeeper的心跳间隔时间。服务器和客户端会通过心跳包维持连接状态。</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># 从节点最多可以等待10 个tickTime（即 10 * 2000 毫秒 = 20 秒）来与领导者同步数据状态。否则它将被认为是不可用的。</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># 定义Zookeeper领导者和从节点之间的心跳和同步请求的最大允许延迟时间。领导者与从节点之间的响应时间如果超过了这个限制，从节点将被认为失去同步状态。（即 5 * 2000 毫秒 = 10 秒）。</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># 定义zk数据目录</span></span><br><span class="line">dataDir=/opt/data/zk</span><br><span class="line"><span class="comment"># 定义Zookeeper集群的客户端连接端口</span></span><br><span class="line">clientPort=2181</span><br><span class="line">server.140=192.168.174.140:2888:3888</span><br><span class="line">server.141=192.168.174.141:2888:3888</span><br><span class="line">server.142=192.168.174.142:2888:3888</span><br><span class="line">    <span class="comment"># 参数解释：</span></span><br><span class="line">            <span class="comment"># dataDirzk数据目录</span></span><br><span class="line">            <span class="comment"># clientPort端口号</span></span><br><span class="line">            <span class="comment"># server.140zk节点唯一标识</span></span><br><span class="line">            <span class="comment"># 192.168.100.160zk节点主机地址</span></span><br><span class="line">            <span class="comment"># 2888集群内部通讯端口</span></span><br><span class="line">            <span class="comment"># 3888leader选举端口</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 创建ID文件(位置存放在zk的数据存放路径下)</span></span><br><span class="line">        101节点</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"140"</span> &gt; /opt/data/zk/myid</span><br><span class="line">        102节点</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"141"</span> &gt; /opt/data/zk/myid</span><br><span class="line">        103节点</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"142"</span> &gt; /opt/data/zk/myid</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 所有节点启动zk</span></span><br><span class="line">$ zkServer.sh start</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看zk状态</span></span><br><span class="line">$ zkServer.sh status</span><br></pre></td></tr></table></figure><p><strong>myid文件</strong>：在Zookeeper集群中，<strong>myid</strong>文件是每个Zookeeper服务器节点的重要配置文件之一，用于唯一标识集群中的每个服务器。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406020109804.png" alt></p><h4 id="3-3-Zookeeper角色划分"><a href="#3-3-Zookeeper角色划分" class="headerlink" title="3.3 Zookeeper角色划分"></a>3.3 Zookeeper角色划分</h4><p>在Zookeeper集群中，不同的服务器节点可以承担不同的角色，以确保集群的高可用性、数据一致性和故障恢复能力。主要角色包括：==<strong>server.140=192.168.174.140:2888:3888:角色</strong>==</p><ol><li><p><strong>领导者（Leader）</strong></p><ul><li><p>处理所有写操作（如创建、更新、删除节点）并确保数据的一致性。</p></li><li><p>管理并协调集群中其他节点的活动。</p></li><li><p>负责为客户端请求生成唯一的事务ID（zxid）。</p></li><li><p>在集群启动或领导者失效时，会进行领导者选举，选出新的领导者。</p></li><li><p>定期发送心跳给跟随者，确保自己处于活动状态。</p></li></ul></li><li><p><strong>跟随者（Follower）</strong></p><ul><li>处理所有读取操作（如读取节点数据）。</li><li>接收并转发客户端的写请求给领导者进行处理。</li><li>将领导者的事务日志同步到本地，确保数据一致性。</li><li>参与领导者选举。</li><li>与领导者保持同步，接收并应用领导者的事务。</li></ul></li><li><p><strong>观察者（Observer）</strong></p><ul><li>处理读取操作，减轻领导者和跟随者的负担。</li><li>不参与领导者选举和事务投票，只同步领导者的事务日志。</li><li>提高集群的读取扩展能力，适合需要高读取吞吐量的场景。</li></ul></li><li><p><strong>客户端（Client）</strong></p><ul><li>连接到集群中的任一节点进行读取或写入操作。</li><li>自动处理节点故障并重新连接到其他可用节点。</li><li>通过客户端API与Zookeeper集群进行交互。<h4 id="3-4-zookeeper配置内存堆栈"><a href="#3-4-zookeeper配置内存堆栈" class="headerlink" title="3.4 zookeeper配置内存堆栈"></a>3.4 zookeeper配置内存堆栈</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 查看zk进程</span></span><br><span class="line">$ jps</span><br><span class="line">1367 Elasticsearch</span><br><span class="line">5400 QuorumPeerMain</span><br><span class="line">5593 Jps</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看zk的堆栈大小</span></span><br><span class="line">$ jmap -heap 5400</span><br></pre></td></tr></table></figure><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406020135738.png" alt></li></ul></li></ol><p><strong>zookeeper默认堆内存大小为1GB，一般设置为2GB或者4GB</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 调节zookeeper推内存大小为256MB</span></span><br><span class="line">$ vim /opt/zookeeper/conf/java.env</span><br><span class="line"><span class="meta">#! /bin/bash </span></span><br><span class="line"> <span class="comment"># 指定JDK安装路径 </span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java </span><br><span class="line"> <span class="comment"># 指定zookeeper的堆内存大小 </span></span><br><span class="line"><span class="built_in">export</span> JVMFLAGS=<span class="string">"-Xms256m -Xmx256m <span class="variable">$JVMFLAGS</span>"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 同步文件</span></span><br><span class="line">$ scp /opt/zookeeper/conf/java.env  elk02:/opt/zookeeper/conf/</span><br><span class="line">$ scp /opt/zookeeper/conf/java.env  elk03:/opt/zookeeper/conf/</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 所有节点重启zk</span></span><br><span class="line">$ zkServer.sh restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 验证堆内存</span></span><br><span class="line">$ jmap -heap `jps | grep QuorumPeerMain | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br></pre></td></tr></table></figure><h3 id="4、kafka集群安装：三节点😀"><a href="#4、kafka集群安装：三节点😀" class="headerlink" title="4、kafka集群安装：三节点😀"></a>4、kafka集群安装：<code>三节点</code>😀</h3><p>​    下载链接：<a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">https://kafka.apache.org/downloads</a><br>​    官网：<a href="https://kafka.apache.org/" target="_blank" rel="noopener">https://kafka.apache.org/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 解压安装包到指定目录</span></span><br><span class="line">$ tar xf kafka_2.13-3.2.1.tgz  -C /opt/ &amp;&amp;  <span class="built_in">cd</span> /opt/</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改目录名称</span></span><br><span class="line">$ mv kafka_2.13-3.2.1/  kafka</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 配置kafka环境变量</span></span><br><span class="line">$ cat &gt;&gt; /etc/profile.d/kafka.sh &lt;&lt;-EOF</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_HOME=/opt/kafka</span><br><span class="line"><span class="built_in">export</span> PATH=\<span class="variable">$PATH</span>:\<span class="variable">$KAFKA_HOME</span>/bin</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载环境变量</span></span><br><span class="line">$ <span class="built_in">source</span> /etc/profile.d/kafka.sh </span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建数据目录</span></span><br><span class="line">$ mkdir /opt/data/kafka -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改kafka配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.kafka101节点配置文件</span></span><br><span class="line">$ egrep -v <span class="string">"^(#|$)"</span> kafka/config/server.properties</span><br><span class="line">broker.id=140</span><br><span class="line">log.dirs=/opt/data/kafka/</span><br><span class="line">zookeeper.connect=192.168.174.140:2181,192.168.174.141:2181,192.168.174.142:2181/kafka</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.kafka102节点配置文件</span></span><br><span class="line">$ egrep -v <span class="string">"^(#|$)"</span> kafka/config/server.properties  </span><br><span class="line">broker.id=141</span><br><span class="line">log.dirs=/opt/data/kafka/</span><br><span class="line">zookeeper.connect=192.168.174.140:2181,192.168.174.141:2181,192.168.174.142:2181/kafka<span class="comment"># /kafka为zk中的znode</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 3.kafka103节点配置文件</span></span><br><span class="line">$ egrep -v <span class="string">"^(#|$)"</span> kafka/config/server.properties  </span><br><span class="line">broker.id=142</span><br><span class="line">log.dirs=/opt/data/kafka/</span><br><span class="line">zookeeper.connect=192.168.174.140:2181,192.168.174.141:2181,192.168.174.142:2181/kafka</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 所有节点启动kafka</span></span><br><span class="line">$ kafka-server-start.sh -daemon /opt/kafka/config/server.properties </span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; zk节点查看kafka注册信息</span></span><br><span class="line">$ zkCli.sh ls /kafka/brokers/ids | grep  <span class="string">"^\["</span></span><br><span class="line">[140, 141, 142]</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; kafka停止脚本</span></span><br><span class="line">$ kafka-server-stop.sh</span><br></pre></td></tr></table></figure><h3 id="5、Kafka-Topic日常操作"><a href="#5、Kafka-Topic日常操作" class="headerlink" title="5、Kafka Topic日常操作"></a>5、Kafka Topic日常操作</h3><h4 id="5-1-查看Topic相关信息"><a href="#5-1-查看Topic相关信息" class="headerlink" title="5.1 查看Topic相关信息"></a>5.1 查看Topic相关信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 查看集群中所有Topic</span></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092,192.168.174.141:9092,192.168.174.142:9092  --list</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看所有Topic详细信息</span></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092,192.168.174.141:9092,192.168.174.142:9092  --describe</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看某个Topic信息</span></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092,192.168.174.141:9092,192.168.174.142:9092  --describe  --topic  Topice名称</span><br></pre></td></tr></table></figure><h4 id="5-2-创建Topic"><a href="#5-2-创建Topic" class="headerlink" title="5.2 创建Topic"></a>5.2 创建Topic</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建test-elk Topic</span></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092 --create --topic <span class="built_in">test</span>-elk</span><br><span class="line">Created topic <span class="built_in">test</span>-elk.</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建Topic，并指定副本数量</span></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092 --create --topic <span class="built_in">test</span>-elk-02  --partitions 10 --replication-factor 1</span><br><span class="line">Created topic <span class="built_in">test</span>-elk.</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看Topic的详细信息</span></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092  --describe --topic <span class="built_in">test</span>-elk-02</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406020407871.png#id=PAr2v&originHeight=504&originWidth=2263&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建Topic，并指定副本数量</span></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092 --create --topic <span class="built_in">test</span>-elk-03  --partitions 10 --replication-factor 2</span><br><span class="line"></span><br><span class="line">$ kafka-topics.sh   --bootstrap-server  192.168.174.140:9092  --describe --topic <span class="built_in">test</span>-elk-03</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202406020410226.png#id=xl6sS&originHeight=504&originWidth=2282&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none" alt="     "></p><p><strong>注意：副本数量不能大于Broker的数量</strong></p><h3 id="6、Filebeat收集日志至Kafka"><a href="#6、Filebeat收集日志至Kafka" class="headerlink" title="6、Filebeat收集日志至Kafka"></a>6、Filebeat收集日志至Kafka</h3><p>官网：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/kafka-output.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/7.17/kafka-output.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@elk01 ~]<span class="comment"># cat filbeat-out-kafka.yml </span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">  fields:</span><br><span class="line">    log_type: nginx_access</span><br><span class="line">  fields_under_root: <span class="literal">true</span></span><br><span class="line">  json.keys_under_root: <span class="literal">true</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">#- type: log</span></span><br><span class="line"><span class="comment">#  paths:</span></span><br><span class="line"><span class="comment">#    - /var/log/nginx/error.log</span></span><br><span class="line"><span class="comment">#  fields:</span></span><br><span class="line"><span class="comment">#    log_type: nginx_error</span></span><br><span class="line"><span class="comment">#  fields_under_root: true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  <span class="comment"># initial brokers for reading cluster metadata</span></span><br><span class="line">  hosts: [<span class="string">"192.168.174.140:9092"</span>, <span class="string">"192.168.174.141:9092"</span>, <span class="string">"192.168.174.142:9092"</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># message topic selection + partitioning</span></span><br><span class="line">  topic: <span class="string">"test-kafka-topic"</span></span><br><span class="line"></span><br><span class="line">[root@elk01 ~]<span class="comment"># filebeat  -e -c ~/filbeat-out-kafka.yml </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka测试拉取数据</span></span><br><span class="line">[root@elk03 opt]<span class="comment"># kafka-console-consumer.sh   --topic test-kafka-topic  --bootstrap-server 192.168.174.140:9092,192.168.174.141:9092,192.168.174.142:9092  --from-beginning</span></span><br></pre></td></tr></table></figure><h3 id="7、Logstash收集Kafka-Topic日志"><a href="#7、Logstash收集Kafka-Topic日志" class="headerlink" title="7、Logstash收集Kafka Topic日志"></a>7、Logstash收集Kafka Topic日志</h3><p>官网：<a href="https://www.elastic.co/guide/en/logstash/7.17/plugins-inputs-kafka.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/7.17/plugins-inputs-kafka.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    bootstrap_servers =&gt; <span class="string">"192.168.174.140:9092,192.168.174.141:9092,192.168.174.142:9092"</span>  <span class="comment"># Kafka集群IP</span></span><br><span class="line">    topics =&gt; [<span class="string">"test-kafka-topic"</span>]     <span class="comment"># 指定Topic进行消费数据</span></span><br><span class="line">    group_id =&gt; <span class="string">"test-kafka"</span>     <span class="comment"># 指定消费者组</span></span><br><span class="line">    codec =&gt; json &#123;                      <span class="comment"># 指定消费的数据是JSON格式。</span></span><br><span class="line">             charset =&gt; <span class="string">"UTF-8"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      <span class="string">"name"</span> =&gt; <span class="string">"ELK stack"</span> </span><br><span class="line">    &#125;</span><br><span class="line">    remove_field =&gt; [<span class="string">"agent"</span>,<span class="string">"ephemeral_id"</span>,<span class="string">"ecs"</span>,<span class="string">"@version"</span>,<span class="string">"tags"</span>,<span class="string">"input"</span>,<span class="string">"log"</span>,<span class="string">"offest"</span>]  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [log_type] == <span class="string">"nginx_access"</span> &#123;</span><br><span class="line">     geoip &#123;</span><br><span class="line">       <span class="built_in">source</span> =&gt; <span class="string">"clientip"</span></span><br><span class="line">     &#125;</span><br><span class="line">     useragent &#123;</span><br><span class="line">       <span class="built_in">source</span> =&gt; <span class="string">"http_user_agent"</span> </span><br><span class="line">       target =&gt; <span class="string">"study_user_agent"</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将下面解开注释即可将数据存入es集群中，分类添加索引到kibana界面上然后呈现数据</span></span><br><span class="line"><span class="comment">#  if [log_type] == "nginx_access" &#123;  </span></span><br><span class="line"><span class="comment">#    elasticsearch &#123;</span></span><br><span class="line"><span class="comment">#      hosts =&gt; ["192.168.174.140:9200","192.168.174.141:9200","192.168.174.142:9200"] </span></span><br><span class="line"><span class="comment">#      index =&gt; "web-access-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line"><span class="comment">#    &#125; </span></span><br><span class="line"><span class="comment">#  &#125; else if [log_type] == "nginx_error" &#123;</span></span><br><span class="line"><span class="comment">#        elasticsearch &#123;</span></span><br><span class="line"><span class="comment">#          hosts =&gt; ["192.168.174.140:9200","192.168.174.141:9200","192.168.174.142:9200"]</span></span><br><span class="line"><span class="comment">#          index =&gt; "web-error-%&#123;+yyyy.MM.dd&#125;"   </span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"><span class="comment">#  &#125;  else if [log_type] == "system_log" &#123;</span></span><br><span class="line"><span class="comment">#       elasticsearch &#123;</span></span><br><span class="line"><span class="comment">#         hosts =&gt; ["192.168.174.140:9200","192.168.174.141:9200","192.168.174.142:9200"]</span></span><br><span class="line"><span class="comment">#         index =&gt; "system-log-%&#123;+yyyy.MM.dd&#125;"     </span></span><br><span class="line"><span class="comment">#    &#125; </span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Logstash实例</span></span><br><span class="line">[root@elk03 ~]<span class="comment"># logstash  -rf ~/filter_grok.yml</span></span><br></pre></td></tr></table></figure><h2 id="十、Elasticsearch-Restful风格API实战"><a href="#十、Elasticsearch-Restful风格API实战" class="headerlink" title="十、Elasticsearch Restful风格API实战"></a>十、Elasticsearch Restful风格API实战</h2><h3 id="1、ES集群状态"><a href="#1、ES集群状态" class="headerlink" title="1、ES集群状态"></a>1、ES集群状态</h3><ol><li>绿色（Green）</li></ol><ul><li><strong>含义</strong>：集群健康状态正常，所有的主分片和副本分片都已分配。</li><li><strong>解释</strong>：绿色状态表示集群中的所有数据都可以访问，所有分片（包括主分片和副本分片）都分配到集群中的节点上。</li><li><strong>示例</strong>：假设集群有3个主分片，每个主分片有1个副本分片，那么绿色状态下这6个分片都已成功分配且正常运行。</li></ul><ol start="2"><li>黄色（Yellow）</li></ol><ul><li><strong>含义</strong>：集群健康状态部分正常，所有的主分片都已分配，但有一个或多个副本分片未分配。</li><li><strong>解释</strong>：黄色状态表示集群中的所有主分片都可以访问，但一些副本分片由于某种原因（例如节点故障或资源不足）未能分配。这意味着数据是安全的，但没有高可用性，因为如果某个节点失败，它可能会导致数据无法访问。</li><li><strong>示例</strong>：假设集群有3个主分片和每个主分片1个副本分片，如果有3个主分片和2个副本分片已分配，但1个副本分片未能分配，则集群为黄色状态。</li></ul><ol start="3"><li>红色（Red）</li></ol><ul><li><strong>含义</strong>：集群健康状态不正常，有一个或多个主分片未分配。</li><li><strong>解释</strong>：红色状态表示集群中有一些数据不可访问，因为主分片未能分配。此时，可能存在数据丢失的风险，需要立即采取措施来修复问题。</li><li><strong>示例</strong>：假设集群有3个主分片和每个主分片1个副本分片，如果有2个主分片和所有副本分片未能分配，则集群为红色状态。</li></ul><h3 id="2、Elasticsearch术语"><a href="#2、Elasticsearch术语" class="headerlink" title="2、Elasticsearch术语"></a>2、Elasticsearch术语</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Document</span><br><span class="line">    文档，用户存储在ES的数据，ES最小单元，文档不可被拆分。文档使用JSON的对象存储类型。</span><br><span class="line">    </span><br><span class="line">filed</span><br><span class="line">    相当于数据表的字段，对文档数据根据不同属性进行分类标识。</span><br><span class="line">    </span><br><span class="line">index</span><br><span class="line">    索引，一个索引就是拥有相似特征文档的集合。</span><br><span class="line">    </span><br><span class="line">shard</span><br><span class="line">    分片，存储数据的地方，每个底层对应的使一个Lucene库，一个索引至少有一个或多个分片。</span><br><span class="line">    </span><br><span class="line">replica</span><br><span class="line">    副本，一个分片可以有0个或者多个副本。作用是对数据进行备份，一旦副本数量不为0，就会引入主分片（primary shard）和副本分片（replica shard）的概念。</span><br><span class="line">        主分片（primary shard）</span><br><span class="line">            实现数据的读写操作。</span><br><span class="line">        副本分片（replica shard）</span><br><span class="line">            可以实现数据的读操作，需要主分片同步数据，当主分片挂掉时，副本分片会变为主分片。</span><br><span class="line">        </span><br><span class="line">Allocation</span><br><span class="line">    分配。将分片分配给某个节点的过程，包括主分片和副本分片。如果副本分片，还包含从主分片复制数据的过程，此过程由Master节点调度完成。</span><br></pre></td></tr></table></figure><h4 id="2-1、Elasticsearch分片分配的基本策略"><a href="#2-1、Elasticsearch分片分配的基本策略" class="headerlink" title="2.1、Elasticsearch分片分配的基本策略"></a>2.1、Elasticsearch分片分配的基本策略</h4><p>​    ES使用数据分片（shard）来提高服务的可用性，将数据分散保存在不同的节点上以降低当单个节点发生故障时对数据完整性的影响，同时使用副本（repiica）来保证数据的完整性。关于分片的默认分配策略，在7.x之前，默认5个primary shard，每个primary shard默认分配一个replica，即5主1副，而7.x之后，默认1主1副ES在分配单个索引的分片时会将每个分片尽可能分配到更多的节点上。但是，实际情况取决于集群拥有的分片和索引的数量以及它们的大小，不一定总是能均匀地分布。</p><p>​    Paimary只能在索引创建时配置数量，而replica可以在任何时间分配，并且primary支持读和写操作，而replica只支持客户端的读取操作，数据由es自动管理，从primary同步。ES不允许Primary和它的Replica放在同一个节点中，并且同一个节点不接受完全相同的两个Replica,同一个节点允许多个索引的分片同时存在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="ELK" scheme="https://l66stbz.github.io/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix告警媒介</title>
    <link href="https://l66stbz.github.io/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/"/>
    <id>https://l66stbz.github.io/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/</id>
    <published>2024-08-27T13:50:00.000Z</published>
    <updated>2024-08-31T02:22:43.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="zabbix-6-0结合邮箱进行告警"><a href="#zabbix-6-0结合邮箱进行告警" class="headerlink" title="zabbix 6.0结合邮箱进行告警"></a>zabbix 6.0结合邮箱进行告警</h1><h2 id="1、邮箱告警流程"><a href="#1、邮箱告警流程" class="headerlink" title="1、邮箱告警流程"></a>1、邮箱告警流程</h2><ol><li><p>个人邮箱/企业邮箱</p></li><li><p>开启邮箱 smtp功能，获取授权码</p></li><li><p>发件人：配置zabbix服务端报警媒介</p></li><li><p>收件人：配置群组、用户接收报警</p></li><li><p>报警动作：什么时候发送告警邮件</p></li></ol><h2 id="2、准备邮箱"><a href="#2、准备邮箱" class="headerlink" title="2、准备邮箱"></a>2、准备邮箱</h2><p>QQ邮箱地址：<a href="https://mail.qq.com/" target="_blank" rel="noopener">https://mail.qq.com/</a></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082049434.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082050025.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**什么是授权码？**</span><br></pre></td></tr></table></figure><p>授权码是QQ邮箱用于登录第三方客户端/服务的专用密码，适用于登录以下服务：POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV 服务。<br>温馨提醒：<code>为了你的帐户安全，请不要告诉他人你的授权码</code>，更改QQ帐号密码会触发授权码过期，需要重新获取新的授权码登录。</p><h2 id="3、测试邮箱使用连接正常"><a href="#3、测试邮箱使用连接正常" class="headerlink" title="3、测试邮箱使用连接正常"></a>3、测试邮箱使用连接正常</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装网络测试连接工具</span></span><br><span class="line">[root@zabbix-server01 ~]<span class="comment"># yum install -y nc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试邮箱</span></span><br><span class="line">[root@zabbix-server01 ~]<span class="comment"># nc smtp.qq.com -t 25</span></span><br><span class="line">220 newxmesmtplogicsvrsza29-0.qq.com XMail Esmtp QQ Mail Server.</span><br></pre></td></tr></table></figure><h2 id="4、设置zabbix-连接邮箱信息"><a href="#4、设置zabbix-连接邮箱信息" class="headerlink" title="4、设置zabbix 连接邮箱信息"></a>4、设置zabbix 连接邮箱信息</h2><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082101968.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082102764.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082110188.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082111087.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082112477.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082113808.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082113865.png" alt="img"></p><h3 id="4-1-设定宏"><a href="#4-1-设定宏" class="headerlink" title="4.1 设定宏"></a>4.1 设定宏</h3><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090014359.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090014257.png" alt="img"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">信息类型是</span>: <span class="string">问题( 发生故障 ) </span></span><br><span class="line"><span class="meta">主题</span>:   <span class="string">故障名称: &#123;EVENT.NAME&#125;</span></span><br><span class="line"><span class="meta">消息</span>: <span class="string"></span></span><br><span class="line"><span class="meta">故障始于</span> <span class="string">时间: &#123;EVENT.TIME&#125; 日期: &#123;EVENT.DATE&#125;</span></span><br><span class="line"><span class="meta">故障名称</span>: <span class="string">&#123;EVENT.NAME&#125;</span></span><br><span class="line"><span class="meta">故障主机</span>: <span class="string">&#123;HOST.NAME&#125;</span></span><br><span class="line"><span class="meta">严重程度</span>: <span class="string">&#123;EVENT.SEVERITY&#125;</span></span><br><span class="line"><span class="meta">额外信息</span>: <span class="string">&#123;EVENT.OPDATA&#125;</span></span><br><span class="line"><span class="meta">故障ID</span>: <span class="string">&#123;EVENT.ID&#125;</span></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="meta">发器地址</span>: <span class="string">&#123;TRIGGER.URL&#125;</span></span><br><span class="line"><span class="comment">#信息类型是: Problem recov 故障解决的时候</span></span><br><span class="line"><span class="meta">主题</span>: <span class="string">故障解决 in &#123;EVENT.DURATION&#125;: &#123;EVENT.NAME&#125;</span></span><br><span class="line"><span class="meta">消息</span>: <span class="string"></span></span><br><span class="line"><span class="meta">故障已经解决</span> <span class="string">时间: &#123;EVENT.RECOVERY.TIME&#125; 日期: </span></span><br><span class="line"><span class="attr">&#123;EVENT.RECOVERY.DATE&#125;</span></span><br><span class="line"><span class="meta">故障名称</span>: <span class="string">&#123;EVENT.NAME&#125;</span></span><br><span class="line"><span class="meta">故障持续时间</span>: <span class="string">&#123;EVENT.DURATION&#125;</span></span><br><span class="line"><span class="meta">故障主机</span>: <span class="string">&#123;HOST.NAME&#125;</span></span><br><span class="line"><span class="meta">故障级别</span>: <span class="string">&#123;EVENT.SEVERITY&#125;</span></span><br><span class="line"><span class="meta">故障ID</span>: <span class="string">&#123;EVENT.ID&#125;</span></span><br><span class="line"><span class="attr">&#123;TRIGGER.URL&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5、设置用户组和用户"><a href="#5、设置用户组和用户" class="headerlink" title="5、设置用户组和用户"></a>5、设置用户组和用户</h2><h3 id="5-1-创建用户组"><a href="#5-1-创建用户组" class="headerlink" title="5.1 创建用户组"></a>5.1 创建用户组</h3><p>针对不同的告警，发送至不同的用户组。</p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082114839.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082116658.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082117912.png" alt="img"></p><h3 id="5-2-创建用户"><a href="#5-2-创建用户" class="headerlink" title="5.2 创建用户"></a>5.2 创建用户</h3><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082118811.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082119735.png" alt="img"></p><p>设置用户的告警媒介</p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082121247.png" alt="img"></p><p>用户配置权限</p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082124437.png" alt="img"></p><p>查看新增用户</p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082127871.png" alt="img"></p><h3 id="5-3-赋予用户组相关主机群组的权限"><a href="#5-3-赋予用户组相关主机群组的权限" class="headerlink" title="5.3 赋予用户组相关主机群组的权限"></a>5.3 赋予用户组相关主机群组的权限</h3><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082359177.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090000453.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090001157.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090002372.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090002535.png" alt="img"></p><h2 id="6、设置告警动作"><a href="#6、设置告警动作" class="headerlink" title="6、设置告警动作"></a>6、设置告警动作</h2><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082130808.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082130300.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082132803.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082133399.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405082133276.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090006426.png" alt="img"></p><p>条件解释：</p><ul><li><p>基于模版：当指定某个监控模板时，该模板所设定的全部触发器触发时，都会发送告警信息；</p></li><li><p>基于主机：当指定某个主机时，该主机的所设定的全部触发器触发时，都会发送告警信息；</p></li><li><p>基于触发器：当指定某个触发器时，该触发器触发时，才会发送告警信息；</p></li><li><p>基于主机群组：当指定某个主机群组时，该主机群组所有的模板中的触发器所设定的全部触发器触发时，都会发送告警；</p></li></ul><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090009167.png" alt="img"></p><h1 id="zabbix-6-0结合企业微信进行告警"><a href="#zabbix-6-0结合企业微信进行告警" class="headerlink" title="zabbix 6.0结合企业微信进行告警"></a>zabbix 6.0结合企业微信进行告警</h1><h2 id="1、注册企业微信"><a href="#1、注册企业微信" class="headerlink" title="1、注册企业微信"></a>1、注册企业微信</h2><p>略</p><h2 id="2、创建群组机器人"><a href="#2、创建群组机器人" class="headerlink" title="2、创建群组机器人"></a>2、创建群组机器人</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716306783634-2ca44222-00a2-4bb7-9e0a-418cc4f2acaa.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716306802588-b33b0116-cf85-4504-b39a-6dfaa330f7d6.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716306889829-4a2a66ea-5ae3-488d-8205-8416a8f03afa.png" alt="img"></p><h2 id="3、web界面配置"><a href="#3、web界面配置" class="headerlink" title="3、web界面配置"></a>3、web界面配置</h2><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716306981859-92e03ed6-fc30-4446-b92c-d6b0fa447abf.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716307063502-5e32e774-d48b-4d81-bfe2-22cb4cf68450.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Wechat = &#123;</span><br><span class="line">  token: <span class="literal">null</span>,</span><br><span class="line">  to: <span class="literal">null</span>,</span><br><span class="line">  message: <span class="literal">null</span>,</span><br><span class="line">  parse_mode: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  sendMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = &#123;</span><br><span class="line">      msgtype: <span class="string">"markdown"</span>,</span><br><span class="line">      chat_id: Wechat.to,</span><br><span class="line">      markdown: &#123;</span><br><span class="line">        content:Wechat.message</span><br><span class="line">      &#125;,</span><br><span class="line">      disable_web_page_preview: <span class="literal">true</span>,</span><br><span class="line">      disable_notification: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">      data,</span><br><span class="line">      response,</span><br><span class="line">      request = <span class="keyword">new</span> CurlHttpRequest(),</span><br><span class="line">      url = <span class="string">'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=5043aed8-f801-4410-b4d3-82ac4e214883'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Wechat.parse_mode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      params[<span class="string">'parse_mode'</span>] = Wechat.parse_mode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request.AddHeader(<span class="string">'Content-Type: application/json'</span>);</span><br><span class="line">    data = <span class="built_in">JSON</span>.stringify(params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove replace() function if you want to see the exposed token in the log file.</span></span><br><span class="line">    Zabbix.Log(<span class="number">4</span>, <span class="string">'[Wechat Webhook] URL: '</span> + url.replace(Wechat.token, <span class="string">'&lt;TOKEN&gt;'</span>));</span><br><span class="line">    Zabbix.Log(<span class="number">4</span>, <span class="string">'[Wechat Webhook] params: '</span> + data);</span><br><span class="line">    response = request.Post(url, data);</span><br><span class="line">    Zabbix.Log(<span class="number">4</span>, <span class="string">'[Wechat Webhook] HTTP code: '</span> + request.Status());</span><br><span class="line">    Zabbix.Log(<span class="number">4</span>, <span class="string">'[Wechat Webhook] response: '</span> + response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response = <span class="built_in">JSON</span>.parse(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      response = <span class="literal">null</span>;</span><br><span class="line">      Zabbix.Log(<span class="number">4</span>, <span class="string">'[Wechat Webhook] response parse error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.Status() !== <span class="number">200</span> ||  response.errcode !== <span class="number">0</span> || response.errmsg !== <span class="string">'ok'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> response.errmsg === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> response.errmsg;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Unknown error. Check debug log for more information.'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> params = <span class="built_in">JSON</span>.parse(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> params.Token === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Incorrect value is given for parameter "Token": parameter is missing'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Wechat.token = params.Token;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">'Markdown'</span>, <span class="string">'HTML'</span>, <span class="string">'MarkdownV2'</span>].indexOf(params.ParseMode) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    Wechat.parse_mode = params.ParseMode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Wechat.to = params.To;</span><br><span class="line">  Wechat.message = params.Subject + <span class="string">'\n'</span> + params.Message;</span><br><span class="line">  Wechat.sendMessage();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'OK'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  Zabbix.Log(<span class="number">4</span>, <span class="string">'[Wechat Webhook] notification failed: '</span> + error);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'Sending failed: '</span> + error + <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意修改其中的Key值</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716307340934-547b1e7d-b3cf-4f21-bf75-342d7eeaca88.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">主题：【监控告警】主机: &lt;font color=<span class="string">"warning"</span>&gt;&#123;HOST.NAME&#125;&lt;/font&gt;  IP地址：&lt;font color=<span class="string">"warning"</span>&gt;&#123;HOST.IP&#125;&lt;/font&gt;</span><br><span class="line">消息：</span><br><span class="line">&gt;主机名称：**&lt;font color=<span class="string">"comment"</span>&gt;&#123;HOST.NAME&#125;&lt;/font&gt;**</span><br><span class="line">&gt;主机IP：&lt;font color=<span class="string">"comment"</span>&gt;&#123;HOST.IP&#125;&lt;/font&gt;</span><br><span class="line">&gt;告警时间：&lt;font color=<span class="string">"comment"</span>&gt;&#123;EVENT.DATE&#125;-&#123;EVENT.TIME&#125;&lt;/font&gt;</span><br><span class="line">&gt;问题名称：&lt;font color=<span class="string">"warning"</span>&gt;&#123;EVENT.NAME&#125;&lt;/font&gt;</span><br><span class="line">&gt;问题详情：&lt;font color=<span class="string">"comment"</span>&gt;&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125;&lt;/font&gt;</span><br><span class="line">&gt;目前状态：&lt;font color=<span class="string">"comment"</span>&gt;&#123;TRIGGER.STATUS&#125;&lt;/font&gt;</span><br><span class="line">&gt;操作数据：&lt;font color=<span class="string">"comment"</span>&gt;&#123;EVENT.OPDATA&#125;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">主题：</span><br><span class="line"></span><br><span class="line"><span class="comment">### 【监控告警】主机: &lt;font color="warning"&gt;&#123;HOST.NAME&#125;&lt;/font&gt;  IP地址：&lt;font color="warning"&gt;&#123;HOST.IP&#125;&lt;/font&gt;</span></span><br><span class="line"></span><br><span class="line">消息：</span><br><span class="line">&gt;主机名称：**&lt;font color=<span class="string">"comment"</span>&gt;&#123;HOST.NAME&#125;&lt;/font&gt;**</span><br><span class="line">&gt;主机IP：&lt;font color=<span class="string">"comment"</span>&gt;&#123;HOST.IP&#125;&lt;/font&gt;</span><br><span class="line">&gt;告警时间：&lt;font color=<span class="string">"comment"</span>&gt;&#123;EVENT.DATE&#125;-&#123;EVENT.TIME&#125;&lt;/font&gt;</span><br><span class="line">&gt;问题名称：&lt;font color=<span class="string">"warning"</span>&gt;&#123;EVENT.NAME&#125;&lt;/font&gt;</span><br><span class="line">&gt;问题详情：&lt;font color=<span class="string">"comment"</span>&gt;&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125;&lt;/font&gt;</span><br><span class="line">&gt;目前状态：&lt;font color=<span class="string">"comment"</span>&gt;&#123;TRIGGER.STATUS&#125;&lt;/font&gt;</span><br><span class="line">&gt;操作数据：&lt;font color=<span class="string">"comment"</span>&gt;&#123;EVENT.OPDATA&#125;&lt;/font&gt;</span><br></pre></td></tr></table></figure><h2 id="4、报警媒介测试"><a href="#4、报警媒介测试" class="headerlink" title="4、报警媒介测试"></a>4、报警媒介测试</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716307502312-86c5c320-e701-47e3-9416-24f4915b5004.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716307519891-c5a0ff51-1a01-45d5-9437-f8fc03590f23.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716307547368-889abd2f-0bda-48c4-944d-886224499e05.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716307576184-f35f48cc-8665-4041-952e-647387dc7636.png" alt="img"></p><h2 id="5、用户配置"><a href="#5、用户配置" class="headerlink" title="5、用户配置"></a>5、用户配置</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716307661758-fe4edc92-fb9e-4b47-93b5-23f188f32c1a.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716307700637-b37aee06-befb-41e8-8482-4bce19ded7f3.png" alt="img"></p><h2 id="6、动作配置"><a href="#6、动作配置" class="headerlink" title="6、动作配置"></a>6、动作配置</h2><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716307754681-968cb8f9-c96e-4ccf-b1e1-69ee82ff7960.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716307786295-f67dd981-8702-48f3-b186-d4891a830e96.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716307838323-6a409e18-703b-4e02-8d20-553a6d5882f5.png" alt="img"></p><h2 id="7、测试微信告警"><a href="#7、测试微信告警" class="headerlink" title="7、测试微信告警"></a>7、测试微信告警</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 被监控端关闭nginx</span></span><br><span class="line">[root@web-01 zabbix_agent2.d]<span class="comment"># systemctl stop nginx</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40379882/1716308076223-e0629e03-9651-4f69-b16f-218028be26e1.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/1716308097532-15339ba9-daa1-4337-8f74-b4b85c958a27.png" alt="img"></p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="zabbix-6-0-结合飞书进行告警"><a href="#zabbix-6-0-结合飞书进行告警" class="headerlink" title="zabbix 6.0 结合飞书进行告警"></a>zabbix 6.0 结合飞书进行告警</h1><h2 id="1、操作步骤"><a href="#1、操作步骤" class="headerlink" title="1、操作步骤"></a>1、操作步骤</h2><ul><li><p>飞书创建群组-添加自定义机器人，复制自定义机器人的webhook地址；</p></li><li><p>zabbix服务器脚本目录下新建feishu.py脚本，并配置webhook地址；</p></li><li><p>创建zabbix报警媒介类型，用户添加报警媒介；</p></li><li><p>创建动作，配置操作。</p></li></ul><h3 id="1-1-webhook介绍"><a href="#1-1-webhook介绍" class="headerlink" title="1.1 webhook介绍"></a>1.1 webhook介绍</h3><p>飞书中的自定义机器人Webhook地址用于<strong>接收和响应群组中的消息</strong>。</p><p>在飞书平台中，创建群组并添加自定义机器人后，会得到一个webhook地址。这个地址是<strong>一个HTTP接口</strong>，它的主要作用如下：</p><ol><li><p><strong>消息推送</strong>：当你需要将外部系统的信息自动推送到飞书群组时，可以通过调用这个webhook地址来实现。例如，你可以使用它来发送天气预报、日程提醒或者工作状态更新等信息。</p></li><li><p><strong>自动化流程</strong>：结合其他工具或服务，webhook可以实现工作流程的自动化。例如，当某个任务在外部系统中完成时，通过webhook通知群组成员，实现任务的自动跟进和管理。</p></li><li><p><strong>集成第三方服务</strong>：通过webhook地址，可以将飞书群组与其他第三方服务（如GitHub、Jira等）集成，使得群组成为各种信息交流和协作的中心。</p></li></ol><p>总的来说，自定义机器人的webhook地址是实现飞书群组智能自动化功能的关键，它允许用户根据自己的需求定制机器人的行为，从而提高工作效率和群组互动的质量。</p><h2 id="2、飞书相关操作"><a href="#2、飞书相关操作" class="headerlink" title="2、飞书相关操作"></a>2、飞书相关操作</h2><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090939663.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090940259.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090941083.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090941772.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090942929.png" alt="img"></p><p>设置机器人名称、描述，复制保存生成的webhook地址。</p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090942703.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090943571.png" alt="img"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="string">//open.feishu.cn/open-apis/bot/v2/hook/2e9b42ff-6977-4bbd-80b1-cd796787fb5c</span></span><br></pre></td></tr></table></figure><h2 id="3、创建飞书脚本文件"><a href="#3、创建飞书脚本文件" class="headerlink" title="3、创建飞书脚本文件"></a>3、创建飞书脚本文件</h2><p>登录zabbix服务器，进入到/usr/lib/zabbix/alertscripts/目录，新建feishu.py文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zabbix-server01 ~]<span class="comment"># vim /usr/local/share/zabbix/alertscripts/feishu.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://open.feishu.cn/open-apis/bot/v2/hook/2e9b42ff-6977-4bbd-80b1-cd796787fb5c"</span> <span class="comment">#你复制的webhook地址粘贴进url内</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    payload_message = &#123;</span><br><span class="line">        <span class="string">"msg_type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="string">"content"</span>: &#123;</span><br><span class="line">            <span class="string">"text"</span>: message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = requests.request(<span class="string">"POST"</span>, url, headers=headers, data=json.dumps(payload_message))</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    text = sys.argv[<span class="number">1</span>]</span><br><span class="line">    send_message(text)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装python3</span></span><br><span class="line">[root@zabbix-server01 ~]<span class="comment"># yum install -y python3</span></span><br><span class="line">[root@zabbix-server01 ~]<span class="comment"># pip-3 install requests</span></span><br><span class="line"><span class="comment"># 脚本增加执行权限</span></span><br><span class="line">[root@zabbix-server01 ~]<span class="comment"># chmod +x  /usr/local/share/zabbix/alertscripts/feishu.py</span></span><br></pre></td></tr></table></figure><h2 id="4、zabbix-web配置报警媒介"><a href="#4、zabbix-web配置报警媒介" class="headerlink" title="4、zabbix web配置报警媒介"></a>4、zabbix web配置报警媒介</h2><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090954794.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090956690.png" alt="img"></p><p>配置Message template</p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090957238.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405090958959.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主题：</span></span><br><span class="line">异常通知: &#123;EVENT.NAME&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息体</span></span><br><span class="line">告警主机:&#123;HOSTNAME1&#125;</span><br><span class="line">告警时间:&#123;EVENT.TIME&#125;</span><br><span class="line">告警等级:&#123;TRIGGER.SEVERITY&#125; </span><br><span class="line">告警信息:&#123;EVENT.NAME&#125; </span><br><span class="line">告警项目:&#123;TRIGGER.KEY1&#125; </span><br><span class="line">问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125; </span><br><span class="line">当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125; </span><br><span class="line">事件ID:&#123;EVENT.ID&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主题：</span></span><br><span class="line">恢复通知: &#123;EVENT.NAME&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息体</span></span><br><span class="line">告警主机:&#123;HOSTNAME1&#125;</span><br><span class="line">告警时间:&#123;EVENT.TIME&#125;</span><br><span class="line">告警等级:&#123;TRIGGER.SEVERITY&#125; </span><br><span class="line">告警信息:&#123;EVENT.NAME&#125; </span><br><span class="line">告警项目:&#123;TRIGGER.KEY1&#125; </span><br><span class="line">问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125; </span><br><span class="line">当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125; </span><br><span class="line">事件ID:&#123;EVENT.ID&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091002343.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091003592.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091003051.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091003329.png" alt="img"></p><h2 id="5、创建用户群组和用户"><a href="#5、创建用户群组和用户" class="headerlink" title="5、创建用户群组和用户"></a>5、创建用户群组和用户</h2><p>详细请见zabbix 6.0 结合邮箱告警用户组和用户创建</p><h2 id="6、触发器动作创建"><a href="#6、触发器动作创建" class="headerlink" title="6、触发器动作创建"></a>6、触发器动作创建</h2><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091114076.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091131585.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091132751.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091133738.png" alt="img"></p><h2 id="7、测试飞书告警"><a href="#7、测试飞书告警" class="headerlink" title="7、测试飞书告警"></a>7、测试飞书告警</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 被监控端关闭nginx</span></span><br><span class="line">$ systemctl stop nginx</span><br></pre></td></tr></table></figure><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091134019.png" alt="img"></p><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091134043.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">$ systemctl start nginx</span><br></pre></td></tr></table></figure><p><img src="/2024/08/27/Zabbix%E5%91%8A%E8%AD%A6%E5%AA%92%E4%BB%8B/202405091135058.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Zabbix" scheme="https://l66stbz.github.io/tags/Zabbix/"/>
    
      <category term="Shell" scheme="https://l66stbz.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix自定义监控脚本</title>
    <link href="https://l66stbz.github.io/2024/08/26/Zabbix%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E8%84%9A%E6%9C%AC/"/>
    <id>https://l66stbz.github.io/2024/08/26/Zabbix%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E8%84%9A%E6%9C%AC/</id>
    <published>2024-08-26T13:50:00.000Z</published>
    <updated>2024-08-31T02:22:01.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="zabbix-6-0-自定义监控redis"><a href="#zabbix-6-0-自定义监控redis" class="headerlink" title="zabbix 6.0 自定义监控redis"></a>zabbix 6.0 自定义监控redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/etc/zabbix/zabbix_agent2.d/redis_status.sh</span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">REDISCLI=<span class="string">"/usr/local/redis/src/redis-cli"</span></span><br><span class="line">HOST=<span class="string">"127.0.0.1"</span></span><br><span class="line">PORT=6379</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        <span class="comment"># 获取 Redis 的版本号。</span></span><br><span class="line">        version)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"redis_version"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        uptime)</span><br><span class="line">        <span class="comment"># 获取 Redis 服务器运行的秒数。</span></span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"uptime_in_seconds"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取当前连接到 Redis 服务器的客户端数量。</span></span><br><span class="line">        connected_clients)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"connected_clients"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取当前被阻塞的客户端数量。</span></span><br><span class="line">        blocked_clients)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"blocked_clients"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis 使用的内存量。</span></span><br><span class="line">        used_memory)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_memory"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis 使用的 RSS（Resident Set Size）内存，表示 Redis 在操作系统层面实际占用的物理内存。</span></span><br><span class="line">        used_memory_rss)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_memory_rss"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis 使用的内存峰值。</span></span><br><span class="line">        used_memory_peak)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_memory_peak"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis Lua 脚本执行时使用的内存。</span></span><br><span class="line">        used_memory_lua)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_memory_lua"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis 在系统级别（内核态）消耗的 CPU 时间。</span></span><br><span class="line">        used_cpu_sys)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_cpu_sys"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis 在用户态消耗的 CPU 时间。</span></span><br><span class="line">        used_cpu_user)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_cpu_user"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis 所有子进程在系统态消耗的 CPU 时间。</span></span><br><span class="line">        used_cpu_sys_children)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_cpu_sys_children"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 获取 Redis 所有子进程在用户态消耗的 CPU 时间。</span></span><br><span class="line">        used_cpu_user_children)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info | grep -w <span class="string">"used_cpu_user_children"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 检查最近一次 RDB 持久化操作的状态是否成功。</span></span><br><span class="line">        rdb_last_bgsave_status)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info  | grep -w <span class="string">"rdb_last_bgsave_status"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span> | grep -c ok`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 检查最近一次 AOF 重写操作的状态是否成功。</span></span><br><span class="line">        aof_last_bgrewrite_status)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info  | grep -w <span class="string">"aof_last_bgrewrite_status"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span> | grep -c ok`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">        <span class="comment"># 检查最近一次 AOF 写操作的状态是否成功。</span></span><br><span class="line">        aof_last_write_status)</span><br><span class="line">            result=`<span class="variable">$REDISCLI</span> -h <span class="variable">$HOST</span> -p <span class="variable">$PORT</span> info  | grep -w <span class="string">"aof_last_write_status"</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span> | grep -c ok`</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">/etc/zabbix/zabbix_agent2.d/redis_status.conf</span><br><span class="line">UserParameter=redis_status[*],bash /etc/zabbix/zabbix_agent2.d/redis_status.sh <span class="variable">$1</span></span><br><span class="line">UserParameter=redis_ping,/usr/<span class="built_in">local</span>/redis/src/redis-cli PING|grep -c <span class="string">"PONG"</span> | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启客户端工具</span></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># systemctl restart zabbix-agent2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># zabbix_agent2  -t redis_status[uptime]</span></span><br><span class="line">redis_status[uptime]                          [s|2698]</span><br><span class="line"></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># zabbix_agent2  -t redis_status[version]</span></span><br><span class="line">redis_status[version]                         [s|6.2.7]</span><br><span class="line"></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># zabbix_agent2  -t redis_ping</span></span><br><span class="line">redis_ping</span><br><span class="line"></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># zabbix_get -s 192.168.100.90 -p 10050 -k redis_status[version]</span></span><br><span class="line">6.2.7</span><br></pre></td></tr></table></figure><h3 id="zabbix-6-0-自定义监控mysql"><a href="#zabbix-6-0-自定义监控mysql" class="headerlink" title="zabbix 6.0 自定义监控mysql"></a>zabbix 6.0 自定义监控mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">/etc/zabbix/zabbix_agent2.d/mysql_check.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 用户名（确保有这个用户）</span></span><br><span class="line">MYSQL_USER=<span class="string">'zabbix'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">MYSQL_PWD=<span class="string">'zabbix'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机地址/IP     下面这个写法是agent 和  数据库在同台机器上</span></span><br><span class="line">MYSQL_HOST=<span class="string">'127.0.0.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line">MYSQL_PORT=<span class="string">'3306'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据连接</span></span><br><span class="line">MYSQL_CONN=<span class="string">"/usr/bin/mysqladmin -u<span class="variable">$&#123;MYSQL_USER&#125;</span> -p<span class="variable">$&#123;MYSQL_PWD&#125;</span> -h<span class="variable">$&#123;MYSQL_HOST&#125;</span> -P<span class="variable">$&#123;MYSQL_PORT&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne <span class="string">"1"</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"arg error!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="comment"># 获取 MySQL 数据库运行的时间（以秒为单位）。</span></span><br><span class="line">Uptime)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> status 2&gt;/dev/null |cut -f2 -d<span class="string">":"</span>|cut -f1 -d<span class="string">"T"</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取执行 UPDATE 语句的次数。</span></span><br><span class="line">Com_update)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status   2&gt;/dev/null  |grep -w <span class="string">"Com_update"</span>|cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取执行时间超过 long_query_time 配置的慢查询的次数。</span></span><br><span class="line">Slow_queries)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> status  2&gt;/dev/null  |cut -f5 -d<span class="string">":"</span>|cut -f1 -d<span class="string">"O"</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取执行 SELECT 语句的次数。</span></span><br><span class="line">Com_select)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status  2&gt;/dev/null  |grep -w <span class="string">"Com_select"</span>|cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取执行 ROLLBACK 事务的次数。</span></span><br><span class="line">Com_rollback)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status  2&gt;/dev/null   |grep -w <span class="string">"Com_rollback"</span>|cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取自数据库启动以来处理的查询总数。</span></span><br><span class="line">Questions)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> status   2&gt;/dev/null |cut -f4 -d<span class="string">":"</span>|cut -f1 -d<span class="string">"S"</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment">#  获取执行 INSERT 语句的次数。</span></span><br><span class="line">Com_insert)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status   2&gt;/dev/null  |grep -w <span class="string">"Com_insert"</span>|cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取执行 DELETE 语句的次数。</span></span><br><span class="line">Com_delete)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status   2&gt;/dev/null  |grep -w <span class="string">"Com_delete"</span>|cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取执行 COMMIT 事务的次数。</span></span><br><span class="line">Com_commit)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status   2&gt;/dev/null  |grep -w <span class="string">"Com_commit"</span>|cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取 MySQL 服务器发送的字节总数。</span></span><br><span class="line">Bytes_sent)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status  2&gt;/dev/null  |grep -w <span class="string">"Bytes_sent"</span> |cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取 MySQL 服务器接收的字节总数。</span></span><br><span class="line">Bytes_received)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status  2&gt;/dev/null  |grep -w <span class="string">"Bytes_received"</span> |cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line"><span class="comment"># 获取执行 BEGIN 事务的次数。</span></span><br><span class="line">Com_begin)</span><br><span class="line">result=`<span class="variable">$&#123;MYSQL_CONN&#125;</span> extended-status  2&gt;/dev/null  |grep -w <span class="string">"Com_begin"</span>|cut -d<span class="string">"|"</span> -f3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Usage:<span class="variable">$0</span>(Uptime|Com_update|Slow_queries|Com_select|Com_rollback|Questions|Com_insert|Com_delete|Com_commit|Bytes_sent|Bytes_received|Com_begin)"</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/etc/zabbix/zabbix_agent2.d/mysql_check.conf</span><br><span class="line">UserParameter=mysql_check[*],bash /etc/zabbix/zabbix_agent2.d/mysql_check.sh <span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启客户端工具</span></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># systemctl restart zabbix-agent2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># zabbix_agent2  -t mysql_check[Uptime]</span></span><br><span class="line">mysql_check[Uptime]                           [s|638]</span><br><span class="line"></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># zabbix_get -s 192.168.100.90 -p 10050 -k mysql_check[Uptime]</span></span><br><span class="line">640</span><br></pre></td></tr></table></figure><h3 id="zabbix-6-0-自定义监控mysql主从状态"><a href="#zabbix-6-0-自定义监控mysql主从状态" class="headerlink" title="zabbix 6.0 自定义监控mysql主从状态"></a>zabbix 6.0 自定义监控mysql主从状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/etc/zabbix/zabbix_agent2.d/mysql_slave_status.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=`mysql -u root -p1 -e <span class="string">"SHOW SLAVE STATUS\G"</span>  2&gt;/dev/null |awk -F<span class="string">' '</span> <span class="string">'NR==12&#123;print $2&#125;'</span>`</span><br><span class="line">b=`mysql -u root -p1 -e <span class="string">"SHOW SLAVE STATUS\G"</span>  2&gt;/dev/null |awk -F<span class="string">' '</span> <span class="string">'NR==13&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="string">'Yes'</span> -a <span class="variable">$b</span> = <span class="string">'Yes'</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">/etc/zabbix/zabbix_agent2.d/mysql_slave_status.conf</span><br><span class="line">UserParameter=mysql_slave_status,bash /etc/zabbix/zabbix_agent2.d/mysql_slave_status.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启客户端工具</span></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># systemctl restart zabbix-agent2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">[root@web09 zabbix_agent2.d]<span class="comment"># zabbix_agent2  -t mysql_slave_status</span></span><br><span class="line">mysql_slave_status                            [s|1]</span><br><span class="line"></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># zabbix_get -s 192.168.100.90 -p 10050 -k mysql_slave_status</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="zabbix-6-0-自定义监控nginx"><a href="#zabbix-6-0-自定义监控nginx" class="headerlink" title="zabbix 6.0 自定义监控nginx"></a>zabbix 6.0 自定义监控nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nginx服务开启状态模块</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">           root /usr/share/nginx/html;</span><br><span class="line">           index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /status &#123;</span><br><span class="line">           stub_status on;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">$ nginx -t</span><br><span class="line">$ systemctl reload nginx</span><br><span class="line"></span><br><span class="line">/etc/zabbix/zabbix_agent2.d/nginx_status.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># nginx status模块状态监控</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Active</span></span> () &#123;</span><br><span class="line">wget --quiet -O - http://localhost/status?auto | awk <span class="string">'NR==1 &#123;print $3&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Accept</span></span> () &#123;</span><br><span class="line">wget --quiet -O - http://localhost/status?auto | awk <span class="string">'NR==3 &#123;print $1&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Handled</span></span> () &#123;</span><br><span class="line">wget --quiet -O - http://localhost/status?auto | awk <span class="string">'NR==3 &#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Requests</span></span> () &#123;</span><br><span class="line">wget --quiet -O - http://localhost/status?auto | awk <span class="string">'NR==3 &#123;print $3&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Reading</span></span> () &#123;</span><br><span class="line">wget --quiet -O - http://localhost/status?auto | awk <span class="string">'NR==4 &#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Writing</span></span> () &#123;</span><br><span class="line">wget --quiet -O - http://localhost/status?auto | awk <span class="string">'NR==4 &#123;print $4&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Waiting</span></span> () &#123;</span><br><span class="line">wget --quiet -O - http://localhost/status?auto | awk <span class="string">'NR==4 &#123;print $6&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">/etc/zabbix/zabbix_agent2.d/nginx_status.conf</span><br><span class="line">UserParameter=nginx_status[*],/etc/zabbix/zabbix_agent2.d/nginx_status.sh <span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启客户端工具</span></span><br><span class="line">[root@test01 ~]<span class="comment"># systemctl restart zabbix-agent2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予脚本执行权限</span></span><br><span class="line">[root@test01 ~]<span class="comment"># chmod +x /etc/zabbix/zabbix_agent2.d/nginx_status.sh </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试脚本</span></span><br><span class="line">[root@test01 ~]<span class="comment"># bash /etc/zabbix/zabbix_agent2.d/nginx_status.sh  Accept</span></span><br><span class="line">1188</span><br><span class="line"><span class="comment"># 服务端测试抓取客户端自定义监控指标</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># zabbix_get  -s 192.168.100.90   -k "nginx_status[Accept]"</span></span><br><span class="line">2166</span><br></pre></td></tr></table></figure><h3 id="zabbix-6-0-自定义监控JVM"><a href="#zabbix-6-0-自定义监控JVM" class="headerlink" title="zabbix 6.0 自定义监控JVM"></a>zabbix 6.0 自定义监控JVM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">安装tomcat</span><br><span class="line">如果是编译安装就直接在以下文件中添加即可！</span><br><span class="line">如果是yum安装就在/usr/libexec/tomcat/server这个文件中添加</span><br><span class="line">可以通过systemctl cat tomcat来查看</span><br><span class="line">ExecStart=/usr/libexec/tomcat/server</span><br><span class="line"></span><br><span class="line">[root@java-web01 bin]<span class="comment"># vim /usr/local/tomcat/bin/catalina.sh </span></span><br><span class="line"><span class="comment">#需添加的内容</span></span><br><span class="line">CATALINA_OPTS=<span class="string">" \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.authenticate=false \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.ssl=false \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.port=12345 \</span></span><br><span class="line"><span class="string">-Djava.rmi.server.hostname=192.168.100.90"</span></span><br><span class="line"></span><br><span class="line">添加完后重启tomcat，然后查看12345端口有没有放开，没放开说明配置有问题！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下是上边添加内容的含义:</span><br><span class="line">-Dcom.sun.management.jmxremote<span class="comment">#  启用 JMX 远程管理功能。启用该选项后，JVM 将允许远程连接进行监控和管理。  </span></span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span><span class="comment">#  禁用 JMX 远程管理的认证功能。默认情况下，JMX 远程访问是需要身份验证的</span></span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span><span class="comment">#  禁用 JMX 远程管理的 SSL 加密功能。  </span></span><br><span class="line">-Dcom.sun.management.jmxremote.port=12345<span class="comment"># JMX对外暴露端口号</span></span><br><span class="line">-Djava.rmi.server.hostname=192.168.100.90<span class="comment"># java实例主机IP， 客户端将连接到该 IP 地址进行 JMX 操作。</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">zabbix-server端</span></span><br><span class="line">[root@zabbix-server ~]# yum install -y zabbix-java-gateway</span><br><span class="line"><span class="meta">#</span><span class="bash"> zabbix-java-gateway配置</span></span><br><span class="line">[root@zabbix-server ~]# vim /etc/zabbix/zabbix_java_gateway.conf </span><br><span class="line">17:LISTEN_PORT=10052</span><br><span class="line">27:PID_FILE="/var/run/zabbix/zabbix_java_gateway.pid"</span><br><span class="line"></span><br><span class="line">以上两步其实不是非要在server端操作，也可以在安装tomcat的服务器上操作。如果在tomcat机器上操作，以下的</span><br><span class="line">JavaGateway就不能写127.0.0.1，需要写安装tomcat的服务器的IP。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@zabbix-server ~]# vim /etc/zabbix/zabbix_server.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> JavaGate 客户端地址</span></span><br><span class="line">JavaGateway=127.0.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> JavaGate 端口号</span></span><br><span class="line">JavaGatewayPort=10052</span><br><span class="line"><span class="meta">#</span><span class="bash"> JavaGate启动进程数</span></span><br><span class="line">StartJavaPollers=5</span><br><span class="line"></span><br><span class="line">[root@zabbix-server ~]# systemctl enable --now zabbix-java-gateway</span><br><span class="line">[root@zabbix-server ~]# systemctl restart zabbix_server</span><br><span class="line">[root@zabbix-server ~]# ls</span><br><span class="line">cmdline-jmxclient-0.10.3.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@zabbix-server ~]# java -jar cmdline-jmxclient-0.10.3.jar  - 192.168.100.130:12345</span><br><span class="line">Catalina:port=8080,type=Mapper</span><br><span class="line">java.lang:type=Runtime</span><br><span class="line">java.lang:name=PS Scavenge,type=GarbageCollector</span><br><span class="line">Catalina:port=8009,type=Connector</span><br><span class="line">java.nio:name=mapped,type=BufferPool</span><br><span class="line">Catalina:name="http-bio-8080",type=GlobalRequestProcessor</span><br><span class="line">Catalina:host=localhost,name=AccessLogValve,type=Valve</span><br><span class="line">java.lang:name=Compressed Class Space,type=MemoryPool</span><br><span class="line">java.util.logging:type=Logging</span><br><span class="line">java.lang:type=Compilation</span><br><span class="line">Catalina:port=8009,type=Mapper</span><br><span class="line">JMImplementation:type=MBeanServerDelegate</span><br><span class="line">java.lang:type=ClassLoading</span><br><span class="line">com.sun.management:type=HotSpotDiagnostic</span><br><span class="line">Catalina:type=NamingResources</span><br><span class="line">java.lang:name=CodeCacheManager,type=MemoryManager</span><br><span class="line">Catalina:host=localhost,name=StandardHostValve,type=Valve</span><br><span class="line">Catalina:realmPath=/realm0/realm0,type=Realm</span><br><span class="line">Catalina:type=Service</span><br><span class="line">java.nio:name=direct,type=BufferPool</span><br><span class="line">Catalina:name="ajp-bio-8009",type=ThreadPool</span><br><span class="line">java.lang:name=PS MarkSweep,type=GarbageCollector</span><br><span class="line">com.sun.management:type=DiagnosticCommand</span><br><span class="line">java.lang:type=Memory</span><br><span class="line">Catalina:type=MBeanFactory</span><br><span class="line">Catalina:port=8080,type=ProtocolHandler</span><br><span class="line">java.lang:name=Metaspace,type=MemoryPool</span><br><span class="line">java.lang:name=PS Old Gen,type=MemoryPool</span><br><span class="line">Catalina:name=StandardEngineValve,type=Valve</span><br><span class="line">Catalina:name="ajp-bio-8009",type=GlobalRequestProcessor</span><br><span class="line">Catalina:port=8009,type=ProtocolHandler</span><br><span class="line">java.lang:type=Threading</span><br><span class="line">Catalina:realmPath=/realm0,type=Realm</span><br><span class="line">Catalina:name="http-bio-8080",type=ThreadPool</span><br><span class="line">java.lang:name=PS Eden Space,type=MemoryPool</span><br><span class="line">jdk.management.jfr:type=FlightRecorder</span><br><span class="line">Catalina:host=localhost,type=Deployer</span><br><span class="line">Catalina:class=org.apache.catalina.UserDatabase,name="UserDatabase",resourcetype=Global,type=Resource</span><br><span class="line">java.lang:name=PS Survivor Space,type=MemoryPool</span><br><span class="line">Catalina:type=Server</span><br><span class="line">Users:database=UserDatabase,type=UserDatabase</span><br><span class="line">java.lang:type=OperatingSystem</span><br><span class="line">Catalina:type=StringCache</span><br><span class="line">java.lang:name=Metaspace Manager,type=MemoryManager</span><br><span class="line">Catalina:port=8080,type=Connector</span><br><span class="line">java.lang:name=Code Cache,type=MemoryPool</span><br><span class="line">Catalina:host=localhost,name=ErrorReportValve,type=Valve</span><br><span class="line">Catalina:host=localhost,type=Host</span><br><span class="line">Catalina:type=Engine</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Zabbix" scheme="https://l66stbz.github.io/tags/Zabbix/"/>
    
      <category term="Shell" scheme="https://l66stbz.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>企业级Zabbix监控平台</title>
    <link href="https://l66stbz.github.io/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"/>
    <id>https://l66stbz.github.io/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/</id>
    <published>2024-08-23T13:50:00.000Z</published>
    <updated>2024-08-31T02:20:06.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="企业级Zabbix监控平台"><a href="#企业级Zabbix监控平台" class="headerlink" title="企业级Zabbix监控平台"></a>企业级Zabbix监控平台</h1><h2 id="1、监控的意义"><a href="#1、监控的意义" class="headerlink" title="1、监控的意义"></a>1、监控的意义</h2><ol><li><p><code>**保障业务稳定运行**</code>：监控系统通过实时关注与业务相关的<code>各项指标</code>，确保服务器、网络设备等硬件资源的正常运行，从而保障公司线上业务的稳定性。</p></li><li><p><code>**及时发现和解决问题**</code>：监控系统能够及时发现系统的异常和故障，通过<code>告警</code>管理迅速通知运维人员，以便尽快采取措施解决问题，减少潜在的损失。</p></li><li><p><strong>数据收集与分析</strong>：监控系统可以收集系统运行的各种数据，如性能数据、日志信息等，通过数据分析帮助管理者更好地理解系统运行状况，优化系统性能。</p></li><li><p><code>**预防故障**</code>：除了发现和解决已经发生的故障，监控系统还能够通过<code>历史数据</code>分析预测潜在的问题，提前采取预防措施，避免故障发生。</p></li></ol><h2 id="2、监控的对象"><a href="#2、监控的对象" class="headerlink" title="2、监控的对象"></a>2、监控的对象</h2><p>通常情况下，我们可以将监控对象这么来分：</p><ol><li><p><strong>服务器监控</strong>：主要监控服务器如：CPU 负载、内存使用率、磁盘使用率、登陆用户数、进程状态、网卡状态等。</p></li><li><p><strong>应用程序监控</strong>：主要监控该应用程序的服务状态，吞吐率和响应时间，因为不同应用需要监控的对象不同，这里不一一列举。</p></li><li><p><strong>数据库监控</strong>：只所以把数据库监控单独列出来，足以说明它的重要性，一般监控数据库状态，数据库表或者表空间的使用情况，是否有死锁，错误日志，性能信息等等。</p></li><li><p><strong>网络监控</strong>：主要监控当前的网络状况，网络流量，端口，连接等。</p></li></ol><p>举例：</p><p><strong>Nginx监控</strong>：Zabbix可以收集包括活跃连接数（active connections）、已接受的连接数（accepts）、已处理的请求总数（handled requests）等在内的关键性能指标。这些数据可以通过自定义脚本使用<code>awk</code>等工具从Nginx状态页中提取出来。</p><h2 id="3、常见监控软件：-夜莺监控-睿象云"><a href="#3、常见监控软件：-夜莺监控-睿象云" class="headerlink" title="3、常见监控软件： 夜莺监控 睿象云"></a>3、常见监控软件： 夜莺监控 睿象云</h2><ol><li><p>Nagios：Nagios是一款开源的监控工具，主要用于监控系统和网络的运行状态，它可以通过多种插件来监控不同的服务和应用。Nagios的特点是轻量级，配置复杂，但是功能强大。<br><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/image-20240425111948184.png" alt="img"> </p></li><li><p>Zabbix：Zabbix是一款更加强大的监控工具，它不仅可以监控系统和应用的运行状态，还可以进行分布式监控、容器监控、网络监控等。Zabbix的特点是功能强大，界面友好，同时支持多种插件和自定义脚本。 MySQL zabbix-proxy<br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425112701820.png" alt="img"> </p></li><li><p>Prometheus：Prometheus是一款开源的监控和报警系统，它将所有监控数据保存为时间序列数据，并对这些数据进行高效的查询和聚合。Prometheus的特点是数据模型简单，强大的查询语言，以及可通过Pull模式获取监控数据。  grfana</p></li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20230524135314127.png" alt="img"></p><h2 id="4、Zabbix应用手册"><a href="#4、Zabbix应用手册" class="headerlink" title="4、Zabbix应用手册"></a>4、Zabbix应用手册</h2><h3 id="4-1-Zabbix介绍"><a href="#4-1-Zabbix介绍" class="headerlink" title="4.1 Zabbix介绍"></a>4.1 Zabbix介绍</h3><p>zabbix官方网站：<a href="https://www.zabbix.com/" target="_blank" rel="noopener">https://www.zabbix.com/</a></p><p>Zabbix是一款开源的监控软件，用于监控各种网络参数、服务器的健康状况以及应用程序的状态。它能够提供灵活的通知机制，允许用户在问题发生时立即得到通知</p><ol><li><p><code>**分布式监控**</code>：Zabbix支持<code>分布式监控</code>，可以轻松地从一台主机监控远程主机和服务。</p></li><li><p><code>**实时数据收集**</code>：Zabbix提供了<code>实时数据收集</code>和图形展示功能，使管理员能够快速了解系统状态并及时响应问题。</p></li><li><p><strong>灵活的告警机制</strong>：Zabbix具有灵活的告警机制，可以根据预设的条件触发告警，并通过多种方式（如邮件、短信）通知管理员。</p></li><li><p><code>**自动发现**</code>：Zabbix支持自动发现功能，可以自动检测网络中的设备和服务，简化了配置过程。</p></li><li><p><strong>模板化管理</strong>：Zabbix使用模板来简化监控项的配置，只需将模板应用于特定的主机或服务，就可以实现对多个对象的统一监控。</p></li><li><p><code>**Web界面**</code>：Zabbix提供了一个直观的Web界面，使管理员能够轻松查看监控数据、配置告警和管理系统设置。</p></li><li><p><strong>Agent和Agentless监控</strong>：Zabbix支持基于Agent的监控和无Agent的监控。基于Agent的监控需要在被监控的主机上安装Zabbix Agent，而无Agent的监控则通过SNMP、IPMI等协议收集数据。</p></li><li><p><strong>历史数据存储</strong>：Zabbix可以将历史数据存储在数据库中，以便进行长期趋势分析和报告生成。</p></li><li><p><code>**权限管理**</code>：Zabbix具有强大的权限管理功能，可以定义不同角色的用户，并赋予他们对特定资源的访问权限。</p></li></ol><h4 id="4-1-1-zabbix企业版选型"><a href="#4-1-1-zabbix企业版选型" class="headerlink" title="4.1.1 zabbix企业版选型"></a>4.1.1 zabbix企业版选型</h4><p>网站：<a href="https://www.zabbix.com/cn/life_cycle_and_release_policy" target="_blank" rel="noopener">Zabbix产品周期&amp;发布日志</a></p><p><strong>Zabbix LTS （长期支持版本）的生命周期</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/life_cycle_of_zabbix_lts_release.png" alt="img"></p><p><strong>Zabbix标准版本的生命周期</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/life_cycle_standard_release.svg" alt="img"></p><h3 id="4-2-zabbix架构图详解"><a href="#4-2-zabbix架构图详解" class="headerlink" title="4.2 zabbix架构图详解"></a>4.2 zabbix架构图详解</h3><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240424095830180.png" alt="img"></p><p><code>zabbix</code>是一个典型的C/S（客户端/服务端）架构。</p><p><strong>监控大致流程：</strong>zabbix-agent(客户端)获取监控数据，zabbix_server端(服务端)索要数据，然后数据会被存放至数据库，zabbix web展示所收集的监控数据。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425145214990.png" alt="img"></p><h4 id="4-2-1-zabbix-组件介绍"><a href="#4-2-1-zabbix-组件介绍" class="headerlink" title="4.2.1 zabbix 组件介绍"></a>4.2.1 zabbix 组件介绍</h4><ul><li><p><strong>Zabbix Server</strong>：Zabbix Server 是 Zabbix 的核心组件，是所有配置信息、统计信息和操作数据的核心存储器。 它主要负责接收客户端发送的报告和信息，同时，所有配置、统计数据及配置操作数据均由其组织进行。</p></li><li><p><strong>Zabbix Database Storage</strong>：主要用于存储数据，所有配置信息和 Zabbix 收集到的数据都被存储在数据库中。常用的存储设备有 MySQL、Oracle 等。</p></li><li><p><strong>Zabbix Web 界面：</strong>这是 Zabbix 提供的 GUI 接口，通常（但不一定）与 Zabbix Server 运行在同一台物理机器上。</p></li><li><p><strong>Zabbix Proxy 代理服务器：</strong>这是一个可选组件，常用于分布监控环境中，代理 Server 可以替 Zabbix Server 收集性能和可用性数据，汇总后统一发往 Zabbix Server 端。</p></li><li><p><strong>Zabbix Agent 监控代理：</strong> Zabbix Agent 部署在被监控主机上，能够主动监控本地资源和应用程序，并负责收集数据发往 Zabbix Server 端或 Zabbix Proxy 端。从 zabbix 5 版本开始，zabbix_agent 分为 zabbix_agent 和 zabbix_agent2，zabbix_agent2 是第二个 agent 版本，功能更加强大，采用 go 语言编写，支持 zabbix_agent 所有功能。使用 zabbix_agent2 可监控 docker 容器、ceph、mysql、oracle、 redis等。</p></li></ul><h4 id="4-2-2-zabbix-进程介绍"><a href="#4-2-2-zabbix-进程介绍" class="headerlink" title="4.2.2 zabbix 进程介绍"></a>4.2.2 zabbix 进程介绍</h4><p>​    根据功能和用途，默认情况下 zabbix 包含 5 个进程，分别是 zabbix_agentd/zabbix_agent2、zabbix_get、zabbix_proxy、zabbix_sender、zabbix_server，另外还有一个 zabbix_java_gateway 是可选的功能，需要另外安装。下面分别介绍下它们各自的作用。</p><ul><li><p><code>**zabbix_agentd/zabbix_agent2**</code>： zabbix_agentd/agent2 是 Zabbix Agent 监控代理端守护进程，此进程收集客户端数据，例如cpu 负载、内存、硬盘、网络使用情况等，推荐使用 zabbix_agent2。</p></li><li><p><code>**zabbix_get**</code>： zabbix 提供的一个工具，通常在 Zabbix server 或者 Zabbix proxy 端执行用来获取远程客户端信息，这其实是 Zabbix server 去 Zabbix Agent 端拉取数据的过程，此工具主要用来进行用户排错。例如在 Zabbix server 端获取不到客户端的监控数据时，可以使用 zabbix_get 命令测试获取客户端数据来做故障排查。</p></li><li><p><strong>zabbix_sender：</strong>zabbix 提供的一个工具，用于发送数据给 Zabbix server 或者 Zabbix proxy，这其实是 Zabbix Agent 端主动推送监控数据到 Zabbix Server 端的过程，通常用于耗时比较长的检查或者有大量主机（千台以上）需要监控的场景。此时通过主动推送数据到 Zabbix server，可以在很大程度上减轻 Zabbix server 的压力和负载。</p></li><li><p><strong>zabbix_proxy：</strong>Zabbix Proxy 的代理守护进程。功能类似 Zabbix server，唯一不同的是它只是一个中转站，它需要把收集到的数据提交或者被提交到 Zabbix server上。</p></li><li><p><strong>zabbix_java_gateway</strong>：Zabbix 2.0 之后引入的一个功能。顾名思义：Java 网关，主要用来监控 JAVA 应用环境，类似 zabbix_agentd 进程。需要特别注意的是，它只能主动去推送数据，而不能等待 zabbix server或者 zabbix proxy 来拉取数据。它的数据最终会给到 zabbix server 或者 zabbix proxy 上。</p></li><li><p><code>**zabbix_server**</code><strong>：</strong>Zabbix server 是整个 Zabbix 系统的核心进程。其它进程 zabbix_agentd、zabbix_get、zabbix_sender、zabbix_proxy、zabbix_java_gateway 的数据最终都是提交到 Zabbix server 来统一进行处理。</p></li><li><p><strong>zabbix web service：</strong>Zabbix web service 是一个用来连接外部网站服务的进程。</p></li></ul><h3 id="4-3-Zabbix-优点和不足"><a href="#4-3-Zabbix-优点和不足" class="headerlink" title="4.3 Zabbix 优点和不足"></a>4.3 Zabbix 优点和不足</h3><p><strong>优点：</strong></p><ol><li><p><strong>开源性</strong>：Zabbix作为一个开源工具，意味着用户可以免费使用，并且拥有对软件进行二次开发的灵活性。</p></li><li><p><strong>数据采集能力</strong>：它支持多种数据收集方式，包括agent、SNMP、JMX和telnet等，还支持主动和被动模式的数据传输。用户还可以自定义插件来收集数据，这提供了高度的灵活性和适应性。</p></li><li><p><strong>高可用性</strong>：Zabbix server对设备性能要求低，支持proxy分布式监控，这使得它能够适应不同规模和需求的监控环境。</p></li><li><p><strong>监控能力</strong>：Zabbix能够监控各种网络参数，并提供灵活的通知机制，帮助运维人员快速定位并解决存在的问题。</p></li><li><p><strong>模板丰富</strong>：Zabbix自带多种监控模板，这简化了新设备的监控配置过程，加快了部署速度。</p></li><li><p><strong>自动发现与全面监控</strong>：Zabbix支持自动发现网络中的设备和服务，这减少了手动配置的工作量，并确保了监控覆盖的全面性。</p></li><li><p><strong>报警处理</strong>：它可以针对报警默认进行固定操作，减少人为操作失误的风险，同时降低人员成本。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**缺点：**</span><br></pre></td></tr></table></figure><ul><li><p><strong>性能瓶颈</strong>：当机器数量增加时，数据量的增大会导致数据库写入成为瓶颈。Zabbix官方指出单机上限为5000台设备，超过这个数量就需要增加proxy来分担负载</p></li><li><p><strong>数据延迟问题</strong>：在采用主动模式即server pull方式采集数据时，如果目标机器数量庞大，则可能出现任务积压和数据延迟的问题。</p></li><li><p><strong>数据库压力</strong>：所有数据都存在数据库里, 产生的数据据很大,瓶颈主要在数据库。</p></li></ul><h3 id="4-4-Zabbix功能"><a href="#4-4-Zabbix功能" class="headerlink" title="4.4 Zabbix功能"></a>4.4 Zabbix功能</h3><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/items" target="_blank" rel="noopener"><strong>数据采集</strong></a></p><ul><li><p>可用性和性能采集；</p></li><li><p>支持 SNMP（包括主动轮询和被动捕获）、IPMI、JMX、VMware 监控；</p></li><li><p>自定义检查；</p></li><li><p>按照自定义的时间间隔采集需要的数据；</p></li><li><p>通过 Server/Proxy 和 Agents 来执行数据采集。</p></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/triggers" target="_blank" rel="noopener"><strong>灵活的阈值定义</strong></a></p><ul><li>您可以定义非常灵活的告警阈值，称之为触发器，触发器从后端数据库获得参考值。</li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/notifications" target="_blank" rel="noopener"><strong>高度可配置化的告警</strong></a></p><ul><li><p>可以根据递增计划、接收者、媒介类型自定义发送告警通知；</p></li><li><p>使用宏变量可以使告警通知变得更加高效有益；</p></li><li><p>自动动作包含远程命令。</p></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/visualization/graphs/simple" target="_blank" rel="noopener"><strong>实时图形</strong></a></p><ul><li>使用内置图形功能可实以将监控项绘制成图形。</li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/web_monitoring" target="_blank" rel="noopener"><strong>Web 监控功能</strong></a></p><ul><li>Zabbix 可以追踪模拟鼠标在 Web 网站上的点击操作，来检查 Web 网站的功能和响应时间。</li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/visualization" target="_blank" rel="noopener"><strong>丰富的可视化选项</strong></a></p><ul><li>能够创建可以将多个监控项组合到单个视图中的自定义图形；</li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/installation/requirements#database_size" target="_blank" rel="noopener"><strong>历史数据存储</strong></a></p><ul><li><p>存储在数据库中的数据；</p></li><li><p>可配置的历史数据；</p></li><li><p>内置数据管理机制（housekeeping）。</p></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/hosts" target="_blank" rel="noopener"><strong>配置简单</strong></a></p><ul><li><p>将被监控设备添加为主机；</p></li><li><p>主机一旦添加到数据库中，就会采集主机数据用于监控；</p></li><li><p>将模板用于监控设备。</p></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/templates" target="_blank" rel="noopener"><strong>套用模板</strong></a></p><ul><li><p>在模板中分组检查；</p></li><li><p>模板可以关联其他模板，获得继承。</p></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/discovery" target="_blank" rel="noopener"><strong>网络发现</strong></a></p><ul><li><p>自动发现网络设备；</p></li><li><p>Zabbix Agent 发现设备后自动注册；</p></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/web_interface" target="_blank" rel="noopener"><strong>快捷的 Web 界面</strong></a></p><ul><li><p>基于 PHP 的 Web 前端；</p></li><li><p>可以从任何地方访问；</p></li><li><p>您可以定制自己的操作方式；</p></li><li><p>审计日志。</p></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/api" target="_blank" rel="noopener"><strong>Zabbix API</strong></a></p><ul><li>Zabbix API 为 Zabbix 提供可编程接口，用于批量操作、第三方软件集成和其他用途。</li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/distributed_monitoring" target="_blank" rel="noopener"><strong>适应更复杂的环境</strong></a></p><ul><li>使用 Zabbix Proxy 代理，可以轻松实现分布式远程监控。</li></ul><h3 id="4-5-zabbix-监控数据流程"><a href="#4-5-zabbix-监控数据流程" class="headerlink" title="4.5 zabbix 监控数据流程"></a>4.5 zabbix 监控数据流程</h3><p>​    首先，为了创建一个采集数据的<code>监控项</code>，您就必须先<code>创建主机</code>。其次，必须有一个监控项，然后创建触发器。最后，您必须有一个触发器来触发一个动作，这几个点构成了一个完整的数据流。因此，如果您想要收到 CPU load it too high on <em>Server X</em> 的告警，您必须首先为 <em>Server X</em> 创建一个主机条目，其次创建一个用于监视其 CPU 的监控项，最后创建一个触发器，用来触发 CPU is too high 这个动作，并将其发送到您的邮箱里。虽然这些步骤看起来很繁琐，但是使用模板的话，其实并不复杂。也正是由于这种设计，使得 Zabbix 的配置变得更加灵活易用。</p><h4 id="4-5-1-Zabbix-核心概念"><a href="#4-5-1-Zabbix-核心概念" class="headerlink" title="4.5.1 Zabbix 核心概念"></a>4.5.1 Zabbix 核心概念</h4><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/1593259517290.png%23id=cpWNQ&originHeight=530&originWidth=786&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="img"></p><p><strong>主机（host）</strong></p><p>你想要监控的联网设备，有IP/DNS。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/hosts" target="_blank" rel="noopener"><strong><em>主机组（host group)</em></strong></a></p><p>主机的逻辑组；可能包含主机和模板。一个主机组里的主机和模板之间并没有任何直接的关联。通常在给不同用户组的主机分配权限时候使用主机组。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/items" target="_blank" rel="noopener"><strong><em>监控项（item）</em></strong></a></p><p>你想要接收的主机的特定数据，一个度量/指标数据。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/items/item#item_value_preprocessing" target="_blank" rel="noopener"><strong><em>值预处理（value preprocessing）</em></strong></a></p><p>转化/预处理接收到的指标数据* 存入数据库之前</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/triggers" target="_blank" rel="noopener">触发器（trigger）</a></p><p>一个被用于定义问题阈值和“评估”监控项接收到的数据的逻辑表达式</p><p>当接收到的数据高于阈值时，触发器从“OK”变成“Problem”状态。当接收到的数据低于阈值时，触发器保留/返回“OK”的状态。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/events" target="_blank" rel="noopener"><strong><em>事件（event）</em></strong></a></p><p>一次发生的需要注意的事情，例如触发器状态改变、发现/监控代理自动注册</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/triggers/event_tags" target="_blank" rel="noopener"><strong><em>事件标签（event tag）</em></strong></a></p><p>提前设置的事件标记*可以被用于事件关联，权限细化设置等。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/event_correlation" target="_blank" rel="noopener"><strong><em>事件关联（event correlation）</em></strong></a></p><p>自动灵活的、精确的关联问题和解决方案</p><p>比如说，你可以定义触发器A告警的异常可以由触发器B解决，触发器B可能采用完全不同的数据采集方式。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/web_interface/frontend_sections/monitoring/problems" target="_blank" rel="noopener"><strong><em>异常（problems）</em></strong></a></p><p>一个处在“异常”状态的触发器</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/acknowledges#updating_problems" target="_blank" rel="noopener"><strong><em>异常更新（problem update）</em></strong></a></p><p>Zabbix提供的问题管理选项，例如添加评论、确认异常、改变问题级别或者手动关闭等。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/notifications/action" target="_blank" rel="noopener"><strong><em>动作（action）</em></strong></a></p><p>预先定义的应对事件的操作</p><p>一个动作由操作(例如发出通知)和条件(什么时间进行操作)组成</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/notifications/action/escalations" target="_blank" rel="noopener"><strong><em>升级（escalation）</em></strong></a></p><p>一个在动作内执行操作的自定义方式; 发送通知/执行远程命令的顺序安排。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/notifications/media" target="_blank" rel="noopener"><strong><em>报警媒介（media）</em></strong></a></p><p>发送告警通知的方式；传送途径</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/notifications/action/operation/message" target="_blank" rel="noopener"><strong><em>通知（notification）</em></strong></a></p><p>关于事件的信心，将通过选设定的媒介途径发送给用户。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/notifications/action/operation/remote_command" target="_blank" rel="noopener"><strong><em>远程命令（remote command）</em></strong></a></p><p>一个预定义好的，满足特定条件的情况下，可以在被监控主机上自动执行的命令。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/templates" target="_blank" rel="noopener"><strong><em>模版（template）</em></strong></a></p><p>一组可以被应用到一个或多个主机上的实体（监控项，触发器，图形，聚合图形，应用，LLD，Web场景）的集合</p><p>模版的应用使得主机上的监控任务部署快捷方便；也可以使监控任务的批量修改更加简单。模版是直接关联到每台单独的主机上。</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/config/items/applications" target="_blank" rel="noopener"><strong><em>应用（application）</em></strong></a></p><p>一组监控项组成的逻辑分组</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/web_monitoring" target="_blank" rel="noopener"><strong><em>Web场景（web scenario）</em></strong></a></p><p>检查网站可浏览性的一个或多个HTTP请求</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/introduction/overview#architecture" target="_blank" rel="noopener"><strong><em>前端（frontend)</em></strong></a></p><p>Zabbix提供的web界面</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/api" target="_blank" rel="noopener"><strong><em>Zabbix API</em></strong></a></p><ul><li><em>Zabbix API允许用户使用JSON RPC协议来创建、更新和获取Zabbix对象（如主机、监控项、图形和其他）信息或者执行任何其他的自定义的任务</em></li></ul><p><a href="https://www.zabbix.com/documentation/5.0/manual/concepts/server" target="_blank" rel="noopener"><strong><em>Zabbix server</em></strong></a></p><p>Zabbix监控的核心程序，主要功能是与Zabbix proxies和Agents进行交互、触发器计算、发送告警通知；并将数据集中保存等</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/concepts/agent" target="_blank" rel="noopener"><strong><em>Zabbix agent</em></strong></a></p><p>部署在监控对象上的，能够主动监控本地资源和应用的程序</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/concepts/proxy" target="_blank" rel="noopener"><strong><em>Zabbix proxy</em></strong></a></p><p>一个帮助Zabbix Server收集数据，分担Zabbix Server的负载的程序</p><p><a href="https://www.zabbix.com/documentation/5.0/manual/encryption" target="_blank" rel="noopener"><strong><em>加密（encryption）</em></strong></a></p><p>支持Zabbix组建之间的加密通讯(server, proxy, agent, zabbix_sender 和 zabbix_get 程序)使用TLS（Transport Layer Security ）协议。</p><h3 id="5、Zabbix-常用监控架构"><a href="#5、Zabbix-常用监控架构" class="headerlink" title="5、Zabbix 常用监控架构"></a>5、Zabbix 常用监控架构</h3><ol><li>分布式监控 (企业常用) server-proxy-agent</li></ol><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/image-20210609232741617.png%23id=VOMdd&originHeight=763&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="img"></p><ol><li>server-anget(点对点监控)</li></ol><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/image-20210609232940841.png%23id=xN38z&originHeight=599&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="img"></p><p><strong>监控报警流程图：</strong></p><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/1593259525914.png%23id=BFcJX&originHeight=397&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="img"></p><h3 id="6、Zabbix-监控系统监控对象"><a href="#6、Zabbix-监控系统监控对象" class="headerlink" title="6、Zabbix 监控系统监控对象"></a>6、Zabbix 监控系统监控对象</h3><ul><li><p>数据库：  MySQL,MariaDB,Oracle,SQL Server    agent</p></li><li><p>应用软件：Nginx,Apache,PHP,Tomcat           agent</p></li></ul><hr><ul><li><p>集群：    LVS,Keepalived,HAproxy,RHCS,F5     agent</p></li><li><p>虚拟化：  VMware,KVM,XEN ,docker,k8s        agent</p></li><li><p>操作系统：Linux,Unix,Windows性能参数       agent</p></li></ul><hr><ul><li><p>硬件： 服务器，存储，网络设备                IPMI</p></li><li><p>网络： 网络环境（内网环境，外网环境）        SNMP</p></li></ul><hr><h4 id="6-1-Zabbix监控方式"><a href="#6-1-Zabbix监控方式" class="headerlink" title="6.1 Zabbix监控方式"></a>6.1 Zabbix监控方式</h4><p><strong>被动模式</strong></p><ul><li>被动检测： <strong>server向agent请求获取配置的各监控项相关的数据</strong>，agent接收请求、获取数据并响应给server； 适合对时效性要求较高的监控项，因为服务器可以随时请求数据。  </li></ul><p><strong>主动模式</strong></p><ul><li>主动检测：<strong>agent向server请求与自己相关监控项配置</strong>，主动地将server配置的监控项相关的数据发送给server； 减少Zabbix服务器的负载，特别是在大量监控项时，避免了服务器对每个监控项进行轮询。主动监控能极大节约监控server的资源。</li></ul><h3 id="7、安装和配置-Zabbix-服务"><a href="#7、安装和配置-Zabbix-服务" class="headerlink" title="7、安装和配置 Zabbix 服务"></a>7、安装和配置 Zabbix 服务</h3><p>服务器配置要求：<a href="https://www.zabbix.com/documentation/6.0/zh/manual/installation/requirements" target="_blank" rel="noopener">2 安装要求 (zabbix.com)</a></p><h4 id="7-1-实验准备"><a href="#7-1-实验准备" class="headerlink" title="7.1 实验准备"></a>7.1 实验准备</h4><p>Centos7.9 系统服务器3台、 一台作为监控服务器， 两台台作为被监控节点， 配置好yum源、 防火墙关闭、 各节点时钟服务同步、 各节点之间可以通过主机名互相通信。</p><p><strong>1. 所有机器关闭防火墙和selinux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ setenforing 0 </span><br><span class="line">$ sed -i <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/'</span> /etc/selinux/config </span><br><span class="line">$ systemctl <span class="built_in">disable</span> --now firewalld.service</span><br></pre></td></tr></table></figure><p><strong>2. 根据架构图，实验基本设置如下：</strong></p><table><thead><tr><th>机器名称</th><th>IP配置</th><th>服务角色</th><th>备注</th></tr></thead><tbody><tr><td>zabbix-server</td><td>192.168.153.147</td><td>zabbix-server</td><td>开启</td></tr><tr><td>zabbix-node1</td><td>192.168.153.178</td><td>zabbix-agent-node1</td><td>开启</td></tr><tr><td>zabbix-node2</td><td>192.168.153.179</td><td>zabbix-agent-node2</td><td>开启</td></tr></tbody></table><h4 id="7-2-安装-Zabbix-server端"><a href="#7-2-安装-Zabbix-server端" class="headerlink" title="7.2 安装 Zabbix-server端"></a>7.2 安装 Zabbix-server端</h4><p><strong>安装NGINX</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># vim /etc/yum.repos.d/nginx.repo</span></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install -y nginx</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl enable --now nginx</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl status nginx</span></span><br></pre></td></tr></table></figure><p><strong>安装PHP</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装epel源</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># wget -O /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装webtatic 扩展源，安装PHP服务时需要</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install -y https://mirror.webtatic.com/yum/el7/epel-release.rpm</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install -y https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装PHP服务</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install php72w-cli php72w-fpm php72w-gd php72w-mbstring php72w-bcmath php72w-xml php72w-ldap php72w-mysqlnd -y</span></span><br></pre></td></tr></table></figure><p><strong>修改nginx配置文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@zabbix-server ~]<span class="comment"># vim /etc/nginx/conf.d/zabbix.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  root /app/zabbix;</span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.php;</span><br><span class="line">  &#125;</span><br><span class="line"> location ~ \.php$ &#123;</span><br><span class="line">   fastcgi_pass  127.0.0.1:9000;</span><br><span class="line">   fastcgi_index index.php; </span><br><span class="line">   fastcgi_param SCRIPT_FILENAME   <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">   include fastcgi_params;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 参数解释：</span></span><br><span class="line">  <span class="variable">$document_root</span>是Nginx的根目录（这里为 /app/zabbix），</span><br><span class="line">  <span class="variable">$fastcgi_script_name</span> 是请求的脚本路径和文件名。该指令将这两个变量组合，构成完整的 PHP 文件路径供 PHP-FPM 使用。例如，如果请求 /index.php，那么 SCRIPT_FILENAME 将是 /app/zabbix/index.php。</span><br><span class="line"><span class="comment"># 创建站点目录</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># mkdir /app/zabbix  -p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置文件是否正确</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载nginx配置文件</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemcreload nginx</span></span><br></pre></td></tr></table></figure><p><strong>修改PHP的服务的启动用户和用户组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行替换</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># sed -ri  '/^(user|group)/s#apache#nginx#g' /etc/php-fpm.d/www.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行检查</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># egrep '^(user|group)' /etc/php-fpm.d/www.conf</span></span><br><span class="line">user = nginx</span><br><span class="line">group = nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试文件</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># vim /app/zabbix/info.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl enable --now php-fpm</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl status php-fpm</span></span><br></pre></td></tr></table></figure><p><strong>数据库部署</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加数据库源</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># vim  /etc/yum.repos.d/mariadb.repo</span></span><br><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line">baseurl = http://mirrors.aliyun.com/mariadb/yum/10.5/centos7-amd64/</span><br><span class="line">gpgkey = http://mirrors.aliyun.com/mariadb/yum/RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck = 1</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装数据库</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install -y mariadb-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否安装成功</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># rpm -qa | grep -i mariadb</span></span><br><span class="line">MariaDB-compat-10.5.24-1.el7.centos.x86_64</span><br><span class="line">MariaDB-client-10.5.24-1.el7.centos.x86_64</span><br><span class="line">MariaDB-server-10.5.24-1.el7.centos.x86_64</span><br><span class="line">MariaDB-common-10.5.24-1.el7.centos.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动数据库</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl enable --now mariadb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库基本设置</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># mysql_secure_installation</span></span><br><span class="line">mysql_secure_installation是一个用于设置MySQL服务器安全选项的脚本。它可以帮助你设置root密码、删除匿名用户、禁止远程root登录等，以提高MySQL服务器的安全性。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建zabbix用户及数据库</span></span><br><span class="line">mysql&gt; create database zabbix charset utf8 collate utf8_bin;</span><br><span class="line"><span class="comment">#创建zabbix用户</span></span><br><span class="line">mysql&gt; grant all on zabbix.* to <span class="string">'zabbix'</span>@<span class="string">'localhost'</span> identified by <span class="string">'zabbix'</span>; </span><br><span class="line"><span class="comment"># 如果数据库与zbx,php不在一起</span></span><br><span class="line"><span class="comment"># grant all on zabbix.* to 'zabbix'@'172.16.1.%' identified by 'zabbix' ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p><strong>zabbix server 配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压安装包</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># tar xf zabbix-6.0.26.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># cd zabbix-6.0.26/database/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入zabbix 相关数据和表结构</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># mysql -uroot -pabc123  zabbix &lt; schema.sql </span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># mysql -uroot -pabc123  zabbix &lt; images.sql </span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># mysql -uroot -pabc123  zabbix &lt; data.sql </span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># mysql -uroot -pabc123  zabbix &lt; double.sql </span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># mysql -uroot -pabc123  zabbix &lt; history_pk_prepare.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sql文件解释</span></span><br><span class="line">  schema.sql 文件通常包含数据库的表结构定义。它会创建 Zabbix 所需的所有数据库表、视图、索引等。</span><br><span class="line">  images.sql 文件用于导入 Zabbix 系统内置的图片和图标，这些图片通常用于仪表板、监控界面和报告生成中。</span><br><span class="line">  data.sql 文件用于导入 Zabbix 的初始数据，包含一些默认的配置、模板、预定义的监控项等。</span><br><span class="line">  double.sql 调整数据表的存储类型或修改数据结构。以支持更精确的数据存储（如历史数据或监控值）。</span><br><span class="line">  history_pk_prepare.sql 用于准备历史数据的主键设置。Zabbix系统会记录大量的历史数据，此文件可能用于优化历史数据表的主键和索引，以提高查询性能。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装编译需要的基础环境</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install -y mysql-devel pcre-devel openssl-devel zlib-devel libxml2-devel net-snmp-devel  net-snmp libssh2-devel OpenIPMI-devel libevent-devel openldap-devel   libcurl-devel gcc gcc-c++</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装zabbix 6.0</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># cd zabbix-6.0.26</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># ./configure --sysconfdir=/etc/zabbix/ --enable-server --with-mysql --with-net-snmp --with-libxml2 --with-ssh2 --with-openipmi --with-zlib --with-libpthread --with-libevent --with-openssl --with-ldap --with-libcurl --with-libpcre</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装zabbix server</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># make install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否安装成功</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># echo $?</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># zabbix_server --version</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写 zabbix server systemd启动配置文件</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># cat /usr/lib/systemd/system/zabbix_server.service</span></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Zabbix Server with MySQL DB</span><br><span class="line">After=syslog.target network.target mysqld.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/sbin/zabbix_server -f</span><br><span class="line">User=zabbix</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载systemd启动文件</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加zabbix用户</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># useradd -s /sbin/nologin  zabbix</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改zabbix_server配置文件连接数据库地址</span></span><br><span class="line">[root@zabbix-server zabbix-6.0.26]<span class="comment"># egrep  -n -i "^DB" /etc/zabbix/zabbix_server.conf</span></span><br><span class="line">87:DBHost=localhost</span><br><span class="line">99:DBName=zabbix</span><br><span class="line">115:DBUser=zabbix</span><br><span class="line">124:DBPassword=zabbix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并且检查 zabbix server </span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl enable --now  zabbix_server</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl status zabbix_server</span></span><br></pre></td></tr></table></figure><p><strong>部署前端代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换前端代码目录</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># cd zabbix-6.0.26</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝前端代码</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># cp -r ui/* /app/zabbix/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改属主和数组</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># chown -R nginx.nginx /app/zabbix/</span></span><br></pre></td></tr></table></figure><h4 id="7-3-测试访问"><a href="#7-3-测试访问" class="headerlink" title="7.3 测试访问"></a>7.3 测试访问</h4><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425165826345.png" alt="img"></p><p>游览器输入： <a href="http://zabbix.tanke.love" target="_blank" rel="noopener">http://zabbix.tanke.love</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425165908837.png" alt="img"></p><p><strong>修改php配置文件，解决报错：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件参数</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># egrep -n '^(max_.*_time|post_max)'   /etc/php.ini</span></span><br><span class="line">/etc/php.ini:368:max_execution_time = 300  <span class="comment"># 设置 PHP 脚本的最大执行时间，防止 PHP 脚本运行时间过长而导致服务器资源耗尽或阻塞。</span></span><br><span class="line">/etc/php.ini:378:max_input_time = 300  <span class="comment"># 设置 PHP 脚本解析输入数据（例如 POST 和 GET 数据、文件上传等）的最大时间，单位为 秒。这个时间限制只影响解析输入数据的时间，而不影响脚本的整体执行时间。</span></span><br><span class="line">/etc/php.ini:656:post_max_size = 80M  <span class="comment"># 设置 PHP 表单提交（POST 请求）允许的最大数据大小，包括文件上传、表单数据等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动 PHP</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl restart php-fpm</span></span><br></pre></td></tr></table></figure><p><strong>修改时区</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425170026975.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425170039723.png" alt="img"></p><p>文件位置：<code>/app/code/zbx/conf/zabbix.conf.php</code></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425170059876.png" alt="img"></p><p><strong>用户名：Admin<br>**</strong>密码：zabbix**</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425170123419.png" alt="img"></p><p><strong>此故障表示没有安装zabbix-agnet或者客户端宕机</strong></p><p><strong>zabbix server 自我测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装zabbix-agent安装源</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># rpm -Uvh https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/6.0/rhel/7/x86_64/zabbix-release-6.0-1.el7.noarch.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装zabbix-agent2 </span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install -y zabbix-agent2.x86_64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改zabbix-agent2 配置文件参数</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># grep '^[a-Z]' /etc/zabbix/zabbix_agent2.conf</span></span><br><span class="line">PidFile=/run/zabbix/zabbix_agent2.pid</span><br><span class="line">LogFile=/var/<span class="built_in">log</span>/zabbix/zabbix_agent2.log</span><br><span class="line">LogFileSize=0 <span class="comment"># 指定日志文件的最大大小。默认不限制</span></span><br><span class="line">Server=127.0.0.1  <span class="comment"># zabbix-server所在的主机IP，被动模式</span></span><br><span class="line">ServerActive=127.0.0.1 <span class="comment"># zabbix-server所在的主机IP,主动模式</span></span><br><span class="line">Hostname=Zabbix server  <span class="comment"># 指定 Zabbix Agent 运行所在的主机名称</span></span><br><span class="line">Include=/etc/zabbix/zabbix_agent2.d/*.conf  <span class="comment"># 自定义监控项配置路径 </span></span><br><span class="line">Include=./zabbix_agent2.d/plugins.d/*.conf  <span class="comment"># 自带插件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动zabbix-agent2</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># systemctl enable --now zabbix-agent2</span></span><br></pre></td></tr></table></figure><p><strong>再次访问web界面</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425170504277.png" alt="img"></p><h4 id="7-4-zabbix-主机图形乱码解决"><a href="#7-4-zabbix-主机图形乱码解决" class="headerlink" title="7.4 zabbix 主机图形乱码解决"></a>7.4 zabbix 主机图形乱码解决</h4><p>原因：zabbix显示中文的字体有问题，导致显示中文异常。<br>解决：把zabbix中文字体替换即可。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425174855188.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425174925105.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换值zabbix 字体目录</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># cd /app/zabbix/assets/fonts/</span></span><br><span class="line">[root@zabbix-server fonts]<span class="comment"># ls</span></span><br><span class="line">DejaVuSans.ttf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份原有字体</span></span><br><span class="line">[root@zabbix-server fonts]<span class="comment"># cp DejaVuSans.ttf&#123;,.bak&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新的字体</span></span><br><span class="line">[root@zabbix-server fonts]<span class="comment"># ls msyh.ttc   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名新字体，不需要重新启动nginx</span></span><br><span class="line">[root@zabbix-server fonts]<span class="comment"># mv msyh.ttc DejaVuSans.ttf</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240425175627776.png" alt="img"></p><p><strong>注意：修改成新的字体后，但是仍然有些许字段没有改变，生产环境建议使用英文版的。</strong></p><h3 id="8、配置文件详解"><a href="#8、配置文件详解" class="headerlink" title="8、配置文件详解"></a>8、配置文件详解</h3><p><strong>zabbix_server主配置文件详解</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@zabbix-server ~]<span class="comment"># grep "^[a-Z]" /etc/zabbix/zabbix_server.conf</span></span><br><span class="line">ListenPort=10051  <span class="comment"># Zabbix服务器监听的端口号，默认为10051</span></span><br><span class="line">LogFile=/tmp/zabbix_server.log  <span class="comment"># Zabbix服务器日志文件的路径</span></span><br><span class="line">DBHost=localhost  <span class="comment"># Zabbix服务器连接的数据库主机地址</span></span><br><span class="line">DBName=zabbix  <span class="comment"># Zabbix服务器连接的数据库名称</span></span><br><span class="line">DBUser=zabbix  <span class="comment"># Zabbix服务器连接的数据库用户名</span></span><br><span class="line">DBPassword=zabbix  <span class="comment"># Zabbix服务器连接的数据库密码</span></span><br><span class="line">Timeout=4  <span class="comment"># Zabbix服务器的超时时间</span></span><br><span class="line">AlertScriptsPath=<span class="variable">$&#123;datadir&#125;</span>/zabbix/alertscripts  <span class="comment"># Zabbix服务器报警脚本的存放路径</span></span><br><span class="line">LogSlowQueries=3000   <span class="comment"># 记录慢查询日志的阈值时间</span></span><br></pre></td></tr></table></figure><h3 id="9、zabbix-agent版本差异解释-了解"><a href="#9、zabbix-agent版本差异解释-了解" class="headerlink" title="9、zabbix agent版本差异解释(了解)"></a>9、zabbix agent版本差异解释(了解)</h3><p><strong>zabbix-agent</strong>：</p><ul><li>C语言开发，基于传统的单线程设计，使用单个进程来处理所有的数据收集。</li></ul><p><strong>zabbix-agent2：</strong></p><ul><li>GO语言和C语言混合开发，基于多线程设计，采用了更先进的异步架构，能够更高效地处理并发请求和大量数据。</li></ul><h3 id="10、监控任意主机"><a href="#10、监控任意主机" class="headerlink" title="10、监控任意主机"></a>10、监控任意主机</h3><p>监控步骤：</p><ul><li><p>被监控端安装客户端工具，并修改配置文件中，server端的主机IP地址。</p></li><li><p>启动客户端工具，并且查看服务是否正常启动。<code>(ps netstat)</code></p></li><li><p>服务端 web界面进行配置。</p></li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426113359441.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426114257355.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426114606918.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426141751419.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426142031899.png" alt="img"></p><h4 id="10-1-快速添加新的主机"><a href="#10-1-快速添加新的主机" class="headerlink" title="10.1 快速添加新的主机"></a>10.1 快速添加新的主机</h4><ul><li><p>被监控端安装客户端工具zabbix-agent</p></li><li><p>通过web界面配置过的被监控主机进行克隆。</p></li></ul><p><strong>流程图如下：</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426154530806.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426154553230.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426154755301.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240426154922536.png" alt="img"></p><h3 id="11、主机群组使用"><a href="#11、主机群组使用" class="headerlink" title="11、主机群组使用"></a>11、主机群组使用</h3><p>​    将多个<strong>相同服务</strong>的主机，归纳一个主机群组，该主机群组可针对服务设定相同的监控项或者自定义监控项，比如多个nginx，他们所监控的指标一致，可以为它们专门创建一个主机群组，例如web-servers。实现统一，方便后期管理。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504215946168.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504220029956.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504220102197.png" alt="img"></p><h3 id="12、自定义监控模版"><a href="#12、自定义监控模版" class="headerlink" title="12、自定义监控模版"></a>12、自定义监控模版</h3><h4 id="12-1-boot分区剩余容量监控"><a href="#12-1-boot分区剩余容量监控" class="headerlink" title="12.1 boot分区剩余容量监控"></a>12.1 boot分区剩余容量监控</h4><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504220350681.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504220410594.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504220517123.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504220609638.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222123795.png" alt="img"></p><p>vfs.fs.size[fs,<mode>] 用于查询或设置虚拟文件系统 (VFS) 中的文件系统（<code>fs</code>）的大小。<code>&lt;mode&gt;</code> 参数指定了如何计算和显示文件系统的大小。  </mode></p><ul><li><p><code>fs</code> 是文件系统的具体实例。一个具体的挂载点，如 <code>/home</code> 或者 <code>/boot等等；</code></p></li><li><p><code>&lt;mode&gt;</code> 参数决定了如何计算文件系统的大小。通常，以下是一些常见的模式：</p></li><li><ul><li>total: 返回文件系统的总大小，包括所有已使用的和未使用的空间。</li><li>used: 返回文件系统中已经使用的空间大小。</li><li>free: 返回文件系统中剩余的可用空间大小。</li><li>available: 返回文件系统中可以分配给普通用户的空间。  </li></ul></li></ul><ul><li><p><strong>历史数据</strong>和<strong>趋势数据</strong>是Zabbix中存储收集到的数据两种方式：</p></li><li><p><strong>历史数据是指Zabbix系统针对每个监控项目在每次采集时所收集到的数据，这个数据保存在Zabbix系统数据库的历史表中。</strong>因为每次采集到的数据都保存在历史表中，所以如果监控项目的更新间隔越小，则在固定时间内保存到历史表中的数据就越多。例如，如果每个监控项目的更新间隔是30秒，那么两个小时该监控项目在Zabbix数据库的历史表中就会产生240条记录，一天就会产生2880条记录。虽然对于只监控一个项目或少量项目的系统来说，这些记录可能并不显著，但对于监控大量项目或需要长时间保存数据的系统来说，历史数据可能会占用大量的存储空间，并对数据库造成较大的负载压力。常见的历史数据表如下：</p></li><li><ul><li><code>**history**</code> <strong>表</strong>：用于存放整数类型的数据，例如 CPU 使用率（以百分比表示）。</li><li><code>**history_uint**</code> <strong>表</strong>：用于存放无符号整数类型的数据，适合存储不会出现负值的监控数据。</li><li><code>**history_str**</code> <strong>表</strong>：用于存放字符串类型的数据，例如日志信息或其他文本类型的监控项。</li><li><code>**history_text**</code> <strong>表</strong>：用于存放长文本数据，适合存储大量文本数据（例如完整的日志行）。</li><li><code>**history_log**</code> <strong>表</strong>：专门用于存储日志文件的监控数据。</li><li>每个表的字段通常包括 <code>itemid</code>、<code>clock</code>、<code>value</code>、<code>ns</code> 等：</li></ul></li><li><ul><li><ul><li><code>itemid</code>：监控项的唯一标识符。</li><li><code>clock</code>：时间戳，记录数据采集的具体时间（以秒为单位）。</li><li><code>value</code>：具体的监控项值。</li><li><code>ns</code>：纳秒级的时间戳，确保数据在同一秒内的精确排序。</li></ul></li></ul></li></ul><ul><li><p>趋势数据则是<strong>按小时统计计算后的平均数据</strong>，它是一种Zabbix内建的历史数据压缩机制。趋势数据可以用来存储数字类型监控项的每小时的最小值、最大值、平均值和记录数量。由于趋势数据是计算后的汇总数据，因此其数量相对于历史数据要少得多，同时其保存的时间通常也比历史数据要长。趋势数据通常用于生成图表或报告，以便用户能够更直观地了解监控项目的长期趋势和变化。常见的表如下：</p></li><li><ul><li><code>**trends**</code> 表：用于存储整数类型的数据的趋势。</li><li><code>**trends_uint**</code> 表：用于存储无符号整数类型的数据的趋势。</li><li>趋势数据表存储格式：每个趋势表的字段通常包括 <code>itemid</code>、<code>clock</code>、<code>num</code>、<code>value_min</code>、<code>value_avg</code>、<code>value_max</code>：</li></ul></li><li><ul><li><ul><li><code>itemid</code>：监控项的唯一标识符。</li><li><code>clock</code>：时间戳，表示数据对应的时间段（通常是小时级别）。</li><li><code>num</code>：在该时间段内的数据样本数量。</li><li><code>value_min</code>：该时间段内的最小值。</li><li><code>value_avg</code>：该时间段内的平均值。</li><li><code>value_max</code>：该时间段内的最大值。</li></ul></li></ul></li></ul><p><strong>强烈建议将历史数据保留时长设置得尽可能的小。这么做可以让数据库不会因存储了大量的历史数据，导致超负荷运行。可以选择长时间的保留趋势数据，来替代长期需要的历史数据。例如：设置成保留14天历史数据和5年的趋势数据。</strong></p><p><strong>创建图形</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222331047.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222347806.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222541298.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222603463.png" alt="img"></p><p><strong>添加主机</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222701746.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222723507.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504222947897.png" alt="img"></p><p><strong>查看监控指标</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504223147777.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504223239069.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504223314247.png" alt="img"></p><p><strong>或者：</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240504224047878.png" alt="img"></p><p><strong>测试监控数据变化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 被监控端boot分区压测</span></span><br><span class="line">[root@test01 boot]<span class="comment"># dd if=/dev/zero of=/boot/1.txt bs=1M count=100</span></span><br><span class="line">[root@test01 boot]<span class="comment"># dd if=/dev/zero of=/boot/1.txt bs=1M count=50</span></span><br><span class="line">[root@test01 boot]<span class="comment"># dd if=/dev/zero of=/boot/1.txt bs=1M count=20</span></span><br><span class="line">[root@test01 boot]<span class="comment"># rm -rf /boot/1.txt</span></span><br></pre></td></tr></table></figure><p>被监控端压测完成以后，回到监控面板查看图形</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042258623.png" alt="img"></p><h4 id="12-2-网卡出入流量监控"><a href="#12-2-网卡出入流量监控" class="headerlink" title="12.2 网卡出入流量监控"></a>12.2 网卡出入流量监控</h4><h5 id="12-2-1-ens33网卡进入流量监控"><a href="#12-2-1-ens33网卡进入流量监控" class="headerlink" title="12.2.1 ens33网卡进入流量监控"></a>12.2.1 ens33网卡进入流量监控</h5><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042305206.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042306218.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042325915.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042318001.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042326553.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042326789.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042327196.png" alt="img"></p><p> <strong>net.if.in[if,<mode>]</mode></strong>是一个用于监控网络接口输入流量的键值（key）。这里的 <code>ens33</code> 是网络接口的名称。<code>net.if.in[ens33]</code> 键值会返回网络接口 <code>ens33</code> 上接收到的字节总数。</p><ul><li><p><code>if</code> 是网络接口的具体实例，表示我们希望监控的网络接口。  </p></li><li><p><code>&lt;mode&gt;</code> 参数决定了如何计算或显示输入的数据流量。常见的模式如下：</p></li><li><ul><li>bytes: 返回通过该网络接口接收到的数据量（以字节为单位）。</li><li>packets: 返回通过该网络接口接收到的数据包数量。</li><li>errors: 返回接收到的数据包中发生的错误数量。</li><li>dropped: 返回接收到的数据包中被丢弃的数量。</li></ul></li></ul><h5 id="12-2-2-ens33网卡出去流量监控"><a href="#12-2-2-ens33网卡出去流量监控" class="headerlink" title="12.2.2 ens33网卡出去流量监控"></a>12.2.2 ens33网卡出去流量监控</h5><p>选择配置–&gt;模版–&gt;监控项</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042329048.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042330046.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042331004.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042332757.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042333704.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042333338.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405042334904.png" alt="img"></p><h4 id="12-3-监控服务端口"><a href="#12-3-监控服务端口" class="headerlink" title="12.3 监控服务端口"></a>12.3 监控服务端口</h4><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062231966.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062232368.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062235452.png" alt="img"></p><p><strong>创建图形</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062236813.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062236319.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062237513.png" alt="img"></p><p><code>net.tcp.service[service,&lt;ip&gt;,&lt;port&gt;]</code> 是一个用于检查TCP服务是否在某个端口上运行的键值（key）。这个键值会尝试与指定的端口建立TCP连接，并检查连接是否成功。如果连接成功，则意味着该服务在该端口上正在运行。</p><ul><li><p><code>service</code> 指的是具体的 TCP 服务（如 Web 服务、FTP 服务、数据库服务等），此参数用于标识所监控的服务类型。  </p></li><li><p><code>&lt;ip&gt;</code> 参数代表 TCP 服务所绑定的 IP 地址。它标识了该服务所在的主机或服务器的 IP 地址。  </p></li><li><p><code>&lt;port&gt;</code> 参数代表该 TCP 服务所监听的端口号。每个服务都通过特定的端口号来区分其他服务。例如，HTTP 服务通常运行在端口80 。</p></li><li><ul><li><code>net.tcp.service[http,192.168.174.11,80]</code>: 监控或查询运行在 IP 地址 <code>192.168.174.11</code> 上端口 <code>80</code> 的 HTTP 服务的状态。</li><li><code>net.tcp.service[ftp,10.96.74.22,21]</code>: 监控或查询运行在 IP 地址 <code>10.96.74.22</code> 上端口 <code>21</code> 的 FTP 服务的状态。</li></ul></li></ul><h5 id="12-2-3监控网卡的上下流量总和"><a href="#12-2-3监控网卡的上下流量总和" class="headerlink" title="12.2.3监控网卡的上下流量总和"></a>12.2.3<code>监控网卡的上下流量总和</code></h5><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062304579.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062304730.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062306030.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062308725.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062308182.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062309394.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062309327.png" alt="img"></p><h4 id="12-4-监控系统进程数量"><a href="#12-4-监控系统进程数量" class="headerlink" title="12.4 监控系统进程数量"></a>12.4 监控系统进程数量</h4><ol><li>系统总进程数量</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062242954.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062243502.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062244134.png" alt="img"></p><p><strong>创建监控项图形</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062246411.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062247689.png" alt="img"></p><p><code>proc.num</code> 是一个用于监控进程数量的键值（key）。它允许你根据进程名称、用户、状态、命令行参数和区域（在容器化环境中）来过滤和计数进程。</p><p>键值 <code>proc.num[&lt;name&gt;,&lt;user&gt;,&lt;state&gt;,&lt;cmdline&gt;,&lt;zone&gt;]</code> 的参数是可选的，你可以根据需要包含或省略它们。以下是这些参数的说明：</p><ul><li><p><code>&lt;name&gt;</code>：进程的名称或名称模式。可以使用通配符（如 <code>*</code>）来匹配多个进程。</p></li><li><p><code>&lt;user&gt;</code>：运行进程的用户名。</p></li><li><p><code>&lt;state&gt;</code>：进程的状态。可以是 <code>Z</code>（僵尸）、<code>R</code>（运行）、<code>S</code>（睡眠）、<code>T</code>（停止）或 <code>D</code>（不可中断的睡眠）。</p></li><li><p><code>&lt;cmdline&gt;</code>：进程的命令行参数。这是一个正则表达式，用于匹配进程的完整命令行。</p></li><li><p><code>&lt;zone&gt;</code>：在容器化环境中，这个参数可以用来指定容器或区域。</p></li></ul><p>如果不提供某个参数，那么Zabbix将不会根据该参数进行过滤。例如，如果你只提供进程名称，那么Zabbix将计算具有该名称的所有进程的数量，不考虑其他参数。</p><p><code>proc.num[mysql]</code>计算名为 <code>mysql</code> 的进程数量。</p><p><code>proc.num[,nginx]</code>计算用户 <code>nginx</code> 运行的进程数量。</p><ol><li>运行中的进程数量</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062250570.png" alt="img"></p><ol><li>监控系统中沉睡的进程数量</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405062255488.png" alt="img"></p><h4 id="12-5-监控cpu的状态"><a href="#12-5-监控cpu的状态" class="headerlink" title="12.5 监控cpu的状态"></a>12.5 监控cpu的状态</h4><ol><li>cpu 五分钟负载情况</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072212759.png" alt="img"></p><p><code>system.cpu.load[&lt;cpu&gt;,&lt;mode&gt;]</code> 是一个用于监控CPU负载的键值（key）。这个键值提供了关于CPU使用情况的信息，通常用于评估系统的性能和瓶颈。</p><p>下面是关于这个键值的参数的详细说明：</p><ul><li><p><cpu>：这个参数指定了要监控的CPU或CPU核心。它可以是以下几种值之一： </cpu></p></li><li><ul><li><code>all</code>：表示监控所有CPU核心的平均负载。</li></ul></li><li><ul><li><code>0</code> 到 <code>N</code>（其中N是CPU核心的数量减去1）：表示监控特定的CPU核心。例如，<code>0</code> 表示第一个CPU核心，<code>1</code> 表示第二个CPU核心，依此类推。</li></ul></li><li><ul><li><code>avg1</code>, <code>avg5</code>, <code>avg15</code>：这些不是CPU核心编号，而是表示过去1分钟、5分钟和15分钟的平均负载。这些值通常用于评估系统负载随时间的变化情况。</li></ul></li></ul><ol><li><strong>cpu 1分钟负载情况</strong></li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072215173.png" alt="img"></p><ol><li><strong>cpu 15分钟负载情况</strong><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072216717.png" alt="img"> </li></ol><hr><hr><h3 id="13、自定义监控设置-Items"><a href="#13、自定义监控设置-Items" class="headerlink" title="13、自定义监控设置(Items)"></a>13、自定义监控设置(Items)</h3><p><strong>客户端(安装有zabbix-agent端)：</strong>    </p><ol><li><p>通过命令、脚本取出需要监控的值； </p></li><li><p>安装zabbix-agent2，编写配置文件、创建键值；格式为：key=values，key为监控项名称。values为监控项的值。通过shell命令取出。 </p></li><li><p>重启客户端服务，并测试是否取出数据。<code>zabbix-agent2 -t Key名</code> </p></li></ol><p><strong>服务端：</strong></p><ol><li><p>服务端命令行测试是否<code>get</code>到客户端自定义监控的值；</p></li><li><p>web界面：获取到的键值与监控项关联；</p></li><li><p>web界面：测试。</p></li></ol><h4 id="13-1-自定义监控项编写"><a href="#13-1-自定义监控项编写" class="headerlink" title="13.1 自定义监控项编写"></a>13.1 自定义监控项编写</h4><p><strong>小试牛刀：监控web服务80端口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行取值</span></span><br><span class="line">[root@test01 ~]<span class="comment"># ss -tunlp | grep -w  80  | wc -l</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428204223339.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看自定监控配置文件存放路径</span></span><br><span class="line">[root@test01 ~]<span class="comment"># grep -i "include" /etc/zabbix/zabbix_agent2.conf </span></span><br><span class="line">...</span><br><span class="line">Include=/etc/zabbix/zabbix_agent2.d/*.conf</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写自定义监控项配置文件</span></span><br><span class="line">[root@test01 ~]<span class="comment"># vim /etc/zabbix/zabbix_agent2.d/web_status.conf</span></span><br><span class="line"><span class="comment">#UserParameter=key,cmd</span></span><br><span class="line"><span class="comment">#UserParameter=web_port_status,bash /check_service/xxx.sh</span></span><br><span class="line">UserParameter=web_port_status,ss -tunlp | grep 80 | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启客户端服务</span></span><br><span class="line">[root@test01 ~]<span class="comment"># systemctl restart zabbix-agent2</span></span><br><span class="line">[root@test01 ~]<span class="comment"># systemctl status zabbix-agent2</span></span><br></pre></td></tr></table></figure><p><code>Include=/etc/zabbix/zabbix_agent2.d/*.conf</code> 自定义监控项配置文件默认位置。</p><p>UserParameter=key,cmd<br>UserParameter=固定格式，表示要自定义监控项。<br>key表示键值名称，也就是自定义监控项的名称，命名最好为 单词+”_”<br>cmd表示取值的命令或者脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端本地测试</span></span><br><span class="line">[root@test01 ~]<span class="comment"># zabbix_agent2 -t web_port_status</span></span><br><span class="line">web_port_status                               [s|1]</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428205503477.png" alt="img"></p><p>解释：<code>**web_port_status**</code> <strong>表示自定义监控的Key，非配置文件名称。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端测试，安装测试工具</span></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># yum install -y zabbix-get</span></span><br><span class="line"></span><br><span class="line">[root@zabbix-server ~]<span class="comment"># zabbix_get  -s 192.168.174.60 -p 10050 -k web_port_status</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><p><strong>-s 客户端IP地址；</strong></p></li><li><p><strong>-p 客户端zabbix-agent 端口，默认：10050；</strong></p></li><li><p><strong>-k 客户端自定义监控项Key名。</strong></p></li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428211118750.png" alt="img"></p><hr><p><strong>web界面添加自定义监控项</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428220752312.png" alt="img"></p><p><strong>配置–&gt;主机–&gt;选择主机监控项</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428220854319.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428221545133.png" alt="img"></p><p>参数解释：</p><ol><li><p>历史数据保留时长：根据服务器的配置决定，建议保留时长不宜过久；</p></li><li><p>趋势存储时间：通常趋势数据设置的的留存时间应当比历史数据留存时间设置的长。</p></li></ol><p>详细信息参考官方文档：<a href="https://www.zabbix.com/documentation/6.0/zh/manual/config/items/history_and_trends" target="_blank" rel="noopener">4 历史数据与趋势数据 (zabbix.com)</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428222405047.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429092334079.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429091503703.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429091543086.png" alt="img"></p><p><strong>web 查看自定义监控项数据</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429094725797.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429094800733.png" alt="img"></p><h4 id="13-2-获取不到内容报错解决"><a href="#13-2-获取不到内容报错解决" class="headerlink" title="13.2 获取不到内容报错解决"></a>13.2 获取不到内容报错解决</h4><p><strong>报错内容</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240428205848334.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**Unknown metric web_port_statuss**</span><br></pre></td></tr></table></figure><ol><li><p>客户端测试时，自定义监控名称写错；</p></li><li><p>自定义监控项配置文件内部语法错误，例如：固定格式、命令；</p></li><li><p>自定义监控项创建完成没有重启客户端。</p></li></ol><h4 id="13-3-使用脚本定义自定义监控项"><a href="#13-3-使用脚本定义自定义监控项" class="headerlink" title="13.3 使用脚本定义自定义监控项"></a>13.3 使用脚本定义自定义监控项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**详细请见附件基于脚本实现自定义监控项**</span><br></pre></td></tr></table></figure><h3 id="14、-自定义图形"><a href="#14、-自定义图形" class="headerlink" title="14、 自定义图形"></a>14、 自定义图形</h3><h4 id="14-1-自定义单个监控项图形"><a href="#14-1-自定义单个监控项图形" class="headerlink" title="14.1 自定义单个监控项图形"></a>14.1 自定义单个监控项图形</h4><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429095135012.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429095158678.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429095505410.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429095627370.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429095731458.png" alt="img"></p><p><strong>查看自定义图形</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429095846535.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429095902300.png" alt="img"></p><h4 id="14-2-仪表盘创建-聚合图形"><a href="#14-2-仪表盘创建-聚合图形" class="headerlink" title="14.2 仪表盘创建(聚合图形)"></a>14.2 仪表盘创建(聚合图形)</h4><p>​    仪表盘用于，将我们自定以图像进行集中值一个界面进行展示，使得我们更方便的找到服务器的瓶颈。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072141985.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072142858.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072143247.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072144583.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072145165.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072145673.png" alt="img"></p><p><strong>查看自定义仪表盘</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072151208.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072151206.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072152655.png" alt="img"></p><h3 id="15、触发器器设置-Triggers-P0级服务"><a href="#15、触发器器设置-Triggers-P0级服务" class="headerlink" title="15、触发器器设置( Triggers)  P0级服务"></a>15、触发器器设置( Triggers)  P0级服务</h3><h4 id="15-1-触发器介绍"><a href="#15-1-触发器介绍" class="headerlink" title="15.1 触发器介绍"></a>15.1 触发器介绍</h4><p>触发器是<code>条件的定义</code>,一个触发器是根据一个监控项的<code>返回值</code>,将之<code>对比预先设置的阈值</code>，当监控项返回了不符合预定义的值范围后,就进行触发下一步操作的警戒线,一般要对创建的监控项设置触发器以及触发方式和值的大小</p><ul><li><p>可以在指定主机上创建触发器,只是针对指定主机有效； </p></li><li><p>也可以在指定<code>模板上创建触发器</code>,则使用此模板的所有主机都有效,一个模板中可以有多触发器；<br>触发器中使用的表达式是非常灵活的。你可以使用它们去创建关于监控统计的复杂逻辑测试。 </p></li></ul><h4 id="15-2-触发器严重性"><a href="#15-2-触发器严重性" class="headerlink" title="15.2 触发器严重性"></a>15.2 触发器严重性</h4><p>触发器严重性表示<code>触发器的重要程度</code>，Zabbix支持下列6种触发器的严重程度：</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429104740157.png" alt="img"></p><p>严重性功能：</p><ul><li><p>通过不同的颜色区分不同的严重程度；</p></li><li><p>用户媒介，不同的用户媒介（通知渠道）代表不同的严重程度。例如，短信 - 高严重性，email - 其他；</p></li><li><p>不同的严重性通过触发器执行对应的条件动作。</p></li></ul><h4 id="15-3-配置触发器"><a href="#15-3-配置触发器" class="headerlink" title="15.3 配置触发器"></a>15.3 配置触发器</h4><h5 id="15-3-1-触发器示例一：web服务端口"><a href="#15-3-1-触发器示例一：web服务端口" class="headerlink" title="15.3.1 触发器示例一：web服务端口"></a>15.3.1 触发器示例一：web服务端口</h5><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429105152136.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429105218145.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429111807604.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429111947106.png" alt="img"></p><p>解释：</p><ul><li><p>监控项：自定义监控项默认没有触发器，需要自己去添加，选择自定义监控项的名称；</p></li><li><p>功能：<code>last</code>函数：表示最新的值和最近一次的值作比较。</p></li><li><p>结果：如果自定义监控项取出的值为0时，触发报警。</p></li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429112408935.png" alt="img"></p><p>解释：表达式 zabbix5和zabbix6之间的区别</p><ul><li><p>zabbix 6 </p></li><li><ul><li>last(/nginx01/web_port_status)=0   # 函数(/主机/自定义监控项)=0</li></ul></li><li><p>zabbix 5 </p></li><li><ul><li>{nginx01:web_port_status.last()}=0    # {主机:自定义监控项名称.功能函数}=0</li></ul></li></ul><p><strong>测试触发器是否生效</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端关闭nginx</span></span><br><span class="line">[root@test01 ~]<span class="comment"># systemctl stop nginx</span></span><br></pre></td></tr></table></figure><p><strong>web界面查看</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429141751762.png" alt="img"></p><h5 id="15-3-2-触发器示例二：cpu-1分钟负载"><a href="#15-3-2-触发器示例二：cpu-1分钟负载" class="headerlink" title="15.3.2 触发器示例二：cpu 1分钟负载"></a>15.3.2 触发器示例二：cpu 1分钟负载</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero  of=/1.txt  bs=1M count=4000</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072220786.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072220561.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072333602.png" alt="img"></p><p><strong>查看触发器</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072335452.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072335962.png" alt="img"></p><p>表达式：<strong>last(/nginx_status_monitor/system.cpu.load[all,avg1])&gt;=0.4</strong></p><p>解释：表达式函数(/监控模版/自定义监控项)&gt;=0.4</p><p><strong>图形查看触发器</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405072343646.png" alt="img"></p><hr><hr><h4 id="15-4-触发器常用表达式功能函数介绍"><a href="#15-4-触发器常用表达式功能函数介绍" class="headerlink" title="15.4 触发器常用表达式功能函数介绍"></a>15.4 触发器常用表达式功能函数介绍</h4><p>官方网站：<a href="https://www.zabbix.com/documentation/6.0/zh/manual/config/triggers/expression" target="_blank" rel="noopener">2 触发器表达式 (zabbix.com)</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240429142518357.png" alt="img"></p><p><strong>触发器示例场景</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 触发器示例场景1:www.zabbix.com的处理器负载过高</span></span><br><span class="line">last(www.zabbix.com/system.cpu.load[all,avg1])&gt;5</span><br><span class="line">服务器是www.zabbix.com，监控项键值是system.cpu.load[all,avg1]</span><br><span class="line">通过使用函数“last()”获取最新的值。最后&gt;5 意味着当www.zabbix.com最新获取的处理器负载值大于5时触发器就会处于异常状态。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发器示例场景2:当前处理器负载大于5并且最近10分钟内最小值大于2，表达式为True</span></span><br><span class="line">last(www.zabbix.com/system.cpu.load[all,avg1]) &gt; 5 and last(www.zabbix.com/system.cpu.load[all.avg1].min(10m)) &gt; 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发器示例场景3:监控/etc/passwd 文件是否被修改，当文件/etc/passwd的checksum值与最近的值不同时，表达式为true。</span></span><br><span class="line">diff(www.zabbix.com/vfs.file.cksum[/etc/passwd]) = 1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发器示例场景4:如果在最后五分钟期间eth0网卡接收到的网络字节数最小值超过 100 KB 将触发。</span></span><br><span class="line">min(/Zabbix server/net.if.in[eth0,bytes],5m)&gt;100K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发器实力场景5：Zabbix server上的处理器负载太高。</span></span><br><span class="line">last(/Zabbix server/system.cpu.load[all,avg1])&gt;5</span><br><span class="line">‘/Zabbix server/system.cpu.load[all,avg1]‘ 给出了被监控参数的简短名称。它指定了服务器是“Zabbix server”，监控项的键值是“system.cpu.load[all,avg1]”。通过使用函数“last()”获取最新的值。最后，“&gt;5”意味着当Zabbix server最新获取的处理器负载值大于5时触发器就会处于异常状态。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发器示例场景7：服务器网卡从 Internet 下载一个大文件。 min 函数的使用：</span></span><br><span class="line">min(/www.example.com/net.if.in[eth0,bytes],5m)&gt;100K</span><br><span class="line">在过去5分钟内，eth0上接收字节数大于100kb时，表达式为<span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发器示例场景8：服务器无法访问。</span></span><br><span class="line">count(/example.example.com/icmpping,30m,,<span class="string">"0"</span>)&gt;5、</span><br><span class="line">如果主机“example.example.com” 在过去 30 分钟内超过 5 次无法访问，则表达式为真。</span><br></pre></td></tr></table></figure><h3 id="16、zabbix监控模版"><a href="#16、zabbix监控模版" class="headerlink" title="16、zabbix监控模版"></a>16、zabbix监控模版</h3><h4 id="16-1-zabbix-server自带模版"><a href="#16-1-zabbix-server自带模版" class="headerlink" title="16.1 zabbix server自带模版"></a>16.1 zabbix server自带模版</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux by Zabbix agent</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>Linux: Host name of Zabbix agent running</td><td>Linux：Zabbix代理运行的主机名</td></tr><tr><td>Linux: Zabbix agent ping</td><td>Linux:Zabbix代理ping</td></tr><tr><td>Linux: Version of Zabbix agent running</td><td>Linux：运行Zabbix代理的版本</td></tr><tr><td>Linux: Maximum number of open file descriptors</td><td>打开文件描述符的最大数量</td></tr><tr><td>Linux: Maximum number of processes</td><td>Linux：进程的最大数量</td></tr><tr><td>Linux: Number of processes</td><td>Linux：进程数</td></tr><tr><td>Linux: Number of running processes</td><td>Linux：正在运行的进程数</td></tr><tr><td>Linux: System boot time</td><td>Linux：系统启动时间</td></tr><tr><td>Linux: Interrupts per second</td><td>Linux:每秒中断次数</td></tr><tr><td>Linux: Load average (1m avg)</td><td>Linux：平均负载（平均1分钟）</td></tr><tr><td>Linux: Load average (5m avg)</td><td>Linux：平均负载（平均5分钟）</td></tr><tr><td>Linux: Load average (15m avg)</td><td>Linux：平均负载（平均15分钟）</td></tr><tr><td>Linux: Number of CPUs</td><td>Linux：CPU数量</td></tr><tr><td>Linux: Context switches per second</td><td>Linux:每秒上下文切换次数</td></tr><tr><td>Linux: CPU idle time: Linux: CPU utilization</td><td>Linux:CPU空闲时间：Linux:CPU利用率</td></tr><tr><td>Linux: CPU guest time</td><td>Linux 中的 CPU guest time 是指<code>虚拟机在宿主机上运行期间，CPU 资源被占用的时间</code>。这个指标可以帮助管理员了解虚拟机对宿主机 CPU 资源的使用情况，以便进行性能优化和资源分配。</td></tr><tr><td>Linux: CPU guest nice time</td><td>Linux 中的 CPU guest nice time 是指<code>虚拟机在宿主机上运行期间</code>，<code>CPU 资源被占用的 nice 时间</code>。nice 值是 Linux 系统中用于控制进程优先级的一个参数，范围从 -20（最高优先级）到 19（最低优先级）。</td></tr><tr><td>Linux: CPU idle time</td><td>在 Linux 系统中，<code>CPU idle time 指的是 CPU 处于空闲状态的时间</code>。这是系统性能监控中的一个重要指标，因为它可以帮助你理解系统资源是否得到了充分利用或者是否存在过剩的计算能力。</td></tr><tr><td>Linux: CPU interrupt time</td><td>Linux 中的 CPU interrupt time 是指 <code>CPU 在处理中断请求时所花费的时间</code>。中断是计算机系统中的一种机制，用于响应硬件设备或软件程序的请求，以便进行相应的操作。</td></tr><tr><td>Linux: CPU iowait time</td><td>在 Linux 中，CPU iowait time（I/O等待时间）是<code>指 CPU 等待 I/O 操作完成的时间</code>。当 CPU 需要从磁盘、网络或其他慢速设备读取数据时，如果该数据尚未准备好，CPU 就会进入等待状态。iowait 是衡量系统 I/O 性能的关键指标之一，它可以帮助识别是否存在 I/O 瓶颈问题。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache by HTTP</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28776&context=template" target="_blank" rel="noopener"> Apache: Service ping</a></td><td>httpd服务是否存活</td></tr><tr><td>Apache: Service response time</td><td>Apache 服务器的响应时间。是指从客户端发送请求到接收到服务器响应所需的时间。这个指标对于评估服务器性能和用户体验非常重要。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28788&context=template" target="_blank" rel="noopener">Apache: Total workers idle</a></td><td>Apache: Total workers idle 是指当前空闲的工作进程数量。这个指标可以帮助你了解服务器的负载情况，以及是否需要增加或减少工作进程的数量来优化性能。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28789&context=template" target="_blank" rel="noopener">Apache: Total workers busy</a></td><td>Apache: Total workers busy 是指当前正在处理请求的工作进程数量。这个指标可以帮助你了解服务器的负载情况，以及是否需要增加或减少工作进程的数量来优化性能。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28796&context=template" target="_blank" rel="noopener">Apache: Workers waiting for connection</a></td><td>Apache: Workers waiting for connection 是指当前正在等待连接的工作进程数量。这个指标可以帮助你了解服务器的负载情况，以及是否需要增加或减少工作进程的数量来优化性能。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener"> Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28778&context=template" target="_blank" rel="noopener">Apache: Workers starting up</a></td><td>Apache: Workers starting up 是指当前正在启动的工作进程数量。这个指标可以帮助你了解服务器的负载情况，以及是否需要增加或减少工作进程的数量来优化性能。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28779&context=template" target="_blank" rel="noopener">Apache: Workers slot with no current process</a></td><td><code>指当前没有正在处理请求的工作进程的插槽数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener"> Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28780&context=template" target="_blank" rel="noopener">Apache: Workers sending reply</a></td><td><code>指当前正在发送响应的工作进程数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28781&context=template" target="_blank" rel="noopener">Apache: Workers reading request</a></td><td><code>指当前正在读取请求的工作进程数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28782&context=template" target="_blank" rel="noopener">Apache: Workers logging</a></td><td>指当前正在记录日志的工作进程数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28783&context=template" target="_blank" rel="noopener">Apache: Workers keepalive (read)</a></td><td><code>指当前正在处理 Keep-Alive 连接的工作进程数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28785&context=template" target="_blank" rel="noopener">Apache: Workers finishing</a></td><td><code>指当前正在结束请求的工作进程数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28787&context=template" target="_blank" rel="noopener">Apache: Workers DNS lookup</a></td><td>指当前正在执行 DNS 查询的工作进程数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28786&context=template" target="_blank" rel="noopener">Apache: Workers closing connection</a></td><td><code>指当前正在关闭连接的工作进程数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28784&context=template" target="_blank" rel="noopener">Apache: Workers idle cleanup</a></td><td>指当前正在执行空闲清理的工作进程数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28790&context=template" target="_blank" rel="noopener">Apache: Version</a></td><td>指 Apache HTTP Server 的版本号。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener"> Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28791&context=template" target="_blank" rel="noopener">Apache: Uptime</a></td><td>指 Apache HTTP Server 自上次启动以来的运行时间。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28793&context=template" target="_blank" rel="noopener">Apache: Requests per second</a></td><td><code>指 Apache HTTP Server 每秒处理的请求数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener"> Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28792&context=template" target="_blank" rel="noopener">Apache: Total requests</a></td><td><code>指 Apache HTTP Server 自上次启动以来处理的总请求数量。</code></td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a></td><td>指获取 Apache HTTP Server 的状态信息。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener">Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28794&context=template" target="_blank" rel="noopener">Apache: Bytes per second</a></td><td>指 Apache HTTP Server 每秒传输的字节数。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28775&context=template" target="_blank" rel="noopener"> Apache: Get status</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10265&itemid=28795&context=template" target="_blank" rel="noopener">Apache: Total bytes</a></td><td>指 Apache HTTP Server 自上次启动以来传输的总字节数。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nginx by Zabbix agent</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener"> Nginx: Get stub status page</a></td><td>Nginx: Get stub status page 是指获取 Nginx Web Server 的状态页面。这个状态页面提供了关于服务器的实时信息，包括连接数、请求处理时间等指标。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28809&context=template" target="_blank" rel="noopener">Nginx: Number of running processes</a></td><td>指 Nginx Web Server 当前正在运行的进程数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28808&context=template" target="_blank" rel="noopener"> Nginx: Memory usage (vsize)</a></td><td>指 Nginx Web Server 进程的虚拟内存使用量。虚拟内存使用量（vsize）包括了进程直接使用的内存以及其映射的文件和设备所使用的内存。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28807&context=template" target="_blank" rel="noopener">Nginx: Memory usage (rss)</a></td><td><strong>Nginx Web Server 进程使用的驻留集大小内存（以字节为单位）</strong>。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28806&context=template" target="_blank" rel="noopener">Nginx: CPU utilization</a></td><td><strong>指的是Nginx进程在服务器CPU上占用的资源情况，包括用户态和内核态的占用</strong>。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener"> Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28820&context=template" target="_blank" rel="noopener">Nginx: Version</a></td><td>指 Nginx Web Server 的版本号。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28818&context=template" target="_blank" rel="noopener">Nginx: Requests per second</a></td><td>指 Nginx Web Server 每秒处理的请求数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener"> Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28819&context=template" target="_blank" rel="noopener">Nginx: Requests total</a></td><td>指 Nginx Web Server 自上次启动以来处理的总请求数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28812&context=template" target="_blank" rel="noopener">Nginx: Connections writing</a></td><td>指 Nginx Web Server 当前正在写入响应的连接数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28811&context=template" target="_blank" rel="noopener">Nginx: Connections waiting</a></td><td>指 Nginx Web Server 当前正在等待连接的连接数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28814&context=template" target="_blank" rel="noopener">Nginx: Connections reading</a></td><td>指 Nginx Web Server 当前正在读取请求的连接数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28815&context=template" target="_blank" rel="noopener">Nginx: Connections handled per second</a></td><td>指 Nginx Web Server 每秒处理的连接数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28816&context=template" target="_blank" rel="noopener">Nginx: Connections dropped per second</a></td><td>指 Nginx Web Server 每秒丢弃的连接数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28813&context=template" target="_blank" rel="noopener">Nginx: Connections active</a></td><td>指 Nginx Web Server 当前活跃的连接数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28804&context=template" target="_blank" rel="noopener">Nginx: Get stub status page</a>: <a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28817&context=template" target="_blank" rel="noopener">Nginx: Connections accepted per second</a></td><td>指 Nginx Web Server 每秒接受的连接数量。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28810&context=template" target="_blank" rel="noopener">Nginx: Service status</a></td><td>指 Nginx Web Server 的运行状态。</td></tr><tr><td><a href="http://192.168.174.58/items.php?form=update&hostid=10266&itemid=28805&context=template" target="_blank" rel="noopener"> Nginx: Service response time</a></td><td>指 Nginx Web Server 处理请求的响应时间。</td></tr></tbody></table><h3 id="17、触发器-Action"><a href="#17、触发器-Action" class="headerlink" title="17、触发器 Action"></a>17、触发器 Action</h3><h4 id="17-1-Action-动作介绍"><a href="#17-1-Action-动作介绍" class="headerlink" title="17.1 Action 动作介绍"></a>17.1 Action 动作介绍</h4><p>Zabbix中的Action是<strong>根据不同的事件状态执行相应操作的功能</strong>。</p><p>在Zabbix监控系统中，Action是一个核心功能，它允许你基于事件的<code>不同状态来执行预定义的操作</code>。这些操作可以极大地自动化日常的运维工作，减少手动干预的需要。以下是Zabbix Action的一些主要特点和用途：</p><ol><li><p><strong>自动响应</strong>：当监控系统检测到问题（如触发器状态变化）时，可以自动执行一系列操作，而不是需要人工介入。</p></li><li><p><strong>可配置性</strong>：：自定义Action，例如发送报警通知、执行远程命令等。</p></li><li><p><strong>权限管理</strong>：为了执行某些操作，如重启服务，可能需要相应的权限。因此，配置sudo权限或修改zabbix配置文件以允许接收远程命令是常见的设置步骤。</p></li><li><p><strong>报警通知</strong>：最常见的用法是在检测到问题时，通过邮件、短信或其他方式将报警信息发送给指定的用户。</p></li><li><p><strong>远程命令执行</strong>：可以配置Action来在特定条件下执行远程命令，如系统重启、服务重启等，这通常需要确保Zabbix用户具有执行这些命令的权限。</p></li><li><p><strong>日志记录</strong>：所有执行的Action都会被记录在Zabbix的日志中，便于后续的问题排查和分析。</p></li></ol><h4 id="17-2-告警分类"><a href="#17-2-告警分类" class="headerlink" title="17.2 告警分类"></a>17.2 告警分类</h4><table><thead><tr><th>报警方式</th><th>企业使用场景</th></tr></thead><tbody><tr><td>邮件告警</td><td>企业邮箱，免费试用</td></tr><tr><td>企业微信/飞书-告警机器人</td><td>企业微信，免费使用</td></tr><tr><td>OA系统(钉钉)</td><td>钉钉，免费使用</td></tr><tr><td>短信</td><td>0.04元/条左右，云厂商，收费</td></tr><tr><td>电话</td><td>收费</td></tr></tbody></table><h4 id="17-2-邮箱告警"><a href="#17-2-邮箱告警" class="headerlink" title="17.2 邮箱告警"></a>17.2 邮箱告警</h4><p><strong>详细请见附件：zabbix 6.0 结合邮箱触发告警</strong></p><h4 id="17-3-飞书告警"><a href="#17-3-飞书告警" class="headerlink" title="17.3 飞书告警"></a>17.3 飞书告警</h4><p><strong>详细请见附件：zabbix 6.0结合飞书触发告警</strong></p><h3 id="17-4-zabbix-基于ssh远程执行故障恢复操作"><a href="#17-4-zabbix-基于ssh远程执行故障恢复操作" class="headerlink" title="17.4 zabbix 基于ssh远程执行故障恢复操作"></a>17.4 zabbix 基于ssh远程执行故障恢复操作</h3><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/1716386143737-e11c2eb7-3c75-47dc-a8f5-913339b9cb76.png" alt="img"></p><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/1716386182378-2beadc93-1f37-45fb-86c4-f43ced978a2c.png" alt="img"></p><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/1716386225761-4918c8c3-7e9e-4dab-a15b-a469eea5de62.png" alt="img"></p><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/1716386267017-e1be7003-82c1-45d5-806d-a6701a48ba12.png" alt="img"></p><p><strong>zabbix中远程命令 ssh报错Cannot obtain authentication methods: Error waiting on socket</strong></p><p>去agent2节点中的/etc/ssh/sshd_config中，将UseDNS打开注释并将yes改为no然后重启sshd服务。</p><p>UseDNS 选项打开状态下，当客户端试图登录SSH服务器时，服务器端先根据客户端的IP地址进行DNS，PTR反向查询出客户端的主机名，然后根据查询出的客户端主机名进行DNS正向A记录查询，验证与其原始IP地址是否一致，这是防止客户端欺骗的一种措施，但一般我们的是动态IP不会有PTR记录，打开这个选项不过是在白白浪费时间而已，不如将其关闭。Linux优化时常这样做。</p><h3 id="18、宏"><a href="#18、宏" class="headerlink" title="18、宏"></a>18、宏</h3><h4 id="18-1-介绍"><a href="#18-1-介绍" class="headerlink" title="18.1 介绍"></a>18.1 介绍</h4><p>​    <strong>Zabbix中的宏是一种用于简化配置和提高可重用性的功能强大的工具</strong>。在Zabbix中，宏可以被视为一种变量，用于保存预设的文本模式，并在调用时将其替换为相应的值。例如，内置宏{HOST.NAME}会在使用中自动替换为对应主机的名称。</p><h4 id="18-2-设置优先级"><a href="#18-2-设置优先级" class="headerlink" title="18.2 设置优先级"></a>18.2 设置优先级</h4><ol><li><p><strong>全局宏</strong>：作用于所有模板和主机，但优先级最低。</p></li><li><p><strong>模板宏</strong>：仅适用于关联的模板。</p></li><li><p><strong>主机宏</strong>：特定于单个主机。</p></li></ol><h4 id="18-3-作用及场景"><a href="#18-3-作用及场景" class="headerlink" title="18.3 作用及场景"></a>18.3 作用及场景</h4><ul><li><p><strong>简化配置</strong>：通过使用宏，可以在多个地方重复使用相同的值，而不必手动更改每个实例。</p></li><li><p><strong>统一管理</strong>：方便后期统一修改和维护，例如，如果需要更改服务器名称，只需更改全局宏一次即可。</p></li></ul><p>实际应用场景</p><ul><li><strong>监控项和触发器</strong>：在创建监控项或触发器时，可以使用宏来定义动态的名称或参数值。</li></ul><h4 id="18-4-宏设置"><a href="#18-4-宏设置" class="headerlink" title="18.4 宏设置"></a>18.4 宏设置</h4><p>触发动作的名字:{ACTION.NAME}</p><p>日期格式为yyyy.mm.dd:{DATE}</p><p>触发动作的事件的时长:{EVENT.AGE}</p><p>触发动作的事件的日期:{EVENT.DATE}</p><p>事件持续时间:{EVENT.DURATION}</p><p>触发动作的事件的数字ID:{EVENT.ID}</p><p>触发动作的问题事件名称:{EVENT.NAME}</p><p>描述事件严重性的数值:{EVENT.NSEVERITY}</p><p>描述事件对象的数值:{EVENT.OBJECT}</p><p>问题对应触发器的当前值:{EVENT.OPDATA}</p><p>事件恢复日期:{EVENT.RECOVERY.DATE}</p><p>恢复时间名称:{EVENT.RECOVERY.NAME}</p><p>恢复事件的文字描述:{EVENT.RECOVERY.STATUS}</p><p>出发动作的事件的文字描述:{EVENT.STATUS}</p><p>触发动作的事件时间*:{EVENT.TIME}</p><p>依赖于主机设置的主机IP地址或DNS名称:{HOST.CONN}</p><p>主机描述.:{HOST.DESCRIPTION}</p><p>主机名称:{HOST.HOST}</p><p>主机 ID.:{HOST.ID}</p><p>主机IP地址:{HOST.IP}</p><p>可见的主机名:{HOST.NAME}</p><p>主机（代理）端口:{HOST.PORT}</p><p>目标主机IP地址或DNS名称，取决于主机设置:{HOST.TARGET.CONN}</p><p>目标主机的DNS名称:{HOST.TARGET.DNS}</p><p>目标主机的技术名称:{HOST.TARGET.HOST}</p><p>目标主机的IP地址。:{HOST.TARGET.IP}</p><p>目标主机的技术名称:{HOST.TARGET.NAME}</p><p>引发通知的触发器表达式中的第N个监控项的描述。:{ITEM.DESCRIPTION}</p><p>引发通知的触发器表达式中的第 N 个监控项的序列ID。:{ITEM.ID}</p><p>触发器表达式中导致通知的第 N 监控项的键：{ITEM.KEY}</p><p>触发器表达式中导致通知的第N个监控项的名称：{ITEM.NAME}</p><p>触发器表达式中导致通知的第 N 监控项的最新状态：{ITEM.STATE}</p><p>如果在触发器状态更改的上下文中使用：{ITEM.VALUE}</p><p>触发器表达式中导致通知的第N个监控项的值类型：{ITEM.VALUETYPE}</p><p>触发器描述。：{TRIGGER.DESCRIPTION}</p><p>触发器表达式。：{TRIGGER.EXPRESSION}</p><p>触发器的名称 (已解析宏).：{TRIGGER.NAME}</p><p>触发器的原始名称 (即未解析宏).：{TRIGGER.NAME.ORIG}</p><p>触发器的最新状态 可能的值: 未知 和 正常：{TRIGGER.STATE}</p><p>当前触发器的值 可以是 PROBLEM 或者 OK：{TRIGGER.STATUS}</p><p>当前触发数值: 0 - 触发器处于正常状态, 1 - 触发器处于问题状态。：{TRIGGER.VALUE}</p><h3 id="19、zabbix-自动发现"><a href="#19、zabbix-自动发现" class="headerlink" title="19、zabbix 自动发现"></a>19、zabbix 自动发现</h3><p>为了满足监控企业成千上万台服务器，因此我们需要使用Zabbix批量监控来实现。自动发现功能是<strong>一个强大的网络监控工具，它允许系统管理员无需手动添加即可自动检测网络中的设备和服务</strong>。自动发现功能发现被监控对象。同时自动发现功能能够提高监控系统的效率，因为它能够自动发现并添加新的主机或服务，使得管理员无需手动添加监控对象。</p><p>自动发现（<strong>被动模式</strong>）：由服务端主动发起，Zabbix Server开启发现进程，定时扫描局域网中IP服务器、设备。实现自动将发现主机、自动将主机添加到主机组、自动加载模板、自动创建项目（item）、自动创建图像等功能。缺点：当 Agent服务器过多的时候采用自动发现，zabbix-server压力会比较大，自动添加主机进度就会非常慢。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405091430543.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405092225029.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405091432175.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405091454115.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405091454293.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405091455385.png" alt="img"></p><p><strong>查看自动发现主机</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405092243625.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405092251627.png" alt="img"></p><p><a href="https://www.cnblogs.com/zdoubly/p/9222902.html" target="_blank" rel="noopener">https://www.cnblogs.com/zdoubly/p/9222902.html</a></p><h3 id="20、zabbix自动注册"><a href="#20、zabbix自动注册" class="headerlink" title="20、zabbix自动注册"></a>20、zabbix自动注册</h3><p>自动注册（<strong>主动模式</strong>）：Zabbix Server 等待 Zabbix Agent2主动上报。由客户端主动发起，客户端必须安装并启动Agent，否则无法被自动注册添加至主机列表。</p><h4 id="20-1-zabbix自动注册介绍"><a href="#20-1-zabbix自动注册介绍" class="headerlink" title="20.1 zabbix自动注册介绍"></a>20.1 zabbix自动注册介绍</h4><p>Zabbix 自动注册是一种方便的功能，它允许 Zabbix Agent2 主动向 Zabbix Server 注册自己，而无需手动在 Zabbix 中为每个主机创建条目。以下是实现 Zabbix 自动注册的关键步骤：</p><ol><li><p><strong>配置元数据</strong>：在 Zabbix Agent2 的配置文件中，需要设置一些参数，如 <code>Hostname</code>、<code>HostMetadata</code> 等客户端的元数据信息，以便 Zabbix Server 根据这些信息来匹配服务器的主机或模板。</p></li><li><p><strong>启用 Agent2 的主动模式</strong>：确保 Zabbix Agent2 是以主动模式运行的，即 Agentd必须安装并启动。在被动模式下，Zabbix Server 会主动扫描局域网中的设备，这在 Agent 数量较多时可能会给 Zabbix Server 带来较大压力。</p></li><li><p><strong>修改 zabbix_agent2.conf 文件</strong>：在客户端的 zabbix_agent2.conf 文件中，需要定义要执行的监控命令和自定义的 key。这些 key 将与服务器端的监控项相对应。</p></li></ol><h4 id="20-2-zabbix自动注册操作"><a href="#20-2-zabbix自动注册操作" class="headerlink" title="20.2 zabbix自动注册操作"></a>20.2 zabbix自动注册操作</h4><p><strong>客户端配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt;  被监控端修改zabbix-agent2配置文件，开启主动模式</span></span><br><span class="line">[root@web02 ~]<span class="comment"># vim  /etc/zabbix/zabbix_agent2.conf </span></span><br><span class="line">ServerActive=192.168.174.58</span><br><span class="line"><span class="comment"># 注释掉配置文件的主机名。</span></span><br><span class="line"><span class="comment"># Hostname=Zabbix server</span></span><br><span class="line"><span class="comment"># 获取当前主机名</span></span><br><span class="line">HostnameItem=system.hostname</span><br><span class="line"><span class="comment"># 获取当前主机元数据信息</span></span><br><span class="line">HostMetadataItem=system.uname</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重启zabbix-agent2</span></span><br><span class="line">[root@web02 ~]<span class="comment"># systemctl restart zabbix-agent2</span></span><br><span class="line"></span><br><span class="line">[root@web02 ~]<span class="comment"># egrep -n  "^Server|^Host"  /etc/zabbix/zabbix_agent2.conf </span></span><br><span class="line">80:Server=192.168.174.58</span><br><span class="line">133:ServerActive=192.168.174.58</span><br><span class="line">153:HostnameItem=system.hostname</span><br><span class="line">176:HostMetadataItem=system.uname</span><br></pre></td></tr></table></figure><p><strong>服务端配置</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405092310344.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405092316654.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405092314364.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405092318861.png" alt="img"></p><h3 id="21、Zabbix-系列之分布式监控-Proxy-代理"><a href="#21、Zabbix-系列之分布式监控-Proxy-代理" class="headerlink" title="21、Zabbix 系列之分布式监控 Proxy 代理"></a>21、Zabbix 系列之分布式监控 Proxy 代理</h3><p><img src="/2024/08/23/%E4%BC%81%E4%B8%9A%E7%BA%A7Zabbix%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/proxy.png" alt="img"></p><h4 id="21-1-介绍"><a href="#21-1-介绍" class="headerlink" title="21.1 介绍"></a>21.1 介绍</h4><p>Zabbix Proxy 可以代表 Zabbix Server 收集性能和可用性数据。<br>通过这种方式，Proxy 可以自己承担一些收集数据的负载，并减轻 Zabbix Server 的负担。<br>此外，当所有 Agents 和 Proxy 都向一个 Zabbix Server 报告并且所有数据都集中收集时，使用 Proxy 代理是实现集中式和分布式监控的最简单方法。<strong>Zabbix Proxy 代理是一个数据收集器，它不运行触发器、处理事件或发送警报。</strong></p><h4 id="21-2-应用场景"><a href="#21-2-应用场景" class="headerlink" title="21.2 应用场景"></a>21.2 应用场景</h4><ol><li><strong>监控远程位置</strong>：Zabbix Proxy 可以部署在远程位置，比如分支机构或数据中心，以收集该位置下所有被监控设备的数据。<br>这样可以减少网络带宽的使用，因为 Proxy 可以先将数据进行聚合，然后再传输到中央的 Zabbix Server。</li><li><strong>监控通信不可靠的场景</strong>：当网络环境不稳定或通信可靠性不高时，Zabbix Proxy 可以作为一个缓存或中转站。即使网络暂时中断，Proxy 也可以继续收集数据，并在网络恢复后将数据发送给 Zabbix Server。这有助于确保数据的完整性和可靠性。</li><li><strong>监视数千个设备</strong>：当需要监控的设备数量非常大时，单一的 Zabbix Server 可能无法处理所有的数据。在这种情况下，可以使用多个 Zabbix Proxy 来分散负载。每个 Proxy 负责一部分设备的监控，然后将数据发送给 Zabbix Server 进行集中处理。</li><li><strong>多机房采集：</strong>通过使用 Zabbix Proxy，可以简化分布式监控的维护。管理员只需要配置和维护 Zabbix Server 和各个 Proxy，而不需要直接管理所有的被监控设备。此外，由于 Proxy 可以处理一些基本的监控任务（如数据聚合、存储和转发），因此可以减少对 Zabbix Server 的依赖，降低单点故障的风险。</li></ol><h4 id="21-3-Zabbix-Proxy-必须使用单独的数据库的原因"><a href="#21-3-Zabbix-Proxy-必须使用单独的数据库的原因" class="headerlink" title="21.3 Zabbix Proxy 必须使用单独的数据库的原因"></a>21.3 Zabbix Proxy 必须使用单独的数据库的原因</h4><ol><li><strong>数据一致性和完整性：</strong> Zabbix Proxy 代理负责收集来自被监控设备的数据，并将这些数据暂时存储在本地数据库中。如果 Proxy 代理和 Server 共享同一个数据库，可能会导致数据写入的冲突和混乱，尤其是在高并发或网络不稳定的情况下。使用单独的数据库可以确保 Proxy 代理收集的数据在传输到 Server 之前得到妥善保存，并且不会因为 Server 的临时通信问题而丢失。</li><li><strong>减轻server压力：</strong> Zabbix Proxy 代理可以在一定程度上分担 Zabbix Server 的压力，特别是在监控大量设备或远程区域设备时。通过使用单独的数据库，Proxy 代理可以在本地处理大部分的数据收集和存储工作，然后再将汇总后的数据发送给 Server，从而减轻 Server 的负担。</li></ol><h4 id="21-4-安装"><a href="#21-4-安装" class="headerlink" title="21.4 安装"></a>21.4 安装</h4><p>安装数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 安装mariadb</span></span><br><span class="line">略</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建用户</span></span><br><span class="line">MariaDB [(none)]&gt; create database zabbix_proxy character <span class="built_in">set</span> utf8 collate utf8_bin;</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on zabbix_proxy.* to zabbix@<span class="string">'%'</span> identified by <span class="string">'zabbix'</span>;</span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on zabbix_proxy.* to zabbix@<span class="string">'localhost'</span> identified by <span class="string">'zabbix'</span>;</span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on zabbix_proxy.* to zabbix@<span class="string">'127.0.0.1'</span> identified by <span class="string">'zabbix'</span>;</span><br><span class="line">MariaDB [(none)]&gt; flush privileges;</span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 安装zabbix_proxy</span></span><br><span class="line">[root@web01 zabbix]<span class="comment"># yum -y install zabbix-proxy-mysql zabbix-sql-scripts zabbix-selinux-policy</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 导入初始架构和初始数据</span></span><br><span class="line">[root@web01 zabbix]<span class="comment"># mysql -uroot  zabbix_proxy &lt; /usr/share/zabbix-sql-scripts/mysql/proxy.sql</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 备份文件</span></span><br><span class="line">[root@web01 zabbix]<span class="comment"># cp /etc/zabbix/zabbix_proxy.conf&#123;,.bak&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改文件  </span></span><br><span class="line">[root@web01 zabbix]<span class="comment"># vim /etc/zabbix/zabbix_proxy.conf</span></span><br><span class="line">Server=192.168.174.58       <span class="comment"># 指定zabbix-server的IP地址</span></span><br><span class="line">LogFile=/var/<span class="built_in">log</span>/zabbix/zabbix_proxy.log     <span class="comment"># 日志文件路径必须指定</span></span><br><span class="line">PidFile=/run/zabbix/zabbix_proxy.pid       <span class="comment"># pid文件路径必须指定</span></span><br><span class="line">Hostname=zabbix-proxy   <span class="comment"># 当前主机的主机名，注意这里一定要和hostname的结果一致</span></span><br><span class="line">DBName=zabbix_proxy <span class="comment"># 指定数据库名称</span></span><br><span class="line">DBUser=zabbix <span class="comment"># 指定连接数据库用户名</span></span><br><span class="line">DBPassword=zabbix          <span class="comment"># 指定用户名密码</span></span><br><span class="line">DBSocket=/var/lib/mysql/mysql.sock <span class="comment"># 指定mariadb的的socket文件</span></span><br><span class="line">AllowUnsupportedDBVersions=1 <span class="comment"># 关闭数据库版本检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动zabbix-proxy</span></span><br><span class="line">[root@web01 zabbix]<span class="comment"># systemctl enable  --now zabbix-proxy</span></span><br><span class="line">[root@web01 zabbix]<span class="comment"># systemctl status zabbix-proxy</span></span><br></pre></td></tr></table></figure><p><strong>注意：zabbix-proxy主机名需要和配置文件中的Hostname保持一致</strong></p><h4 id="zabbix-agent2配置"><a href="#zabbix-agent2配置" class="headerlink" title="zabbix-agent2配置"></a>zabbix-agent2配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@web03 ~]<span class="comment"># hostname -I</span></span><br><span class="line">192.168.174.62 </span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改配置zabbix-agent2配置文件</span></span><br><span class="line">[root@web03 ~]<span class="comment"># vim /etc/zabbix/zabbix_agentd.conf</span></span><br><span class="line"><span class="comment"># 这里不在写zabbix server的地址，写zabbix proxy主机的地址</span></span><br><span class="line">Server=192.168.174.60             <span class="comment"># 被动模式</span></span><br><span class="line">ServerActive=192.168.174.60  <span class="comment"># 主动模式</span></span><br><span class="line"><span class="comment">#此值也必须和hostname的值一致</span></span><br><span class="line">Hostname=web03</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重启服务</span></span><br><span class="line">[root@web03 ~]<span class="comment"># systemctl restart zabbix-agent2</span></span><br><span class="line">[root@web03 ~]<span class="comment"># systemctl status zabbix-agent2</span></span><br></pre></td></tr></table></figure><p><strong>zabbix 服务端 web界面配置</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405100954005.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405100955450.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405100956199.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405101048266.png" alt="img"></p><p><strong>配置主机</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405101049948.png" alt="img"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405101050284.png" alt="img"></p><p><strong>注意：如果主机可用性长时间没有变绿，则先重启被监控端zabbix-agnet2，和proxy端的zabbix-proxy。</strong></p><h3 id="22、zabbix优化方案"><a href="#22、zabbix优化方案" class="headerlink" title="22、zabbix优化方案"></a>22、zabbix优化方案</h3><ol><li><p>zabbix-proxy：当监控集群规模庞大时，使用zabbix-proxy，减少Zabbix Server的负载。</p></li><li><p>数据库优化：HA，读写分离，创建和维护适当的索引，减少查询时间。</p></li><li><p>主机和模版优化：简化配置管理，确保一致性；合理分组监控项，<strong>避免单个主机过多监控项</strong>；减少每个主机的监控负担，提高性能，使用低频率的监控项收集非关键数据，高频率的监控项收集关键数据。</p></li><li><p>触发器优化：减少触发器数量，避免不必要的复杂逻辑。</p></li><li><p>历史数据和趋势数据优化：设置合理的数据保留周期，减少数据库负担。定期清理旧数据，防止数据库膨胀。</p></li><li><p>调整 Zabbix 服务器参数：</p></li><li><ol><li><strong>StartPollers</strong>：控制 Zabbix 服务器同时运行的轮询器进程数量，<strong>建议设置为系统 CPU 核数的 2-4 倍</strong>。 轮询器负责主动从客户端（Zabbix Agent）或其他监控对象（如 HTTP、SNMP 等）获取数据。  </li><li><strong>StartTrappers</strong>：控制 Zabbix 服务器同时运行的 trapper 进程数量，<strong>建议设置为 10-20</strong>。 该进程用于接收 Zabbix 客户端和其他设备主动发送的数据（例如主动模式下的监控数据）。  </li><li><strong>CacheSize</strong>：用于存储历史数据和趋势数据的缓存大小，<strong>建议设置为系统内存的 10%-20%</strong>。<strong>以减少数据库负载</strong>。 缓存越大，Zabbix 可以更高效地处理和存储数据，从而减少对数据库的频繁读写操作。  </li><li><strong>HistoryCacheSize</strong>：历史缓存大小，用于缓存历史数据，减少数据库的 I/O 负载。建议：64M 到 256M，根据监控数据趋势计算的需求设置。  </li><li><strong>Timeout</strong>：设置 Zabbix 服务器与代理或受监控对象的通信超时时间，可以根据网络状况适当增加，但不宜过大，以免延迟过多。  </li><li><strong>StartDiscoverers：</strong>控制 Zabbix 服务器同时运行的发现进程数量，决定自动发现的并发能力。默认为1。</li><li><strong>StartDBSyncers</strong>：数据库同步进程数量，用于将数据从 Zabbix 缓存写入数据库。默认为4。</li></ol></li></ol><h3 id="23、zabbix结合Grafana实现图形展示"><a href="#23、zabbix结合Grafana实现图形展示" class="headerlink" title="23、zabbix结合Grafana实现图形展示"></a>23、zabbix结合Grafana实现图形展示</h3><p>详细请见后续文章。</p><h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Zabbix" scheme="https://l66stbz.github.io/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>企业自动化运维神器Ansible(2)</title>
    <link href="https://l66stbz.github.io/2024/08/21/%E4%BC%81%E4%B8%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%A5%9E%E5%99%A8Ansible(2)/"/>
    <id>https://l66stbz.github.io/2024/08/21/%E4%BC%81%E4%B8%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%A5%9E%E5%99%A8Ansible(2)/</id>
    <published>2024-08-21T13:50:00.000Z</published>
    <updated>2024-08-24T12:37:54.914Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Ansible-playbook-2"><a href="#Ansible-playbook-2" class="headerlink" title="Ansible-playbook(2)"></a>Ansible-playbook(2)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">group模块参数：</span><br><span class="line">name参数：必须参数，用于指定组名称。</span><br><span class="line">state参数：用于指定组的状态，两个值可选，present，absent，默认为 present，设置为absent 表示删除组。</span><br><span class="line">gid参数：用于指定组的gid。如果不指定为随机</span><br><span class="line">system参数:如果是yes为系统组。--可选</span><br><span class="line">=========================================================================================</span><br><span class="line">1.创建多个play</span><br><span class="line">[root@ansible ~]# cd /etc/ansible/</span><br><span class="line">[root@ansible ansible]# vim play.yml</span><br><span class="line">- hosts: webservers1</span><br><span class="line">  user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: create a group</span><br><span class="line">    group: name=mygrp gid=2003 system=true</span><br><span class="line">  - name: create a user</span><br><span class="line">    user: name=tom group=mygrp system=true</span><br><span class="line"></span><br><span class="line">- hosts: webservers2</span><br><span class="line">  user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install apache</span><br><span class="line">    yum: name=httpd state=latest</span><br><span class="line">  - name: start httpd service</span><br><span class="line">    service: name=httpd state=started</span><br><span class="line">=========================================================================================</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1569479193759.png" alt="1569479193759"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查并执行</span><br><span class="line">[root@ansible ansible]# ansible-playbook --syntax-check play.yml</span><br><span class="line">[root@ansible ansible]# ansible-playbook play.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2.条件执行when模块</span><br><span class="line">先判断when条件是否成立</span><br><span class="line">[root@ansible ansible]# cat /etc/ansible/hosts</span><br><span class="line">[webservers1]</span><br><span class="line">ansible-web1</span><br><span class="line">ansible-web2</span><br><span class="line"></span><br><span class="line">[root@ansible ansible]# vim when.yml</span><br><span class="line">- hosts: webservers1</span><br><span class="line">  user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: use when</span><br><span class="line">    file: state=touch path=/tmp/when.txt</span><br><span class="line">  - name: insert data</span><br><span class="line">    shell: echo 123 &gt;&gt; /tmp/when.txt          #2在执行这个模块命令</span><br><span class="line">    when: ansible_hostname == "ansible-web1"  #1.先条件执行，先判断when是否成立，如果成立则执行上面命令,ansible-web1指的是被控节点上真正的主机名称</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1569480152773.png" alt="1569480152773"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行</span><br><span class="line">[root@ansible ansible]# ansible-playbook when.yml</span><br><span class="line">[root@ansible-web1 ~]# cat /tmp/when.txt</span><br><span class="line">123</span><br><span class="line">[root@ansible-web2 ~]# cat /tmp/when.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">3.使用变量并不显示搜集主机相关信息</span><br><span class="line">gather_facts参数：指定了在任务部分执行前，是否先执行setup模块获取主机相关信息，默认值为true，改成false之后在执行过程中不会搜集主机相关信息。</span><br><span class="line">==========================================================================================================</span><br><span class="line">[root@ansible ansible]# vim create_user.yml</span><br><span class="line">- hosts: ansible-web1</span><br><span class="line">  user: root</span><br><span class="line">  gather_facts: false  #是否执行setup模块，搜集对方机器的信息</span><br><span class="line">  vars:                #自定义变量</span><br><span class="line">  - user: "jack"       #user是自定义变量名称，“jack”是变量值</span><br><span class="line">  - src_path: "/root/a.txt"    #同上</span><br><span class="line">  - dest_path: "/mnt/"</span><br><span class="line">  tasks:</span><br><span class="line">  - name: create user</span><br><span class="line">    user: name=&#123;&#123; user &#125;&#125;</span><br><span class="line">  - name: copy file</span><br><span class="line">    copy: src=&#123;&#123; src_path &#125;&#125; dest=&#123;&#123; dest_path &#125;&#125;</span><br><span class="line"></span><br><span class="line">[root@ansible ansible]# vim /root/a.txt  #创建测试文件</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1569482053656.png" alt="1569482053656"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行：</span><br><span class="line">[root@ansible ansible]# ansible-playbook create_user.yml</span><br></pre></td></tr></table></figure><h2 id="Role角色"><a href="#Role角色" class="headerlink" title="Role角色"></a>Role角色</h2><p>roles则是在ansible中，playbooks的目录组织结构。而模块化之后，成为roles的组织结构，易读，代码可重用，层次清晰。</p><p>实战目标：通过role远程部署nginx并配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">两台机器配置本地解析</span><br><span class="line">[root@ansible-server ~]# vim /etc/hosts</span><br><span class="line">192.168.1.9    ansible-server</span><br><span class="line">192.168.1.13   ansible-web4</span><br><span class="line">[root@ansible-web4 ~]# vim /etc/hosts</span><br><span class="line">192.168.1.9    ansible-server</span><br><span class="line">192.168.1.13   ansible-web4</span><br><span class="line">添加主机组</span><br><span class="line">[root@ansible-server ansible]# pwd</span><br><span class="line">/etc/ansible</span><br><span class="line">[root@ansible-server ansible]# vim hosts</span><br><span class="line">[webservers4]</span><br><span class="line">ansible-web4</span><br><span class="line">配置免密登录：</span><br><span class="line">[root@ansible-server ~]# ssh-copy-id -i 192.168.1.13</span><br></pre></td></tr></table></figure><p>1.目录结构：</p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567322212880.png" alt="1567322212880" style="zoom:50%;"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">目录顺序:</span><br><span class="line">role_name/     ---角色名称=目录</span><br><span class="line">    files/：存储一些可以用copy调用的静态文件。</span><br><span class="line">    tasks/： 存储任务的目录,此目录中至少应该有一个名为main.yml的文件，用于定义各task；其它的文件需要由main.yml进行“包含”调用； </span><br><span class="line">    handlers/:此目录中至少应该有一个名为main.yml的文件，用于定义各handler；其它的文件需要由（与notify:名字相同，方便notify通知执行下一条命令）通过main.yml进行“包含”调用； </span><br><span class="line">    vars/：此目录中至少应该有一个名为main.yml的文件，用于定义各variable；其它的文件需要由main.yml进行“包含”调用； </span><br><span class="line">    templates/：存储由template模块调用的模板文本； （也可以调用变量）</span><br><span class="line">    site.yml：定义哪个主机应用哪个角色</span><br><span class="line">=========================================================================================</span><br><span class="line">1.准备目录结构</span><br><span class="line">[root@ansible-server ~]# cd /etc/ansible/roles/  #roles为自带目录，如果不存在可以创建</span><br><span class="line">[root@ansible-server roles]# mkdir nginx/&#123;files,handlers,tasks,templates,vars&#125; -p</span><br><span class="line">2.创建文件</span><br><span class="line">[root@ansible-server roles]# touch site.yml nginx/&#123;handlers,tasks,vars&#125;/main.yml</span><br><span class="line">[root@ansible-server roles]# yum install -y tree</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567322899375.png" alt="1567322899375"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建nginx的测试文件</span><br><span class="line">[root@ansible-server roles]# echo 1234 &gt; nginx/files/index.html</span><br><span class="line">2.安装nginx并配置模板</span><br><span class="line">[root@ansible-server roles]# yum install -y nginx &amp;&amp; cp /etc/nginx/nginx.conf nginx/templates/nginx.conf.j2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3.编写任务</span><br><span class="line">[root@ansible-server roles]# vim nginx/tasks/main.yml</span><br><span class="line">---</span><br><span class="line">- name: install epel</span><br><span class="line">  yum: name=epel-release state=latest</span><br><span class="line">- name: install nginx</span><br><span class="line">  yum: name=nginx state=latest</span><br><span class="line">- name: copy nginx.conf templte</span><br><span class="line">  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">- name: copy index.html</span><br><span class="line">  copy: src=/etc/ansible/roles/nginx/files/index.html dest=/usr/share/nginx/html/index.html</span><br><span class="line">  notify: start nginx</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567329259385.png" alt="1567329259385"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.准备配置文件</span><br><span class="line">[root@ansible-server roles]# vim nginx/templates/nginx.conf.j2</span><br><span class="line">修改成如下内容。自定义变量</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567324084045.png" alt="1567324084045"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5.编写变量</span><br><span class="line">[root@ansible-server roles]# vim nginx/vars/main.yml  #添加如下内容</span><br><span class="line">worker_connections: 2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6.编写handlers</span><br><span class="line">[root@ansible-server roles]# vim nginx/handlers/main.yml #编写如下内容</span><br><span class="line">---</span><br><span class="line">- name: start nginx  #和notify的名字必须一样</span><br><span class="line">  service: name=nginx state=started</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7.编写剧本</span><br><span class="line">[root@ansible-server roles]# vim site.yml</span><br><span class="line">---</span><br><span class="line">- hosts: webservers4</span><br><span class="line">  user: root</span><br><span class="line">  roles:</span><br><span class="line">   - nginx</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567325911030.png" alt="1567325911030"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">检测语法</span><br><span class="line">[root@ansible-server roles]# ansible-playbook site.yml --syntax-check</span><br><span class="line">playbook: site.yml</span><br><span class="line">执行剧本：</span><br><span class="line">[root@ansible-server roles]# ansible-playbook site.yml</span><br></pre></td></tr></table></figure><p>查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-web4 ~]# netstat -lntp </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3102/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      926/sshd            </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1007/master         </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      3102/nginx: master  </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      926/sshd            </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1007/master         </span><br><span class="line">[root@ansible-web4 ~]# cat /etc/nginx/nginx.conf | grep pro</span><br><span class="line"><span class="meta">#</span><span class="bash">worker_processes auto;</span></span><br><span class="line">worker_processes 2;</span><br></pre></td></tr></table></figure><p>访问：</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567329307179.png" alt="1567329307179"></p><h2 id="项目实战：通过ansible上线"><a href="#项目实战：通过ansible上线" class="headerlink" title="项目实战：通过ansible上线"></a>项目实战：通过ansible上线</h2><h4 id="批量部署Jdk-Tomcat"><a href="#批量部署Jdk-Tomcat" class="headerlink" title="批量部署Jdk+Tomcat"></a>批量部署Jdk+Tomcat</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-server src]# cat tomcat.yml</span><br><span class="line">- hosts: webservers</span><br><span class="line">  user: root</span><br><span class="line">  tasks:</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#配置JDK，上传jdk、tomcat的安装包到/usr/src</span></span></span><br><span class="line">  - name: configure Jdk1.8</span><br><span class="line">    copy: src=/usr/src/jdk-8u211-linux-x64.tar.gz  dest=/usr/src</span><br><span class="line">  - name: unzip</span><br><span class="line">    shell: tar -xvzf /usr/src/jdk-8u211-linux-x64.tar.gz -C /usr/local</span><br><span class="line">  - name: rename to java</span><br><span class="line">    shell: mv /usr/local/jdk1.8.0_211 /usr/local/java</span><br><span class="line">  - name: configure envirement1</span><br><span class="line">    shell: echo "JAVA_HOME=/usr/local/java" &gt;&gt; /etc/profile</span><br><span class="line">  - name: configure envirement2</span><br><span class="line">    shell: echo 'PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#Tomcat</span></span></span><br><span class="line">  - name: copy tomcat</span><br><span class="line">    copy: src=/usr/src/apache-tomcat-8.5.45.tar.gz dest=/usr/src</span><br><span class="line">  - name: unzip tomcat</span><br><span class="line">    shell: tar -xvzf /usr/src/apache-tomcat-8.5.45.tar.gz -C /usr/local</span><br><span class="line">  - name: rename to tomcat</span><br><span class="line">    shell: mv /usr/local/apache-tomcat-8.5.45 /usr/local/tomcat</span><br><span class="line">  - name: copy startup file</span><br><span class="line">    copy:  src=/usr/src/startup.sh dest=/usr/local/tomcat/bin</span><br><span class="line">    notify: start tomcat</span><br><span class="line">  handlers:</span><br><span class="line">  - name: start tomcat</span><br><span class="line">    shell: nohup /usr/local/tomcat/bin/startup.sh &amp;</span><br><span class="line">[root@java-server src]# ls</span><br><span class="line">apache-tomcat-8.5.45         debug                       kernels     tomcat.retry</span><br><span class="line">apache-tomcat-8.5.45.tar.gz  jdk-8u211-linux-x64.tar.gz  startup.sh  tomcat.yml</span><br><span class="line">[root@java-server src]# head -2 startup.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="批量部署Jenkins"><a href="#批量部署Jenkins" class="headerlink" title="批量部署Jenkins"></a>批量部署Jenkins</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">项目描述：</span><br><span class="line">1.准备两台机器，一台作为nginx代理。一台为tomcat服务器。</span><br><span class="line">2.tomcat服务器手动部署tomcat服务，并将webapps目录下面的内容提前删掉。</span><br><span class="line">3.将jenkins.war包上传到nginx服务器。通过ansible将war包拷贝过去。并启动tomcat</span><br><span class="line">4.配置nginx反向代理tomcat，实现访问jenkins。</span><br><span class="line">操作如下:</span><br><span class="line">一、tomcat服务器</span><br><span class="line">1.安装jdk与tomcat略。</span><br><span class="line">2.添加tomcat启动脚本中添加环境变量</span><br><span class="line">[root@ansible-web2 ~]# vim /usr/local/tomcat/bin/startup.sh  #需要添加如下内容</span><br><span class="line">source /etc/profile</span><br><span class="line">====================================</span><br><span class="line">二、nginx服务器：</span><br><span class="line">1.安装nginx与ansible，上传jenkins的war包略。</span><br><span class="line">2.ansible配置如下：</span><br><span class="line">3.定义变量：</span><br><span class="line">[root@ansible ~]# cd /etc/ansible/</span><br><span class="line">[root@ansible ansible]# mkdir vars</span><br><span class="line">[root@ansible ansible]# vim vars/path.yml</span><br><span class="line">src_path: /root/jenkins.war</span><br><span class="line">dest_path: /usr/local/tomcat/webapps/</span><br><span class="line"></span><br><span class="line">4.配置playbook：</span><br><span class="line">[root@ansible ansible]# vim jenkins.yml</span><br><span class="line">- hosts: webserver2</span><br><span class="line">  user: root</span><br><span class="line">  vars_files:</span><br><span class="line">   - /etc/ansible/vars/path.yml</span><br><span class="line">  tasks:</span><br><span class="line">  - name: copy jenkins.war</span><br><span class="line">    copy: src=&#123;&#123; src_path &#125;&#125; dest=&#123;&#123; dest_path &#125;&#125;</span><br><span class="line">  - name: start tomcat</span><br><span class="line">    shell: nohup /usr/local/tomcat/bin/startup.sh &amp;</span><br><span class="line">[root@ansible ansible]# ansible-playbook jenkins.yml</span><br><span class="line"></span><br><span class="line">5.配置nginx反向代理</span><br><span class="line">[root@ansible ansible]# vim /etc/nginx/conf.d/jenkins.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    charset koi8-r;</span><br><span class="line">    access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location /jenkins &#123;</span><br><span class="line">        proxy_pass http://192.168.62.181:8080;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6.启动nginx</span><br><span class="line">7.检查nginx与tomcat是否启动成功！</span><br><span class="line">8.访问nginx服务器http://ip/jenkins。</span><br></pre></td></tr></table></figure><h4 id="批量部署Jdk-Tomcat-Jenkins"><a href="#批量部署Jdk-Tomcat-Jenkins" class="headerlink" title="批量部署Jdk+Tomcat+Jenkins"></a>批量部署Jdk+Tomcat+Jenkins</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将Jdk、Tomcat、Jenkins的安装包上传到ansbile控制节点的/usr/src下</span><br><span class="line">[root@ansible ansible]# ls /usr/src/</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1583207321017.png" alt="1583207321017"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@java-server ansible]# head -2 /usr/src/startup.sh //startup.sh是tomcat的启动脚本</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">source /etc/profile    #加上此行，是为了启动加载到环境变量</span><br></pre></td></tr></table></figure><p>下面是变量文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量文件</span><br><span class="line">[root@ansible ansible]# cat /etc/ansible/vars/file.yml</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1583207590404.png" alt="1583207590404"></p><p>下面是剧本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible ansible]# cat jenkins.yml</span><br><span class="line">- hosts: ansible-web1</span><br><span class="line">  user: root</span><br><span class="line">  vars_files:</span><br><span class="line">  - /etc/ansible/vars/file.yml</span><br><span class="line">  tasks:</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#配置JDK，上传jdk、tomcat的安装包到/usr/src</span></span></span><br><span class="line">  - name: configure JDK1.8</span><br><span class="line">    copy: src=&#123;&#123; src_jdk_path &#125;&#125;  dest=&#123;&#123; dest_jdk_path &#125;&#125;</span><br><span class="line">  - name: unzip JDK</span><br><span class="line">    shell: tar -xvzf /usr/src/jdk-8u211-linux-x64.tar.gz -C /usr/local</span><br><span class="line">  - name: rename to java</span><br><span class="line">    shell: mv /usr/local/jdk1.8.0_211 /usr/local/java</span><br><span class="line">  - name: configure JDK envirement1</span><br><span class="line">    shell: echo "JAVA_HOME=/usr/local/java" &gt;&gt; /etc/profile</span><br><span class="line">  - name: configure JDK envirement2</span><br><span class="line">    shell: echo 'PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#Tomcat</span></span></span><br><span class="line">  - name: copy tomcat</span><br><span class="line">    copy: src=&#123;&#123; src_tomcat_path &#125;&#125; dest=&#123;&#123; dest_tomcat_path &#125;&#125;</span><br><span class="line">  - name: unzip tomcat</span><br><span class="line">    shell: tar -xvzf /usr/src/apache-tomcat-8.5.45.tar.gz -C /usr/local</span><br><span class="line">  - name: rename to tomcat</span><br><span class="line">    shell: mv /usr/local/apache-tomcat-8.5.45 /usr/local/tomcat</span><br><span class="line">  - name: copy startup file</span><br><span class="line">    copy: src=/usr/src/startup.sh dest=/usr/local/tomcat/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#Jenkins</span></span></span><br><span class="line">  - name: copy jenkins</span><br><span class="line">    copy: src=/usr/src/jenkins.war  dest=/usr/local/tomcat/webapps/</span><br><span class="line">    notify: start jenkins</span><br><span class="line">  handlers:</span><br><span class="line">  - name: start jenkins</span><br><span class="line">    shell: nohup /usr/local/tomcat/bin/startup.sh &amp;</span><br></pre></td></tr></table></figure><h4 id="剧本实现批量部署Jdk-Tomcat-Jenkins"><a href="#剧本实现批量部署Jdk-Tomcat-Jenkins" class="headerlink" title="剧本实现批量部署Jdk+Tomcat+Jenkins"></a>剧本实现批量部署Jdk+Tomcat+Jenkins</h4><p>l66：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: webservers</span><br><span class="line">  user: root</span><br><span class="line">  vars: </span><br><span class="line">        install_dir: "/usr/local"</span><br><span class="line">  tasks: </span><br><span class="line">    - name: 解压安装到目标主机路径</span><br><span class="line">      unarchive: src=&#123;&#123; item &#125;&#125; dest=&#123;&#123; install_dir &#125;&#125;</span><br><span class="line">      loop: </span><br><span class="line">        - /opt/apache-tomcat-8.5.45.tar.gz</span><br><span class="line">        - /opt/jdk-8u211-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">    - name: tomcat目录改名</span><br><span class="line">      shell: mv &#123;&#123; install_dir &#125;&#125;/apache-tomcat-8.5.45  &#123;&#123; install_dir &#125;&#125;/tomcat</span><br><span class="line">    - name: jdk目录改名</span><br><span class="line">      shell: mv &#123;&#123; install_dir &#125;&#125;/jdk1.8.0_211   &#123;&#123; install_dir &#125;&#125;/java</span><br><span class="line"></span><br><span class="line">    - name: 声明jdk环境变量</span><br><span class="line">      copy:</span><br><span class="line">        content: |</span><br><span class="line">         JAVA_HOME=/usr/local/java</span><br><span class="line">         PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">        dest: /etc/profile.d/java.sh</span><br><span class="line"></span><br><span class="line">    - name: 上限Jenkins</span><br><span class="line">      copy: src=/opt/jenkins.war dest=/usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line">    - name: 重新加载环境变量，并启动Tomcat</span><br><span class="line">      shell: source /etc/profile.d/java.sh &amp;&amp; nohup /usr/local/tomcat/bin/startup.sh &amp;</span><br></pre></td></tr></table></figure><p>ming：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: web01</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: 解压安装包到目标主机</span><br><span class="line">      unarchive: src=&#123;&#123; item &#125;&#125; dest=/usr/local/</span><br><span class="line">      loop:</span><br><span class="line">       - /opt/jdk-8u211-linux-x64.tar.gz</span><br><span class="line">       - /opt/apache-tomcat-8.5.45.tar.gz</span><br><span class="line">    </span><br><span class="line">    - name: 声明jdk变量</span><br><span class="line">      copy: </span><br><span class="line">        content: |</span><br><span class="line">          JAVA_HOME=/usr/local/jdk1.8.0_211</span><br><span class="line">          PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">        dest: /etc/profile.d/jdk.sh</span><br><span class="line">    </span><br><span class="line">    - name: 上线jenkins</span><br><span class="line">      copy: src=/root/jenkins.war  dest=/usr/local/apache-tomcat-8.5.45/webapps</span><br><span class="line">      notify: start tomcat</span><br><span class="line"></span><br><span class="line">  handlers:</span><br><span class="line">  - name: start tomcat</span><br><span class="line">    shell: source /etc/profile.d/jdk.sh &amp;&amp; nohup /usr/local/apache-tomcat-8.5.45/bin/startup.sh &amp;</span><br></pre></td></tr></table></figure><h4 id="剧本实现编译安装nginx"><a href="#剧本实现编译安装nginx" class="headerlink" title="剧本实现编译安装nginx"></a>剧本实现编译安装nginx</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: web09</span><br><span class="line">  user: root</span><br><span class="line">  vars:</span><br><span class="line">        install_dir: "/usr/local"</span><br><span class="line">  tasks: </span><br><span class="line">    - name: 安装编译环境</span><br><span class="line">      yum: name=&#123;&#123; item &#125;&#125; state=present</span><br><span class="line">      loop: </span><br><span class="line">        - gcc</span><br><span class="line">        - gcc-c++</span><br><span class="line">        - pcre</span><br><span class="line">        - pcre-devel</span><br><span class="line">        - openssl</span><br><span class="line">        - openssl-devel</span><br><span class="line">        - zlib</span><br><span class="line">        - zlib-devel</span><br><span class="line">    </span><br><span class="line">    - name: 创建用户nginx</span><br><span class="line">      user: name=nginx state=present shell=/sbin/nologin</span><br><span class="line"></span><br><span class="line">    - name: 解压安装包</span><br><span class="line">      unarchive: src=/opt/nginx-1.24.0.tar.gz dest=&#123;&#123; install_dir &#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: 编译安装</span><br><span class="line">      shell: cd /usr/local/nginx-1.24.0/ &amp;&amp; ./configure --prefix=/usr/local/nginx --group=nginx --user=nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream  &amp;&amp;  make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">    - name: 创建目录/tmp/nginx</span><br><span class="line">      file: path=/tmp/nginx state=directory</span><br><span class="line"></span><br><span class="line">    - name: 配置systemd启动脚本</span><br><span class="line">      copy: </span><br><span class="line">        content: |</span><br><span class="line">         <span class="section">[Unit]</span></span><br><span class="line">         Description=nginx - high performance web server</span><br><span class="line">         Documentation=http://nginx.org/en/docs/</span><br><span class="line">         After=network-online.target remote-fs.target nss-lookup.target</span><br><span class="line">         Wants=network-online.target</span><br><span class="line"></span><br><span class="line">         <span class="section">[Service]</span></span><br><span class="line">         Type=forking</span><br><span class="line">         PIDFile=/var/run/nginx.pid</span><br><span class="line">         ExecStart=/usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">         ExecReload=/bin/sh -c "/bin/kill -s HUP \$(/bin/cat /var/run/nginx.pid)"</span><br><span class="line">         ExecStop=/bin/sh -c "/bin/kill -s TERM \$(/bin/cat /var/run/nginx.pid)"</span><br><span class="line"></span><br><span class="line">         <span class="section">[Install]</span></span><br><span class="line">         WantedBy=multi-user.target </span><br><span class="line">        dest: /lib/systemd/system/nginx.service</span><br><span class="line"></span><br><span class="line">    - name: 启动nginx</span><br><span class="line">      service: name=nginx state=started enabled=yes</span><br></pre></td></tr></table></figure><h4 id="剧本实现mysql登陆、修改密码、刷新权限、建库和导入数据"><a href="#剧本实现mysql登陆、修改密码、刷新权限、建库和导入数据" class="headerlink" title="剧本实现mysql登陆、修改密码、刷新权限、建库和导入数据"></a>剧本实现mysql登陆、修改密码、刷新权限、建库和导入数据</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: web09</span><br><span class="line">  user: root</span><br><span class="line">  vars:</span><br><span class="line">    root_password: "1"</span><br><span class="line">    new_password: "ldqldq666"</span><br><span class="line">    db_name: "ruoyi"</span><br><span class="line">    db_charset: "utf8mb4" </span><br><span class="line">  tasks:</span><br><span class="line">    - name: 修改mysql密码并设置允许远程连接</span><br><span class="line">      mysql_user:</span><br><span class="line">        name: root</span><br><span class="line">        host: '%'</span><br><span class="line">        password: "&#123;&#123; new_password &#125;&#125;"</span><br><span class="line">        priv: '*.*:ALL,GRANT'</span><br><span class="line">        state: present</span><br><span class="line">        login_user: root</span><br><span class="line">        login_password: "&#123;&#123; root_password &#125;&#125;"</span><br><span class="line"></span><br><span class="line">    - name: 刷新权限</span><br><span class="line">      mysql_db:</span><br><span class="line">        name: mysql</span><br><span class="line">        state: import</span><br><span class="line">        target: /dev/null</span><br><span class="line">        login_user: root</span><br><span class="line">        login_password: "&#123;&#123; new_password &#125;&#125;"</span><br><span class="line">      ignore_errors: yes</span><br><span class="line"></span><br><span class="line">    - name: 重启mysql</span><br><span class="line">      service:</span><br><span class="line">        name: mysqld</span><br><span class="line">        state: restarted</span><br><span class="line"></span><br><span class="line">    - name: 创建ruoyi数据库</span><br><span class="line">      mysql_db:</span><br><span class="line">        name: "&#123;&#123; db_name &#125;&#125;"</span><br><span class="line">        encoding: "&#123;&#123; db_charset &#125;&#125;"</span><br><span class="line">        state: present</span><br><span class="line">        login_user: root</span><br><span class="line">        login_password: "&#123;&#123; new_password &#125;&#125;"</span><br><span class="line"></span><br><span class="line">    - name: 导入数据</span><br><span class="line">      shell: mysql -uroot -p'&#123;&#123; new_password  &#125;&#125;'  ruoyi &lt; /root/RuoYi-Vue/sql/ry_20240629.sql</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Ansible" scheme="https://l66stbz.github.io/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>企业自动化运维神器Ansible(1)</title>
    <link href="https://l66stbz.github.io/2024/08/20/%E4%BC%81%E4%B8%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%A5%9E%E5%99%A8Ansible(1)/"/>
    <id>https://l66stbz.github.io/2024/08/20/%E4%BC%81%E4%B8%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%A5%9E%E5%99%A8Ansible(1)/</id>
    <published>2024-08-20T13:50:00.000Z</published>
    <updated>2024-08-24T06:07:26.872Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="企业级自动化运维工具Ansible"><a href="#企业级自动化运维工具Ansible" class="headerlink" title="企业级自动化运维工具Ansible"></a>企业级自动化运维工具Ansible</h1><p>[TOC]</p><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h3 id="1、自动化运维发展历程"><a href="#1、自动化运维发展历程" class="headerlink" title="1、自动化运维发展历程"></a>1、自动化运维发展历程</h3><ol><li><h4 id="手动运维阶段"><a href="#手动运维阶段" class="headerlink" title="手动运维阶段"></a><strong>手动运维阶段</strong></h4></li></ol><p><strong>特点：</strong></p><ul><li><strong>早期计算机时代</strong>：主要依赖运维人员手动管理服务器等。</li><li><strong>集中管理和人工操作</strong>：系统更新、配置、监控、故障排查等任务全部手动完成。</li><li><strong>局限性</strong>：效率低下、容易出现人为错误，且无法应对大规模环境。</li></ul><p><strong>典型场景：</strong>小型数据中心，几台服务器，运维人员使用SSH等手动登录服务器进行操作。</p><ol start="2"><li><h4 id="脚本化运维阶段"><a href="#脚本化运维阶段" class="headerlink" title="脚本化运维阶段"></a><strong><code>脚本化运维阶段</code></strong></h4></li></ol><p><strong>特点</strong>：</p><ul><li><strong>自动化初步萌芽</strong>：运维人员开始使用Shell、Python、Perl等脚本语言来实现部分重复性任务的自动化，如批量部署、日志收集、监控和报警等。</li><li><strong>自定义脚本和工具</strong>：企业根据需求编写自定义脚本来简化日常运维工作，减少手动操作。</li></ul><p><strong>典型场景：</strong>通过Shell脚本实现批量管理、定时任务调度等，减轻重复性工作负担。</p><ol start="3"><li><h4 id="运维工具化阶段"><a href="#运维工具化阶段" class="headerlink" title="运维工具化阶段"></a><strong><code>运维工具化阶段</code></strong></h4></li></ol><p><strong>特点：</strong></p><ul><li><strong>引入专用运维工具</strong>：随着IT基础设施的复杂化，运维工具逐渐普及。常见工具如Puppet、Ansible、SaltStack等开始出现，提供了标准化的自动化运维能力。</li><li><strong>集中式管理</strong>：通过工具的集中式管理能力，运维人员可以统一管理多台服务器，实现大规模环境下的自动化部署、配置管理和系统更新。</li></ul><p><strong>典型应用：</strong>使用Puppet进行配置管理，Ansible进行批量操作，SaltStack进行大规模部署。</p><ol start="4"><li><h4 id="容器化和微服务运维阶段"><a href="#容器化和微服务运维阶段" class="headerlink" title="容器化和微服务运维阶段"></a><strong><code>容器化和微服务运维阶段</code></strong></h4></li></ol><p><strong>特点：</strong></p><ul><li><strong>容器化</strong>：随着Docker和Kubernetes等技术的普及，运维自动化进入了容器化时代。基础设施以容器为单位进行管理，运维流程更加简化和标准化。</li><li><strong>微服务架构</strong>：应用被拆解为独立的微服务，运维需要应对大量的分布式服务，自动化工具集成了容器编排、服务发现、动态伸缩等功能。</li><li><strong>持续集成和持续交付（CI/CD）</strong>：Jenkins、GitLab CI等工具与Kubernetes和Docker相结合，实现了自动化的应用交付和部署。</li></ul><p><strong>典型应用：</strong>Kubernetes用于容器编排，结合CI/CD流水线实现自动化应用发布和扩展。</p><h3 id="2、自动化运维工具对比"><a href="#2、自动化运维工具对比" class="headerlink" title="2、自动化运维工具对比"></a>2、自动化运维工具对比</h3><ul><li><strong>Puppet：</strong>基于 Ruby 开发,采用 C/S 架构,扩展性强,基于SSL,远程命令执行相对较弱；</li><li><strong>SaltStack：</strong>基于 Python 开发,采用 C/S 架构,相对 puppet 更轻量级,配置语法使用YAML,使得配置脚本更简单.需要配置客户端以及服务器端。每台被控制节点需要安装agent；</li><li><strong>Ansible：</strong>基于Python开发,分布式,无需客户端,轻量级,配置语法使用YAML语言,更强的远程命令执行操作。</li></ul><h3 id="3、Ansible简介"><a href="#3、Ansible简介" class="headerlink" title="3、Ansible简介"></a>3、Ansible简介</h3><p>​    <strong>ansible是自动化运维工具，基于Python开发、分布式、无需客户端、轻量级。实现了批量系统配置、批量程序部署、批量运行命令等功能。</strong></p><p><strong>ansible是基于模块工作的,本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块,ansible只是提供一种框架。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ansible特性</span><br><span class="line">    1)、no agents：不需要在被管控主机上安装任何客户端,更新时,只需在操作机上进行一次更新即可（不用安装客户端。分布式的）</span><br><span class="line">    2)、no server：无服务器端,使用时直接运行命令即可</span><br><span class="line">    3)、modules in any languages：基于模块工作,可使用任意语言开发模块</span><br><span class="line">    4)、yaml,not code：使用yaml语言定制剧本playbook</span><br><span class="line">    5)、ssh by default：基于SSH工作</span><br><span class="line">    6)、strong multi-tier solution：可实现多级指挥</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567243310363.png" alt="1567243310363"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection plugins：连接插件,负责和被监控端实现通信,默认使用SSH连接。</span><br><span class="line">host inventory：主机清单,是一个配置文件里面定义监控的主机。</span><br><span class="line">modules : 模块,核心模块、command模块、自定义模块等。</span><br><span class="line">plugins : modules功能的补充,包括连接插件,邮件插件等。</span><br><span class="line">playbook：编排,定义 Ansible 多任务配置文件,非必需。</span><br></pre></td></tr></table></figure><h2 id="二、ansible安装"><a href="#二、ansible安装" class="headerlink" title="二、ansible安装"></a>二、ansible安装</h2><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.  环境准备"></a>1.  环境准备</h4><ol><li><strong>初始化工作</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 本地解析</span></span><br><span class="line">$ cat /etc/hosts</span><br><span class="line">192.168.174.20 ansible-server</span><br><span class="line">192.168.174.21 ansible-web01</span><br><span class="line">192.168.174.22 ansible-web02</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 关闭防火墙及selinux</span></span><br><span class="line">$ systemctl disable --now firewalld &amp;&amp; setenforce 0</span><br><span class="line">$ sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config</span><br></pre></td></tr></table></figure><ol start="2"><li><strong><code>ansible-server</code>生成SSH密钥对</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 生成密钥</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ssh-keygen</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看密钥</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ll ~/.ssh/</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-------. 1 root root 1679 8月  18 13:33 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  408 8月  18 13:33 id_rsa.pub</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>ansible-server</code>传递公钥</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 传递公钥</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># for i in ansible-web0&#123;1..2&#125;;do ssh-copy-id -i $i;done</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>安装</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 配置EPEL网络yum源</span></span><br><span class="line">[root@ansible-server ~]# curl -o /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装ansible</span></span><br><span class="line">[root@ansible-server ~]# yum install -y ansible</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看版本</span></span><br><span class="line">[root@ansiable-server ~]# ansible --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看帮助</span></span><br><span class="line">[root@ansible-server ~]# ansible --help</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181440961.png" alt="image-20240818144013877"></p><h2 id="三、Ansible-文件介绍"><a href="#三、Ansible-文件介绍" class="headerlink" title="三、Ansible 文件介绍"></a>三、Ansible 文件介绍</h2><h3 id="1、主配置文件"><a href="#1、主配置文件" class="headerlink" title="1、主配置文件"></a>1、主配置文件</h3><p><strong>文件位置：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/ansible/ansible.cfg</span><br></pre></td></tr></table></figure><p><strong>常用文件内容介绍：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#inventory      = /etc/ansible/hosts</span></span><br><span class="line"><span class="comment">#library        = /usr/share/my_modules/</span></span><br><span class="line"><span class="comment">#module_utils   = /usr/share/my_module_utils/</span></span><br><span class="line"><span class="comment">#remote_tmp     = ~/.ansible/tmp</span></span><br><span class="line"><span class="comment">#local_tmp      = ~/.ansible/tmp</span></span><br><span class="line"><span class="comment">#plugin_filters_cfg = /etc/ansible/plugin_filters.yml</span></span><br><span class="line"><span class="comment">#forks          = 5</span></span><br><span class="line"><span class="comment">#poll_interval  = 15</span></span><br><span class="line"><span class="comment">#sudo_user      = root</span></span><br><span class="line"><span class="comment">#ask_sudo_pass = True</span></span><br><span class="line"><span class="comment">#ask_pass      = True</span></span><br><span class="line"><span class="comment">#transport      = smart</span></span><br><span class="line"><span class="comment">#remote_port    = 22</span></span><br></pre></td></tr></table></figure><ol><li><code>#inventory = /etc/ansible/hosts</code></li></ol><ul><li><strong>解释</strong>： Ansible 的默认<code>主机清单</code>位置。主机清单列出了目标主机的 IP 地址或主机名。</li></ul><ol start="2"><li><code>#library = /usr/share/my_modules/</code></li></ol><ul><li><strong>解释</strong>：指定 Ansible 自定义模块的库路径。默认情况下，Ansible 使用内置的模块，但通过设置 <code>library</code>，你可以将自己编写的自定义模块放在 <code>/usr/share/my_modules/</code> 目录中。</li></ul><ol start="4"><li><code>#remote_tmp = ~/.ansible/tmp</code></li></ol><ul><li><strong>解释</strong>：指定 Ansible 在远程主机上存储临时文件的路径。默认情况下，Ansible 会在远程主机的 <code>~/.ansible/tmp</code> 目录中创建临时文件和目录。</li></ul><ol start="5"><li><code>#local_tmp = ~/.ansible/tmp</code></li></ol><ul><li><strong>解释</strong>：指定 Ansible 在本地主机上存储临时文件的路径。Ansible 会在执行任务时在本地生成临时文件，默认路径是 <code>~/.ansible/tmp</code>。</li></ul><ol start="6"><li><code>#plugin_filters_cfg = /etc/ansible/plugin_filters.yml</code></li></ol><ul><li><strong>解释</strong>：过滤 Ansible 插件的配置文件路径。这个配置文件控制哪些插件可以加载和使用。</li></ul><ol start="7"><li><code>#forks = 5</code></li></ol><ul><li><strong>解释</strong>：Ansible 并行处理的最大任务数量。</li></ul><ol start="8"><li><code>#poll_interval = 15</code></li></ol><ul><li><strong>解释</strong>：Ansible 检查后台任务状态的轮询间隔，单位是秒。默认情况下，Ansible 每隔 15 秒检查一次后台运行的任务状态。</li></ul><ol start="9"><li><code>#sudo_user = root</code></li></ol><ul><li><strong>解释</strong>：远程主机上执行命令时的默认 sudo 用户。这里配置的是 <code>root</code> 用户，意味着 Ansible 在使用 sudo 提权时会尝试以 root 用户身份执行任务。</li></ul><ol start="10"><li><code>#ask_sudo_pass = True</code></li></ol><ul><li><strong>解释</strong>：Ansible 将在运行任务时提示输入 sudo 密码。这在目标主机配置了需要输入 sudo 密码的情况下使用。</li></ul><ol start="11"><li><code>#ask_pass = True</code></li></ol><ul><li><strong>解释</strong>：Ansible 将在运行任务时提示输入 SSH 密码。如果目标主机不使用密钥认证而是通过密码登录，可以启用此项。</li></ul><ol start="12"><li><code>#transport = smart</code></li></ol><ul><li><strong>解释</strong>：Ansible 与目标主机通信时使用的传输方式。默认的 <code>smart</code> 模式会自动选择最佳的传输方式（通常是基于 SSH）。</li></ul><ol start="13"><li><code>#remote_port = 22</code></li></ol><ul><li><strong>解释</strong>：Ansible 连接到远程主机时使用的默认 SSH 端口。默认值为 <code>22</code>。</li></ul><h3 id="2、主机清单"><a href="#2、主机清单" class="headerlink" title="2、主机清单"></a>2、主机清单</h3><p><strong>文件位置：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/ansible/hosts</span><br></pre></td></tr></table></figure><p>官方文档:  <a href="http://docs.ansible.com/ansible/intro_inventory.html#" target="_blank" rel="noopener">http://docs.ansible.com/ansible/intro_inventory.html#</a></p><p><strong><code>Inventory文件</code>通常用于定义要管理主机的认证信息，例如ssh登录用户名、密码以及key相关信息。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看配置文件</span></span><br><span class="line">[root@ansible-server ~]# rpm  -qc ansible</span><br><span class="line">/etc/ansible/ansible.cfg</span><br><span class="line">/etc/ansible/hosts#ansible主机清单文件</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt;语法:</span></span><br><span class="line">[root@ansible-server ~]# vim /etc/ansible/hosts</span><br><span class="line">ansible-web1  # 单独指定主机，可以使用主机名称或IP地址</span><br><span class="line"></span><br><span class="line">[webservers]  # 主机群组自定义</span><br><span class="line">192.168.174.21 # 未做本地解析的主机地址</span><br><span class="line">192.168.174.22 # 未做本地解析的主机地址</span><br><span class="line"></span><br><span class="line">[dbservers] # 自定义主机群组</span><br><span class="line">192.168.174.[21:22]</span><br><span class="line"></span><br><span class="line">[zabbix] # 自定义主机群组</span><br><span class="line">192.168.174.21:22 # 未做本地解析的主机地址加端口</span><br><span class="line"></span><br><span class="line">[redis] # 自定义主机名</span><br><span class="line">ansible-web02 # 经过本地解析的主机名</span><br><span class="line"></span><br><span class="line">[servers:children] # 集合多个子群组</span><br><span class="line">zabbix</span><br><span class="line">redis</span><br><span class="line"></span><br><span class="line">[webservers01] # 自定义主机群组</span><br><span class="line">ansible-web0[1:2] # 经过本地解析的主机名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为一个组指定变量，组内每个主机都可以使用该变量：</span></span><br><span class="line">[weball:vars]         # 设置变量,vars--照写</span><br><span class="line">ansible_ssh_port=2222     </span><br><span class="line">ansible_ssh_user=root   </span><br><span class="line">ansible_ssh_private_key_file=/root/.ssh/id_rsa  </span><br><span class="line"><span class="meta">#</span><span class="bash">ansible_ssh_pass=<span class="built_in">test</span>      <span class="comment">#也可以定义密码，如果没有互传秘钥可以使用密码。</span></span></span><br></pre></td></tr></table></figure><p> Ansible Inventory 常见的内置参数：</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567262857205.png" alt="1567262857205"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看组内主机列表：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法：ansible  组名  --list-hosts</span></span><br><span class="line">[root@ansible-server ~]# ansible webservers --list-host</span><br><span class="line">  hosts (2):</span><br><span class="line">    192.168.174.21</span><br><span class="line">    192.168.174.22</span><br></pre></td></tr></table></figure><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p><code>Ansible</code>常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 列出所有模块</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible-doc -l</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看某个模块帮助用法</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible-doc ping</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看某个模块帮助用法</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible-doc  -s ping</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="meta">#</span><span class="bash"> ansible  &lt;pattern&gt;   -m &lt;module_name&gt;   -a &lt;arguments&gt;</span></span><br><span class="line">pattern--主机清单里定义的主机组名、主机名、IP等,all表示所有的主机,支持通配符,正则</span><br><span class="line">-m# 模块名称,默认为command</span><br><span class="line">-a# 传递给模块的参数</span><br><span class="line">-o# 单行显示</span><br><span class="line">-c# 检查，不执行命令</span><br><span class="line">-k# 提示输入ssh连接密码。默认ssh key认证</span><br><span class="line">-v# 详细过程 -vv -vvv更详细</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 示例</span></span><br><span class="line">[root@ansible-server ~]# ansible webservers -m ping</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181526198.png" alt="image-20240818152656146"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-server ~]<span class="comment"># ansible all -m ping -o</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181605472.png" alt="image-20240818160505421"></p><p>使用案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 指定单台机器：</span></span><br><span class="line">[root@ansible-server ~]# ansible ansible-web1 -m ping -o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 同时指定多台机器：</span></span><br><span class="line">[root@ansible-server ~]# ansible ansible-web1,ansible-web2 -m ping -o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 指定组名:</span></span><br><span class="line">[root@ansible-server ~]# ansible  webservers1 -m ping -o</span><br></pre></td></tr></table></figure><h3 id="4、Ansible执行过程"><a href="#4、Ansible执行过程" class="headerlink" title="4、Ansible执行过程"></a>4、Ansible执行过程</h3><ol><li><p>Ansible 在执行命令之前会加载配置文件（通常位于 <code>/etc/ansible/ansible.cfg</code>）并读取主机清单文件。</p></li><li><p>Ansible 根据配置文件或命令行参数决定如何连接远程主机。</p></li><li><p>Ansible 使用<strong>模块</strong>（module）在远程主机上执行具体任务。Ansible 会将模块发送到远程主机，并通过 Python 解释器或其他指定解释器执行这些模块。但需要注意的是：ansible会将模块或者命令生成对应的临时文件，并将文件通过ssh传输至远程主机的对应执行用户的<code>$HOME/.ansible/tmp/ansible-tmp-随机数字/随机字符串.py</code>文件。并添加执行权限。</p></li><li><p>模块执行完成后，Ansible 会收集结果并将其返回到控制节点。每个模块返回的数据为 JSON 格式，Ansible 会将这些数据解析为易读的输出，显示在控制台中。删除临时py文件。并退出。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 测试</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible all -m ping  -vvv   &gt; test.log</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># grep rm  test.log</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181647679.png" alt="image-20240818164734639"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-server ~]<span class="comment"># grep rm  test.log</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181648295.png" alt="image-20240818164827261"></p><h3 id="5、Ansible执行颜色分类"><a href="#5、Ansible执行颜色分类" class="headerlink" title="5、Ansible执行颜色分类"></a>5、Ansible执行颜色分类</h3><ul><li><p><strong><code>绿色</code></strong>：执行成功并且没有改变内容；</p></li><li><p><strong><code>黄色</code></strong>：执行成功并且对目标主机做的更改操作；</p></li><li><p><strong><code>红色</code></strong>：命令或模块没有执行成功。</p></li></ul><h3 id="6、Ansible中shell模块几乎可以做任何事情，那为什么要有别的那么多模块且写剧本的时候明明可以从头到尾使用shell模块，但是为什么还是要使用别的模块呢？"><a href="#6、Ansible中shell模块几乎可以做任何事情，那为什么要有别的那么多模块且写剧本的时候明明可以从头到尾使用shell模块，但是为什么还是要使用别的模块呢？" class="headerlink" title="6、Ansible中shell模块几乎可以做任何事情，那为什么要有别的那么多模块且写剧本的时候明明可以从头到尾使用shell模块，但是为什么还是要使用别的模块呢？"></a>6、Ansible中shell模块几乎可以做任何事情，那为什么要有别的那么多模块且写剧本的时候明明可以从头到尾使用shell模块，但是为什么还是要使用别的模块呢？</h3><p>因为幂等性。在 Ansible 中，幂等性指的是运行相同的剧本或任务多次时，其结果应该是相同的，不会产生副作用或重复更改。也就是说，不论你执行剧本多少次，系统的最终状态都应保持一致，不会改变。</p><p>而如果我们从头到尾shell的话，是无法保证幂等性的，有的时候可能一些操作之前已经之前过了，如果使用shell的话他还会再给我们执行一次，回显颜色会为黄色。但是如果我们使用的是其对应功能的模块的话，那么他会检查我们之前是否做过这步操作，如果做过他就不会再执行。回显为绿色。</p><p>所以这会对运维人员有些许干扰，因为大部分情况我们会根据回显颜色来判断执行的结果。情况严重的话，有可能会产生一些副作用。</p><p>ansible中分模块来干不同的事情有点类似于微服务架构，采用分布式，降低了紧密型（解耦），增加了可维护性。</p><h2 id="四、Ansible模块使用"><a href="#四、Ansible模块使用" class="headerlink" title="四、Ansible模块使用"></a>四、Ansible模块使用</h2><h3 id="1、command模块（默认）"><a href="#1、command模块（默认）" class="headerlink" title="1、command模块（默认）"></a>1、<code>command</code>模块（默认）</h3><p>​    <code>ansible</code> 的 <code>command</code> 模块是最常用的模块之一，它用于在远程主机上运行命令。与 <code>shell</code> 模块不同的是，<code>command</code> 模块执行命令时不会通过 shell 执行，因此不支持管道、重定向等 shell 特性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m command -a "uptime"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181659986.png" alt="image-20240818165933947"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers  -a "df -Th"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181659305.png" alt="image-20240818165959247"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers  -a "ls "</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181701718.png" alt="image-20240818170134686"></p><h3 id="2、shell模块"><a href="#2、shell模块" class="headerlink" title="2、shell模块"></a>2、<code>shell</code>模块</h3><p>​        Ansible 的 <code>shell</code> 模块用于在远程主机上通过 shell 执行命令。与 <code>command</code> 模块不同的是，<code>shell</code> 模块允许你使用所有的 shell 特性，例如管道、重定向、变量扩展等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers  -m shell  -a "df -Th | grep root"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181705083.png" alt="image-20240818170522034"></p><h3 id="3、USER模块"><a href="#3、USER模块" class="headerlink" title="3、USER模块"></a>3、<code>USER</code>模块</h3><p>​         <code>user</code> 模块用于在远程主机上管理用户账户。它能够创建、删除、修改用户以及设置用户的权限、组和密码等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建用户</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m user -a "name=maoxiansheng state=present" -o</span></span><br><span class="line"></span><br><span class="line">name<span class="comment"># 用户名</span></span><br><span class="line">state<span class="comment"># 创建</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181713168.png" alt="image-20240818171306121"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 删除用户</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m user -a "name=maoxiansheng state=absent remove=yes"  -o</span></span><br><span class="line"></span><br><span class="line">name<span class="comment"># 用户名</span></span><br><span class="line">state<span class="comment"># 删除操作</span></span><br><span class="line">remove<span class="comment"># 慎用！删除用户时，除了删除用户本身，还会删除该用户的相关资源（如用户的家目录及相关文件）。默认情况下，这个选项是 no，即只删除用户而不删除其文件。</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181714153.png" alt="image-20240818171430115"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建用户并设置Shell和主目录</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  webservers -m user -a "user=mingge home=/home/mingge state=present shell=/bin/bash" -o</span></span><br><span class="line"></span><br><span class="line">name<span class="comment"># 用户名</span></span><br><span class="line">state<span class="comment"># 创建</span></span><br><span class="line">shell<span class="comment"># 指定所创建用户shell</span></span><br><span class="line">home<span class="comment"># 指定所创建用户家目录</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181717407.png" alt="image-20240818171717360"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 添加用户到指定组</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m user -a "name=feige groups=mingge append=yes password='123'"  -o</span></span><br><span class="line"></span><br><span class="line">name<span class="comment"># 用户名</span></span><br><span class="line">groups<span class="comment"># 加入指定组</span></span><br><span class="line">append<span class="comment"># 不会删除他已经属于的其他组。即追加到该组，而不是替换原来的组。</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408181723058.png" alt="image-20240818172331003"></p><h3 id="4、yum模块"><a href="#4、yum模块" class="headerlink" title="4、yum模块"></a>4、<code>yum</code>模块</h3><p>​     <code>yum</code> 模块用于主要通过 <code>yum</code> 包管理器进行安装、升级、删除和管理仓库。它是处理软件包的一个常见模块，适用于基于 <code>yum</code> 包管理器的 Linux 发行版。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 安装服务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m yum -a "name=nginx state=present"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 删除服务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m yum -a "name=nginx state=removed"</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m yum -a "name=nginx state=absent" </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 升级软件包到最新版本</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m yum -a "name=nginx state=latest" </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 安装指定版本</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m yum -a "name=nginx-1.24.0  state=present" </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 安装多个软件包</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m yum -a "name=git,vim state=present"</span></span><br></pre></td></tr></table></figure><h3 id="5、service模块"><a href="#5、service模块" class="headerlink" title="5、service模块"></a>5、<code>service</code>模块</h3><p>​        <code>service</code> 模块用于管理系统服务，例如启动、停止、重启服务或确保服务处于特定状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 启动服务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m service -a "name=nginx  state=started"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 停止服务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m service -a "name=nginx  state=stopped"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重启服务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m service -a "name=nginx  state=restarted"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 启动服务并加入开机自启</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m service -a "name=nginx  state=started enabled=yes"</span></span><br></pre></td></tr></table></figure><h3 id="6、file模块"><a href="#6、file模块" class="headerlink" title="6、file模块"></a>6、<code>file</code>模块</h3><p>​        <code>file</code> 模块用于管理文件、目录和符号链接的属性，包括创建、删除、修改权限等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建目录</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m file -a "path=/tmp/mingge state=directory" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建文件</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m file -a "path=/tmp/mingge/1.txt state=touch" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 删除目录或者文件</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m file -a "path=/tmp/mingge/1.txt state=absent" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改文件权限</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m file -a "path=/tmp/mingge mode=0777" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改文件属主和属组</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m file -a "path=/tmp/mingge/ owner=mingge group=mingge" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建文件并设置权限</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m file -a "path=/tmp/2.txt state=touch mode=0777 owner=mingge group=mingge" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建符号链接</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m file -a "src=/tmp/2.txt dest=/root/2.txt state=link" -o</span></span><br></pre></td></tr></table></figure><h3 id="7、copy模块"><a href="#7、copy模块" class="headerlink" title="7、copy模块"></a>7、<code>copy</code>模块</h3><p>​         <code>copy</code> 模块用于从控制节点将文件或目录复制到目标主机。</p><p><strong>常见选项：</strong></p><ul><li><strong><code>src</code></strong>：源文件或目录的路径。</li><li><strong><code>dest</code></strong>：目标路径。</li><li><strong><code>backup</code></strong>：是否在目标上备份现有文件（值为 <code>yes</code> 时备份）。</li><li><strong><code>force</code></strong>：是否强制覆盖目标文件（默认为 <code>yes</code>）。</li><li><strong><code>mode</code></strong>：设置目标文件或目录的权限（如 <code>0644</code>）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 复制单个文件到远程主机</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m copy -a "src=/etc/hosts dest=/etc/ force=yes" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 复制目录到远程主机</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m copy -a "src=/root/ops dest=/root/  force=yes" -o</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>如果需要拷贝的目录为空，则无法拷贝至目标主机。</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 复制文件并修改权限</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m copy -a "src=/root/test dest=/root/test01 mode=0777" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 复制文件并备份现有文件</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m copy -a "src=/root/test dest=/root/test01 backup=yes" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 不覆盖已有文件</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m copy -a "src=/root/test dest=/root/test01 force=no" -o</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：不覆盖文件代表含义就是。但是需要拷贝的文件在目标主机的路径下存在。则不执行copy</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 利用字符串生成新文件</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m copy -a "content='name mingge\nage 18\n' dest=/tmp/test.txt" -o </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看文件内容</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m shell -a "cat /tmp/test.txt" -o</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182129331.png" alt="image-20240818212923301"></p><h3 id="8、Script模块"><a href="#8、Script模块" class="headerlink" title="8、Script模块"></a>8、<code>Script</code>模块</h3><p>​         <code>script</code> 模块用于在<strong>目标主机</strong>上执行<strong>本地脚本</strong>。但需要注意的是<code>script</code> 模块只是在远程主机上执行<strong>ansible</strong>本地脚本，因此需要确保脚本是可以在远程主机的环境中正确执行的。执行脚本的路径必须是相对于控制节点的路径，而不是远程主机的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 编写测试脚本</span></span><br><span class="line">cat &gt;&gt; echo.sh &lt;&lt;-EOF</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello.world"</span></span><br><span class="line">sleep 10</span><br><span class="line">touch test01.txt</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 执行脚本</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m script  -a "./echo.sh" -o</span></span><br></pre></td></tr></table></figure><h3 id="9、archive模块"><a href="#9、archive模块" class="headerlink" title="9、archive模块"></a>9、<code>archive</code>模块</h3><p>​         <code>archive</code> 模块用于在目标主机上创建压缩文件（归档文件）到目标主机的指定目录。它可以将文件或目录打包成 tar、zip 或其他格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 压缩目录</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m archive -a "path=/root dest=./root.zip format=zip" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 压缩多个目录或文件</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m archive -a "path=/root,/opt,/tmp/test10.txt dest=/tar/lastest.tar.gz" -o</span></span><br></pre></td></tr></table></figure><h3 id="10、unarchive模块"><a href="#10、unarchive模块" class="headerlink" title="10、unarchive模块"></a>10、<code>unarchive</code>模块</h3><p>​        <code>unarchive</code> 模块用于在目标主机上解压存档文件（如 <code>.tar</code>, <code>.zip</code> 等）。也可以将控制主机的压缩包拷贝至目标主机解压或远程的压缩文件，并将其解压到指定的目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 将当前主机的压缩包拷贝目标主机并解压,并且修改相关权限</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m unarchive -a 'src=./nginx-1.24.0.tar.gz dest=/usr/local/ owner=root group=root mode=0755' -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  webservers  -m shell -a "ls -l  /usr/local/ | grep nginx"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182159547.png" alt="image-20240818215951506"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 将目标主机压缩包解压到指定目录</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m copy -a "src=./nginx-1.24.0.tar.gz dest=/root" -o</span></span><br><span class="line"></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m unarchive -a 'src=/root/nginx-1.24.0.tar.gz dest=/usr/local/ owner=root group=root mode=0755 copy=no' -o</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182205827.png" alt="image-20240818220503783"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 从远程连接下载安装包，并解压到指定目录</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m unarchive -a "src=https://nginx.org/download/nginx-1.27.1.tar.gz dest=/opt owner=root group=root mode=0755 copy=no" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  webservers  -m shell -a "ls -l  /opt | grep nginx"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182211648.png" alt="image-20240818221117597"></p><h3 id="11、Fetch模块"><a href="#11、Fetch模块" class="headerlink" title="11、Fetch模块"></a>11、<code>Fetch</code>模块</h3><p>​        <code>fetch</code> 模块用于从远程主机复制<strong>文件</strong>到本地主机。该模块的主要用途是从目标机器获取文件（如日志、配置文件等）并存储在控制节点的指定位置。目前还没有远程拷贝目录到控制主机的功能。未来可能会实现！记住是可能哟。嘿嘿！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 将目标主机文件拷贝到当前主机目录下</span></span><br><span class="line">[root@ansible-server ~]# ansible webservers -m fetch -a "src=/etc/redhat-release dest=/tmp" -o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看本地目录</span></span><br><span class="line">[root@ansible-server ~]# tree /tmp/</span><br><span class="line">/tmp/</span><br><span class="line">├── 192.168.174.21</span><br><span class="line">│   └── etc</span><br><span class="line">│       └── redhat-release</span><br><span class="line">├── 192.168.174.22</span><br><span class="line">│   └── etc</span><br><span class="line">│       └── redhat-release</span><br></pre></td></tr></table></figure><h3 id="12、Hostname模块"><a href="#12、Hostname模块" class="headerlink" title="12、Hostname模块"></a>12、<code>Hostname</code>模块</h3><p>​         <code>hostname</code> 模块用于在远程主机上设置或获取主机名。无法通过命令行设置多个主机名。否则会出现冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 修改单个主机的主机名</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible 192.168.174.21 -m hostname  -a "name=web01" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  192.168.174.21  -m shell -a "hostname"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182217372.png" alt="image-20240818221715339"></p><h3 id="13、Cron模块"><a href="#13、Cron模块" class="headerlink" title="13、Cron模块"></a>13、<code>Cron</code>模块</h3><p>​        <code>cron</code> 模块用于管理远程主机上的计划任务（cron jobs），可以添加、删除或修改已有的任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 创建计划任务：周一至周五每天凌晨2点20备份数据库</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible 192.168.174.22 -m cron -a 'hour=2 minute=20 weekday=1-5 name="backup data mysql" job=/root/mysql_backup.sh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  192.168.174.22  -m shell -a "crontab -l"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182226482.png" alt="image-20240818222648449"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 禁用计划任务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible 192.168.174.22 -m cron -a 'hour=2 minute=20 weekday=1-5 name="backup data mysql" job=/root/mysql_backup.sh disabled=yes'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disabled=yes 禁用计划任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  192.168.174.22  -m shell -a "crontab -l"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182230517.png" alt="image-20240818223011478"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 启动计划任务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible 192.168.174.22 -m cron -a 'hour=2 minute=20 weekday=1-5 name="backup data mysql" job=/root/mysql_backup.sh disabled=no'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  192.168.174.22  -m shell -a "crontab -l"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182231113.png" alt="image-20240818223116065"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 删除计划任务</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible 192.168.174.22 -m cron -a "name='backup data mysql' state=absent" -o</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># state=absent 删除计划任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible  192.168.174.22  -m shell -a "crontab -l"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182232755.png" alt="image-20240818223258724"></p><h3 id="14、Setup模块"><a href="#14、Setup模块" class="headerlink" title="14、Setup模块"></a>14、<code>Setup</code>模块</h3><p>​        <code>setup</code> 模块用于从远程主机收集“事实”，即主机的硬件、网络和操作系统相关的信息。<code>setup</code> 模块会收集诸如 IP 地址、操作系统类型、磁盘空间、内存、环境变量等信息，默认情况下，Ansible 在执行任务时会自动收集这些信息，但也可以通过显式调用 <code>setup</code> 模块来手动收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 查看主机内核版本</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m setup  -a "filter=ansible_kernel"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182243264.png" alt="image-20240818224336209"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 查看主机ipv4相关信息</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m setup  -a "filter=ansible_default_ipv4"</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182245946.png" alt="image-20240818224520882"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 查看内存的总大小</span></span><br><span class="line">[root@ansible-server ~]<span class="comment"># ansible webservers -m setup -a 'filter=ansible_memtotal_mb'</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408182247379.png" alt="image-20240818224701311"></p><h2 id="五、ansible-playbook-剧本"><a href="#五、ansible-playbook-剧本" class="headerlink" title="五、ansible-playbook  剧本"></a>五、ansible-playbook  剧本</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>​    <strong>playbook是ansible用于配置，部署，和管理被控节点的剧本</strong>。通过playbook的详细描述，执行其中的tasks，可以让远端主机达到预期的状态。playbook是由一个或多个”play”组成的列表。  当对一台机器做环境初始化的时候往往需要不止做一件事情，这时使用playbook会更加适合。通过playbook你可以一次在多台机器执行多个指令。通过这种预先设计的配置保持了机器的配置统一，并很简单的执行日常任务。</p><p>​    ansible通过不同的模块实现相应的管理，管理的方式通过定义的清单文件(hosts)所管理的主机包括认证的方式连接的端口等。所有的功能都是通过调用不同的模块(modules)来完成不同的功能的。不管是执行单条命令还是play-book都是基于清单文件。</p><h3 id="2、playbook格式"><a href="#2、playbook格式" class="headerlink" title="2、playbook格式"></a>2、<strong>playbook格式</strong></h3><p>playbook由yaml语言编写。YMAL格式是类似于JSON的文件格式，便于人理解和阅读，同时便于书写。 <code>驼峰式</code></p><p><strong>一个剧本里面可以有多个play，每个play只能有一个tasks，每个tasks可以有多个name</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Variables     # 变量元素,可传递给Tasks/Templates使用;  </span><br><span class="line">Tasks           # 任务元素,由模块定义的操作的列表，即调用模块完成任务;  </span><br><span class="line">Templates  # 模板元素,使用了模板语法的文本文件;  </span><br><span class="line">Handlers    # 处理器元素,通常指在某事件满足时触发的操作;  </span><br><span class="line">Roles           # 角色元素</span><br></pre></td></tr></table></figure><p><strong>playbook的基础组件：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">拷贝nginx安装包</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="string">src=/opt/nginx-1.24.0.tar.gz</span> <span class="string">dest=/tmp</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">解压安装包</span></span><br><span class="line">  <span class="attr">unarchive:</span> <span class="string">src=/tmp/nginx-1.24.0.tar.gz</span> <span class="string">dest=/usr/local</span> <span class="string">copy=no</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">创建启动用户</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=nginx</span> <span class="string">shell=/sbin/nologin</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">name: </span><br><span class="line">    定义playbook或者task的名称(描述信息)，每一个play都可以完成一个任务。</span><br><span class="line">    </span><br><span class="line">hosts: </span><br><span class="line">    hosts用于指定要执行指定任务的主机。</span><br><span class="line">    </span><br><span class="line">user:</span><br><span class="line">    remote_user则用于指定远程主机上的执行任务的用户</span><br><span class="line">    </span><br><span class="line">tasks:</span><br><span class="line">    任务列表play的主体部分是task list. task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。</span><br><span class="line">    </span><br><span class="line">vars:</span><br><span class="line">   定义变量（如果不使用内部变量需要提前定义）</span><br><span class="line">   </span><br><span class="line">vars_files:</span><br><span class="line">  调用定义变量文件</span><br><span class="line">  </span><br><span class="line">notify:</span><br><span class="line">    任务执行结果如果是发生更改了的则触发定义在handler的任务执行</span><br><span class="line">    </span><br><span class="line">handlers:</span><br><span class="line">    用于当前关注的资源发生变化时采取一定指定的操作</span><br></pre></td></tr></table></figure><h3 id="1、hosts"><a href="#1、hosts" class="headerlink" title="1、hosts"></a>1、hosts</h3><p>​    <code>hosts</code> 组件定义了任务要运行在哪些主机或主机组上。<code>hosts</code> 是 Playbook 的核心部分之一，因为它决定了将这些任务分发到哪些远程主机执行。</p><ol><li><strong>语法格式</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">&lt;目标主机或主机组&gt;</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">示例任务</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">echo</span> <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>常见用法</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 指定单个主机</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">server01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 指定主机组</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 指定IP地址</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="number">192.168</span><span class="number">.174</span><span class="number">.22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 指定所有主机</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 排除特定主机：将在所有主机上运行，除了dbservers组中的主机。</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all:!dbservers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 模式匹配：只选择既属于 webservers 组又属于dbservers组的主机。</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers:&amp;dbservers</span></span><br></pre></td></tr></table></figure><h3 id="2、tasks"><a href="#2、tasks" class="headerlink" title="2、tasks"></a>2、tasks</h3><p>​        <code>tasks</code> 组件用于定义一系列将被执行的操作。每个 <code>tasks</code> 列表中的任务都描述了一项操作（如安装软件、修改文件、管理服务等），并且它们是按顺序执行的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span> <span class="string">ploybook</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">启动并启用</span> <span class="string">nginx</span> <span class="string">服务</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure><h3 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h3><h4 id="1-安装nginx服务，并且发布服务"><a href="#1-安装nginx服务，并且发布服务" class="headerlink" title="1. 安装nginx服务，并且发布服务"></a>1. <strong>安装nginx服务，并且发布服务</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 切换目录</span></span><br><span class="line"><span class="string">[root@ansible-server</span> <span class="string">~]#</span> <span class="string">cd</span> <span class="string">/opt/playbook/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 编写playbook文件</span></span><br><span class="line"><span class="string">[root@ansible-server</span> <span class="string">playbook]#</span> <span class="string">vim</span> <span class="string">nginx-install.yaml</span> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装nginx</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=nginx-1.24.0</span> <span class="string">state=present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">拷贝发布文件</span></span><br><span class="line">    <span class="attr">copy:</span> <span class="string">src=/tmp/index.html</span>  <span class="string">dest=/usr/share/nginx/html/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">启动nginx</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试是否能够正常执行</span></span><br><span class="line"><span class="string">[root@ansible-server</span> <span class="string">playbook]#</span> <span class="string">ansible-playbook</span> <span class="string">-C</span> <span class="string">nginx-install.yaml</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408192030619.png" alt="image-20240819203043504"></p><p><strong>具体字段的含义如下：</strong></p><ul><li><strong><code>192.168.174.21</code></strong>: 目标主机的 IP 地址。</li><li><strong><code>ok=4</code></strong>: 有 4 个任务成功执行，没有发生错误。</li><li><strong><code>changed=0</code></strong>: 表示没有任何任务更改了目标主机的状态（例如安装软件、修改文件等）。</li><li><strong><code>unreachable=0</code></strong>: 表示目标主机是可达的（网络正常），没有主机是不可达的。</li><li><strong><code>failed=0</code></strong>: 表示没有任务失败，所有任务都成功完成。</li><li><strong><code>skipped=0</code></strong>: 表示没有任务被跳过。</li><li><strong><code>rescued=0</code></strong>: 表示没有任务进入救援模式（通常在任务失败时触发）。</li><li><strong><code>ignored=0</code></strong>: 表示没有被忽略的任务（例如使用 <code>ignore_errors: yes</code> 忽略的任务）。</li></ul><h4 id="2-vars变量引用"><a href="#2-vars变量引用" class="headerlink" title="2. vars变量引用"></a>2. vars变量引用</h4><p>​        <code>vars</code> 用于定义在任务中可以被引用的变量。可以通过两种方式引用变量：使用 <code></code> 或直接通过关键字引用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">nginx_version:</span> <span class="string">"1.24.0"</span></span><br><span class="line">    <span class="attr">copy_dir:</span> <span class="string">"/tmp"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">拷贝安装包到目标主机并解压</span></span><br><span class="line">      <span class="attr">unarchive:</span> <span class="string">src=/root/nginx-&#123;&#123;</span> <span class="string">nginx_version</span> <span class="string">&#125;&#125;.tar.gz</span> <span class="string">dest=&#123;&#123;</span> <span class="string">copy_dir</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">实例二：</span><br><span class="line">[root@ansible-server ~]# cd /etc/ansible/</span><br><span class="line">[root@ansible-server ansible]# vim test.yml  #创建文件必须以.yml/.yaml结尾</span><br><span class="line">---</span><br><span class="line"> - hosts: webservers1</span><br><span class="line">   user: root</span><br><span class="line">   tasks:</span><br><span class="line">   - name: playbook_test</span><br><span class="line">     file: state=touch path=/tmp/playbook.txt</span><br><span class="line">========================================================================</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释：</span></span><br><span class="line">    hosts: 参数指定了对哪些主机进行操作；</span><br><span class="line">    user: 参数指定了使用什么用户登录远程主机操作；</span><br><span class="line">    tasks: 指定了一个任务.</span><br><span class="line">    name:参数同样是对任务的描述，在执行过程中会打印出来。</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1567316641470.png" alt="1567316641470"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 检测语法：</span></span><br><span class="line">[root@ansible-server ansible]# ansible-playbook -C test.yml </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 运行Playbook</span></span><br><span class="line">[root@ansible-server ansible]# ansible-playbook test.yml #加剧本名称</span><br></pre></td></tr></table></figure><h4 id="3-handlers和notify引用"><a href="#3-handlers和notify引用" class="headerlink" title="3. handlers和notify引用"></a>3. handlers和notify引用</h4><p>​        <code>handlers</code>（处理器）和 <code>notify</code>（触发器）用于在某些任务状态发生变化时自动执行特定操作。<code>handlers</code> 只有在被 <code>notify</code> 触发时才会执行，而 <code>notify</code> 会在任务状态为 <code>changed</code> 时触发处理器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Nginx</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Nginx</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=/tmp/default.conf</span> <span class="string">dest=/etc/nginx/conf.d/default.conf</span> <span class="string">backup=yes</span></span><br><span class="line">      <span class="attr">notify:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Restart</span> <span class="string">Nginx</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Start</span> <span class="string">Nginx</span> <span class="string">service</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Nginx</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure><h4 id="4-item和loop引用"><a href="#4-item和loop引用" class="headerlink" title="4. item和loop引用"></a>4. item和loop引用</h4><p>​        <code>item</code> 通常用于在循环（<code>loop</code>）中遍历列表或字典。它允许任务在多次迭代中使用不同的值。最常见的用法是通过 <code>loop</code> 模块来执行相同的操作多次，但使用不同的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- hosts: webservers2</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install packages</span><br><span class="line">    yum: name=&#123;&#123; item &#125;&#125; state=latest         #相当于for循环里面的i </span><br><span class="line">    loop:                               #取值 。但是不支持通配符</span><br><span class="line">     - httpd</span><br><span class="line">     - php</span><br><span class="line">     - php-mysql</span><br><span class="line">     - php-mbstring</span><br><span class="line">     - php-gd</span><br><span class="line">     </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 或者</span></span><br><span class="line">- hosts: webservers2</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install packages</span><br><span class="line">    yum: name=&#123;&#123; item &#125;&#125; state=latest         #相当于for循环里面的i </span><br><span class="line">    with_items:                               #取值 。但是不支持通配符</span><br><span class="line">     - httpd</span><br><span class="line">     - php</span><br><span class="line">     - php-mysql</span><br><span class="line">     - php-mbstring</span><br><span class="line">     - php-gd</span><br></pre></td></tr></table></figure><blockquote><p><code>with_items</code> 与 <code>loop</code> 类似，但 <code>loop</code> 是 Ansible 2.5 及更高版本的推荐使用方法。</p></blockquote><h4 id="5-when判断"><a href="#5-when判断" class="headerlink" title="5. when判断"></a>5. when判断</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">lrzsz</span> <span class="string">yum</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">vim-enhanced</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">installed</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">=="RedHat"</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">lrzsz</span> <span class="string">apt</span></span><br><span class="line">      <span class="attr">apt:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">vim</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">installed</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">=="Debian"</span></span><br></pre></td></tr></table></figure><h4 id="6-vars-files-变量文件"><a href="#6-vars-files-变量文件" class="headerlink" title="6. vars_files 变量文件"></a>6. vars_files 变量文件</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Ansible" scheme="https://l66stbz.github.io/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息队列</title>
    <link href="https://l66stbz.github.io/2024/08/16/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>https://l66stbz.github.io/2024/08/16/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2024-08-16T14:50:00.000Z</published>
    <updated>2024-08-17T07:58:37.656Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ-消息中间件-消息队列"><a href="#RabbitMQ-消息中间件-消息队列" class="headerlink" title="RabbitMQ 消息中间件/消息队列"></a>RabbitMQ 消息中间件/消息队列</h1><p>[TOC]</p><h1 id="1、消息中间件"><a href="#1、消息中间件" class="headerlink" title="1、消息中间件"></a>1、消息中间件</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>消息队列（Message Queue，简称 MQ）是一种用于跨进程或跨系统的异步通信机制。它允许不同的服务、应用程序或进程之间传递消息，从而实现解耦和高效的任务处理。消息队列通常用于异步处理、分布式系统、负载均衡等场景。</p><p><strong>消息传递</strong>指的是程序之间通过在消息中发送数据进行通信。</p><p>当下主流的消息中间件有RabbitMQ、Kafka、ActiveMQ、RocketMQ等</p><h2 id="1-2-异步处理"><a href="#1-2-异步处理" class="headerlink" title="1.2 异步处理"></a>1.2 异步处理</h2><p>​    场景说明：用户注册账号以后，需要发送注册成功邮件和注册成功短信，传统的做法有两种：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.串行的方式；</span><br><span class="line">2.并行的方式；</span><br></pre></td></tr></table></figure><h3 id="1-2-1-串行方式"><a href="#1-2-1-串行方式" class="headerlink" title="1.2.1 串行方式"></a>1.2.1 串行方式</h3><p>​        将注册信息写入数据库后，发送注册邮件，再发送注册短信，以上三个任务全部完成后才返回给客户端。这有一个问题是，邮件，短信并不是必须的，它只是一个通知，而这种做法让客户端等待没有必要等待的东西。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405141546699.png" alt="串行方式"></p><h3 id="1-2-2-并行方式"><a href="#1-2-2-并行方式" class="headerlink" title="1.2.2 并行方式"></a>1.2.2 并行方式</h3><p>​        将注册信息写入数据库后，发送邮件的同时，发送短信，以上三个任务完成后，返回给客户端，并行的方式能提高处理的时间。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405141547675.png" alt="并行方式"></p><p>假设三个业务节点分别使用50ms，串行方式使用时间150ms，并行使用时间100ms。虽然并性已经提高的处理时间，但是，前面说过邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功，应该是写入数据库后就返回。</p><h3 id="1-2-3-消息队列"><a href="#1-2-3-消息队列" class="headerlink" title="1.2.3 消息队列"></a>1.2.3 消息队列</h3><p>​        引入消息队列后，把发送邮件，短信不是必须的业务逻辑异步处理。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405251531955.png" alt="在这里插入图片描述"></p><p>由此可以看出，引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计)，引入消息队列后处理后，响应时间是串行的3倍，是并行的2倍。</p><h2 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h2><h3 id="2-1-消息中间件主要作用"><a href="#2-1-消息中间件主要作用" class="headerlink" title="2.1 消息中间件主要作用"></a>2.1 消息中间件主要作用</h3><ul><li>冗余(存储)<ul><li>消息持久化功能，将消息存储在可靠的介质中，确保在系统故障或崩溃时，消息不会丢失。</li></ul></li><li>扩展性<ul><li>消息中间件支持系统的水平扩展。通过添加更多的生产者（Producers）和消费者（Consumers），可以处理更大规模的数据量和流量。</li></ul></li><li>可恢复性<ul><li>具有内建的故障恢复机制，能够在系统组件出现故障时进行恢复。例如，当某个消费者崩溃后重新启动时，它可以从上次处理的消息位置继续处理未完成的消息，从而实现故障恢复。</li></ul></li><li>缓冲<ul><li>在生产者和消费者之间提供缓冲作用。生产者可以以自己的速度发送消息，而消费者可以以自己的速度处理消息，这种缓冲机制帮助平滑突发的流量高峰，防止系统过载。</li></ul></li><li>异步通信<ul><li>允许系统之间进行异步通信，生产者发送消息后不需要等待消费者处理完毕，这样可以提高系统的并发性和响应速度。异步通信模式下，生产者和消费者可以独立地进行处理，提升整体系统的效率。</li></ul></li><li>削峰  <ul><li>消息队列中的常用场景，一般在秒杀或抢购活动中使用广泛。一般会因为流量过大，应用系统配置承载不了这股瞬间流量，导致系统直接挂掉，即传说中的“宕机”现象。为解决这个问题，我们会将那股巨大的流量拒在系统的上层，即将其转移至 MQ 而不直接涌入我们的接口。</li></ul></li><li>解耦（耦合性）<ul><li>降低应用与应用间的耦合性</li></ul></li></ul><h2 id="3、消息中间件的两种模式"><a href="#3、消息中间件的两种模式" class="headerlink" title="3、消息中间件的两种模式"></a>3、消息中间件的两种模式</h2><h3 id="1、P2P模式-Rabbitmq"><a href="#1、P2P模式-Rabbitmq" class="headerlink" title="1、P2P模式  Rabbitmq"></a>1、P2P模式  Rabbitmq</h3><p>P2P模式包含三个角色：消息队列（Queue）、发送者(Sender)、接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到它们被消费或超时。</p><p><strong>P2P的特点：</strong>（点对点：Queue，不可重复消费）</p><ul><li>每个消息只有一个消费者（Consumer），即一旦被消费，消息就不再在消息队列中存在</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功</li><li>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式</li></ul><h3 id="2、Pub-Sub模式（发布-订阅：Topic，可以重复消费）"><a href="#2、Pub-Sub模式（发布-订阅：Topic，可以重复消费）" class="headerlink" title="2、Pub/Sub模式（发布/订阅：Topic，可以重复消费）"></a>2、Pub/Sub模式（发布/订阅：Topic，可以重复消费）</h3><p>Pub/Sub模式包含三个角色：主题（Topic）、发布者（Publisher）、订阅者（Subscriber） 。多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。</p><p><strong>Pub/Sub的特点：</strong></p><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息</li><li>为了消费消息，订阅者必须保持运行的状态</li><li>如果希望发送的消息可以不被做任何处理、或者只被一个消费者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</li></ul><h2 id="4、常用中间件介绍与对比"><a href="#4、常用中间件介绍与对比" class="headerlink" title="4、常用中间件介绍与对比"></a>4、常用中间件介绍与对比</h2><h3 id="1、Kafka"><a href="#1、Kafka" class="headerlink" title="1、Kafka"></a>1、Kafka</h3><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，<strong>不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量日志数据的互联网服务的数据收集业务。</strong></p><h3 id="2、RabbitMQ"><a href="#2、RabbitMQ" class="headerlink" title="2、RabbitMQ"></a>2、RabbitMQ</h3><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，<strong>基于AMQP协议来实现。AMQP的主要特征是异步通信、面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</strong></p><p><code>Erlang</code>是一种通用的面向并发的编程语言</p><blockquote><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个开放的标准应用层协议，用于消息传递。AMQP 设计的初衷是为了实现跨平台的消息队列系统，确保不同的消息传递中间件能够互操作。</p><p>主要特性</p><ol><li><strong>异步消息传递</strong>：AMQP 支持异步消息传递，可以在发送和接收消息时不需要同步等待。</li><li><strong>跨平台互操作性</strong>：AMQP 是一个开放标准，支持不同平台和编程语言的互操作。</li><li><strong>可靠性</strong>：提供消息确认、持久化、事务等机制，确保消息不会丢失。</li></ol></blockquote><h3 id="3、RocketMQ"><a href="#3、RocketMQ" class="headerlink" title="3、RocketMQ"></a>3、RocketMQ</h3><p>RocketMQ是阿里开源的消息中间件，<strong>它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。</strong>它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、消息推送、日志流式处理、binglog分发等场景。</p><hr><p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p><h1 id="2、RabbitMQ集群"><a href="#2、RabbitMQ集群" class="headerlink" title="2、RabbitMQ集群"></a>2、RabbitMQ集群</h1><h3 id="1、RabbitMQ简介"><a href="#1、RabbitMQ简介" class="headerlink" title="1、RabbitMQ简介"></a><strong>1、RabbitMQ简介</strong></h3><p>RabbitMQ是Erlang开发的，集群非常方便，因为Erlang天生就是分布式语言，但其本身<strong>并不支持负载均衡，支持高并发，支持可扩展。支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</strong></p><p><em>Ajax</em> 即“Asynchronous Javascript And XML”(异步 JavaScript 和 XML),是指一种创建交互式网页应用的网页开发技术。<em>Ajax</em> = 异步 JavaScript 和 XML</p><h3 id="2、RabbitMQ-特点"><a href="#2、RabbitMQ-特点" class="headerlink" title="2、RabbitMQ 特点"></a>2、RabbitMQ 特点</h3><ul><li><strong>可靠性</strong><ul><li><code>持久化</code>：消息可以持久化到磁盘，确保在服务器重启后仍然可以恢复消息。</li><li>确认机制：生产者和消费者可以收到消息传递和处理的确认，确保消息不会丢失。</li></ul></li></ul><ul><li><p><strong>扩展性</strong></p><ul><li><code>集群</code>：RabbitMQ 可以配置为集群模式，多个节点共同工作，分担消息负载。</li><li>分区交换：消息可以根据规则分发到不同的队列，实现负载均衡。</li></ul></li><li><p><strong>高可用性</strong></p><ul><li><code>镜像队列</code>：队列可以配置为镜像队列，消息会在多个节点之间复制，确保其中一个节点故障时消息不会丢失。</li><li><code>自动故障转移</code>：在集群模式下，RabbitMQ 可以自动进行故障转移，保持系统的高可用性。</li></ul></li><li><p><strong>多语言客户端</strong></p><ul><li>Java：通过 Spring AMQP、RabbitMQ Java Client 等库进行集成。</li><li>其他语言：如 .NET、JavaScript、Go、PHP 等都有对应的客户端库。</li></ul></li><li><p><strong>Web管理界面</strong></p><ul><li>提供了一个功能强大的 Web 管理界面，便于管理和监控</li></ul></li><li><p><strong>插件机制</strong></p><ul><li>通过简单的命令可以安装和启用插件。<ul><li>Management Plugin：提供 Web 管理界面。</li><li>其他插件：如延迟队列插件、安全认证插件等。</li></ul></li></ul></li></ul><h3 id="3、RabbitMQ模式"><a href="#3、RabbitMQ模式" class="headerlink" title="3、RabbitMQ模式"></a>3、RabbitMQ模式</h3><p><strong>注意:RabbitMQ模式大概分为以下三种:</strong></p><p>(1)单机模式。</p><p>(2)普通模式(默认的集群模式)。</p><p>(3)<code>镜像模式</code>(把需要的队列做成镜像队列，存在于多个节点，属于RabbiMQ的HA方案，在对业务可靠性要求较高的场合中比较适合)。要实现镜像模式，需要先搭建出普通集群模式，在这个模式的基础上再配置镜像模式以实现高可用。</p><h3 id="4、了解集群中的基本概念："><a href="#4、了解集群中的基本概念：" class="headerlink" title="4、了解集群中的基本概念："></a><strong>4、了解集群中的基本概念：</strong></h3><p>RabbitMQ的集群节点包括<code>内存节点</code>、<code>磁盘节点</code>。顾名思义内存节点就是将所有数据放在内存，磁盘节点将数据放在磁盘。</p><p>一个rabbitmq集群中可以共享 user，vhost，queue，exchange等，所有的数据和状态都是必须在所有节点上复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Broker:</span><br><span class="line"><span class="meta">#</span><span class="bash"> RabbitMQ 服务器本身就是一个消息代理（Broker）。它负责接收、存储和转发消息到合适的目的地。</span></span><br><span class="line"></span><br><span class="line">ConnectionFactory（连接管理器）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用程序与Rabbit之间建立连接的管理器，程序代码中使用；如主机名、端口、用户名、密码等。</span></span><br><span class="line"></span><br><span class="line">Exchange（交换器）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 交换器（Exchange）是消息路由的核心组件。生产者发送的消息不会直接传递到队列，而是先发送到交换器，然后由交换器根据特定的规则将消息路由到一个或多个队列中。</span></span><br><span class="line"></span><br><span class="line">Routing Key：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个用于路由消息的字符串。当生产者发送消息到交换机(Exchange)时，会指定一个路由键。交换机会根据这个键和绑定规则将消息分发到相应的队列。</span></span><br><span class="line"></span><br><span class="line">Queue（队列）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 存储消息的地方，消费者从队列中获取并处理消息。队列可以配置为持久化，以确保消息在服务器重启后仍然存在。</span></span><br><span class="line"></span><br><span class="line">Bindding（绑定）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将交换机和队列连接起来，定义了交换机如何根据路由键将消息路由到队列。</span></span><br><span class="line"></span><br><span class="line">vhost（虚拟主机）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用于多租户和权限分离的机制。一个 Broker 可以有多个 Vhost，每个 Vhost 可以有独立的交换机、队列、绑定和权限配置。这样可以隔离不同的应用或租户的数据和配置。</span></span><br><span class="line"></span><br><span class="line">producer（生产者）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生产者是创建并发送消息到 RabbitMQ 的应用程序或服务。生产者将消息发送到交换机，并指定一个路由键。</span></span><br><span class="line"></span><br><span class="line">consumer（消费者）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 消费者是从 RabbitMQ 队列中接收并处理消息的应用程序或服务。消费者可以订阅一个或多个队列，并根据需要处理消息。</span></span><br><span class="line"></span><br><span class="line">channel（信道）：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。消息推送使用的通道。</span></span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1571320020040.png" alt="1571320020040"></p><ol><li><strong>生产者发送消息</strong>：</li></ol><ul><li>生产者创建消息，并将其发送到 RabbitMQ 的某个交换机中。消息可以携带路由键，交换机会根据这个键和绑定规则将消息路由到相应的队列。</li></ul><ol start="2"><li><strong>交换机路由消息</strong>：</li></ol><ul><li>交换机接收消息后，根据类型和绑定规则将消息路由到一个或多个队列中。如果没有找到匹配的队列，交换机会丢弃消息，或者根据配置返回给生产者。</li></ul><ol start="3"><li><strong>消息进入队列</strong>：</li></ol><ul><li>一旦消息被路由到队列中，消息就会暂时存储在队列中，等待消费者处理。队列可以配置为持久化，以确保即使 RabbitMQ 服务崩溃，消息也不会丢失。</li></ul><ol start="4"><li><strong>消费者接收消息</strong>：</li></ol><ul><li>消费者从队列中取走消息并进行处理。消息的分发可以通过轮询（Round Robin）分配给多个消费者，或者消费者可以从多个队列中获取消息进行处理。</li></ul><ol start="5"><li><strong>消息确认</strong>：</li></ol><ul><li>消费者处理完消息后，会向 RabbitMQ 发送一个确认消息（ACK），告知消息已被成功处理。如果消费者在处理过程中失败，RabbitMQ 可以重新将消息投递给其他消费者或重新进入队列，这取决于队列的配置。</li></ul><p><strong>面试注意:集群中有两种节点</strong></p><ul><li><p><code>内存节点</code>：只保存状态到内存（持久的queue的持久内容将被保存到磁盘中）</p></li><li><p><code>磁盘节点</code>：保存状态到内存和磁盘。—推荐</p></li></ul><p>内存节点虽然不写入磁盘，但是它执行比磁盘节点要高。集群中，只需要一个磁盘节点来保存状态 就足够了。如果集群中<code>只有内存节点</code>，那么<code>不能停止</code>它们，否则所有的状态，消息等都会丢失。</p><h3 id="5、普通集群准备环境"><a href="#5、普通集群准备环境" class="headerlink" title="5、普通集群准备环境"></a>5、普通集群准备环境</h3><p>Rabbitmq官方最新rpm包下载地址：<a href="https://www.rabbitmq.com/install-rpm.html#downloads" target="_blank" rel="noopener">https://www.rabbitmq.com/install-rpm.html#downloads</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># rabbitmq 和 erlang兼容版本</span><br><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;which-erlang.html</span><br><span class="line"># erlang 版本选择</span><br><span class="line">https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;erlang</span><br><span class="line"># rabbitmq 版本选择</span><br><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;news.html</span><br></pre></td></tr></table></figure><p><strong>三台机器都操作:</strong></p><ol><li><p>配置hosts文件；更改三台MQ节点的<code>主机名</code>分别为rabbitmq-1、rabbitmq-2 和rabbitmq-3，然后修改hosts配置件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 三台主机修改主机名</span></span><br><span class="line">[root@rabbitmq-1 ~]# hostnamectl set-hostname rabbitmq-1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 三台主机本地解析</span></span><br><span class="line">[root@rabbitmq-1 ~]# vim /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.50.138 rabbitmq-1</span><br><span class="line">192.168.50.139 rabbitmq-2</span><br><span class="line">192.168.50.140 rabbitmq-3</span><br></pre></td></tr></table></figure></li><li><p>三个节点配置安装rabbitmq软件</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">[root@rabbitmq-1 ~]# yum install -y *epel* gcc-c++ unixODBC unixODBC-devel openssl-devel ncurses-devel</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum安装erlang</span></span><br><span class="line">[root@rabbitmq-1 ~]# wget --content-disposition https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-20.3-1.el7.centos.x86_64.rpm/download.rpm</span><br><span class="line">[root@rabbitmq-1 ~]# yum install erlang-20.3-1.el7.centos.x86_64.rpm -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试erlang</span></span><br><span class="line">[root@rabbitmq-1 ~]# erl</span><br><span class="line">Erlang/OTP 20 [erts-9.3] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [hipe] [kernel-poll:false]</span><br><span class="line"></span><br><span class="line">Eshell V9.3  (abort with ^G)</span><br><span class="line"><span class="meta">1&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 两次Crtl+c退出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装rabbitmq</span></span><br><span class="line">[root@rabbitmq-1 ~]# wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.5/rabbitmq-server-3.7.5-1.el7.noarch.rpm</span><br><span class="line">[root@rabbitmq-1 ~]# yum install rabbitmq-server-3.7.5-1.el7.noarch.rpm -y</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">[root@rabbitmq-1 ~]# systemctl daemon-reload</span><br><span class="line">[root@rabbitmq-1 ~]# systemctl enable --now rabbitmq-server</span><br><span class="line">[root@rabbitmq-1 ~]# systemctl status rabbitmq-server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每台都操作开启rabbitmq的web访问界面： </span></span><br><span class="line">[root@rabbitmq-1 ~]# rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1585804728482.png" alt="1585804728482"></p><blockquote><p>默认：RabbitMQ web界面关闭</p></blockquote><p>创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注意:在一台机器操作</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加用户和密码</span></span><br><span class="line">[root@rabbitmq-1 ~]# rabbitmqctl add_user soho soso</span><br><span class="line">Adding user "soho" ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> soho：用户名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> soso：密码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为管理员</span></span><br><span class="line">[root@rabbitmq-1 ~]# rabbitmqctl set_user_tags soho administrator</span><br><span class="line">Setting tags for user "soho" to [administrator] ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有用户</span></span><br><span class="line">[root@rabbitmq-1 ~]# rabbitmqctl list_users</span><br><span class="line">Listing users ...</span><br><span class="line">guest[administrator]</span><br><span class="line">soho[administrator]</span><br><span class="line">...done.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建用户设置权限</span></span><br><span class="line">[root@rabbitmq-1 ~]# rabbitmqctl set_permissions -p "/" soso ".*" ".*" ".*"</span><br><span class="line">Setting permissions for user "soho" in vhost "/" ...</span><br></pre></td></tr></table></figure><blockquote><p><code>此处设置权限时注意&#39;.*&#39;之间需要有空格 三个&#39;.*&#39;分别代表了加载conf权限，read权限与write权限 例如：当没有给soho设置这三个权限前是没有权限查询队列，在ui界面也看不见</code></p></blockquote><ol start="3"><li>三台机器都操作:开启用户远程登录:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">[root@rabbitmq-1 ~]# cd /etc/rabbitmq/   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝默认配置文件至工作目录</span></span><br><span class="line">[root@rabbitmq-1 rabbitmq]# cp /usr/share/doc/rabbitmq-server-3.7.5/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br><span class="line"></span><br><span class="line">[root@rabbitmq-1 rabbitmq]# ls</span><br><span class="line">enabled_plugins  rabbitmq.config</span><br><span class="line"></span><br><span class="line">[root@rabbitmq-1 rabbitmq]# vim rabbitmq.config</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改如下:</span></span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564157816348.png" alt="1564157816348"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 三台机器都操作重启服务服务:</span></span><br><span class="line">[root@rabbitmq-1 ~]# systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><p><strong>查看端口</strong></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564157344617.png" alt="1564157344617"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4369 -- erlang端口</span><br><span class="line">5672 --程序连接端口</span><br><span class="line">15672 -- 管理界面ui端口</span><br><span class="line">25672 -- server间内部通信端口</span><br></pre></td></tr></table></figure><p><strong>！注意如果是云服务器，切记添加安全组端口放行。</strong></p><p>访问:192.168.50.138:15672</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564157664109.png" alt="1564157664109"></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564158056319.png" alt="1564158056319"></p><p><strong>这里需要注意:</strong></p><p>rabbitmq默认管理员用户:guest   密码:guest</p><p>新添加的用户为:soho 密码:soso</p><h3 id="6、开始部署集群三台机器都操作"><a href="#6、开始部署集群三台机器都操作" class="headerlink" title="6、开始部署集群三台机器都操作"></a><strong>6、开始部署集群三台机器都操作</strong></h3><p>1.首先创建好数据存放目录和日志存放目录:</p><p>3台机器都操作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建RabbitMQ数据存放处</span></span><br><span class="line">[root@rabbitmq-1 ~]# mkdir -p /data/rabbitmq/data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建RabbitMQ日志文件存放处</span></span><br><span class="line">[root@rabbitmq-1 ~]# mkdir -p /data/rabbitmq/logs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改权限和属主、属组</span></span><br><span class="line">[root@rabbitmq-1 ~]# chmod 777 -R /data/rabbitmq</span><br><span class="line">[root@rabbitmq-1 ~]# chown rabbitmq.rabbitmq /data/ -R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建配置文件:</span></span><br><span class="line">[root@rabbitmq-1 ~]# vim /etc/rabbitmq/rabbitmq-env.conf</span><br><span class="line">RABBITMQ_MNESIA_BASE=/data/rabbitmq/data</span><br><span class="line">RABBITMQ_LOG_BASE=/data/rabbitmq/logs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">[root@rabbitmq-1 ~]# systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><p><strong>2.拷erlang.cookie</strong></p><p>Rabbitmq的集群是依附于erlang的集群来工作的,所以必须先构建起erlang的集群。Erlang的集群中各节点是经由各个cookie来实现的,这个cookie存放在<code>/var/lib/rabbitmq/.erlang.cookie</code>中，文件是400的权限。所以<code>必须保证各节点cookie一致</code>,不然节点之间就<code>无法通信</code>。</p><p>如果执行# rabbitmqctl stop_app 这条命令报错:需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果执行<span class="comment"># rabbitmqctl stop_app 这条命令报错:需要执行</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">chmod 400 .erlang.cookie</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chown rabbitmq.rabbitmq .erlang.cookie</span></span><br></pre></td></tr></table></figure><p>(官方在介绍集群的文档中提到过.erlang.cookie 一般会存在这两个地址：第一个是home/.erlang.cookie；第二个地方就是/var/lib/rabbitmq/.erlang.cookie。如果我们使用解压缩方式安装部署的rabbitmq，那么这个文件会在{home}目录下，也就是$home/.erlang.cookie。如果我们使用rpm等安装包方式进行安装的，那么这个文件会在/var/lib/rabbitmq目录下。)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看Cookie值</span></span><br><span class="line">[root@rabbitmq-1 ~]# cat /var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">HOUCUGJDZYTFZDSWXTHJ</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> scp的方式将rabbitmq-1节点的.erlang.cookie的值复制到其他两个节点中。</span></span><br><span class="line">[root@rabbitmq-1 ~]# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.50.139:/var/lib/rabbitmq/</span><br><span class="line">[root@rabbitmq-1 ~]# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.50.140:/var/lib/rabbitmq/</span><br></pre></td></tr></table></figure><blockquote><p><code>.erlang.cookie</code> 文件是 Erlang 运行时系统用于节点之间的认证文件。在搭建 RabbitMQ 集群时，确保了集群中的各个节点可以相互通信和信任。每个节点在启动时都会检查 .erlang.cookie 文件的内容，只有拥有相同 cookie 值的节点才能成功地建立连接并进行通信。</p></blockquote><p><strong>3.将mq-2、mq-3作为内存节点加到mq-1节点集群中</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在mq-2、mq-3执行如下命令： 停止节点，切记不是停止服务</span></span><br><span class="line">[root@rabbitmq-2 ~]# rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1585815681534.png" alt="1585815681534"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果有数据需要重置，没有则不用</span></span><br><span class="line">[root@rabbitmq-2 ~]# rabbitmqctl reset</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1585815744200.png" alt="1585815744200"></p><p><code>注意查看回显，如果不是以上。就是错误；如果报错，重启rabbitmq服务</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将两个节点加入集群，指定角色，添加到内存节点</span></span><br><span class="line">[root@rabbitmq-2 ~]# rabbitmqctl join_cluster --ram rabbit@rabbitmq-1  </span><br><span class="line">Clustering node 'rabbit@rabbitmq-2' with 'rabbit@rabbitmq-1' ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动节点</span></span><br><span class="line">[root@rabbitmq-2 ~]# rabbitmqctl start_app  </span><br><span class="line">Starting node 'rabbit@rabbitmq-2' ...</span><br><span class="line"> completed with 3 plugins.</span><br><span class="line">===============================================================================</span><br><span class="line"></span><br><span class="line">[root@rabbitmq-3 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping node 'rabbit@rabbitmq-3' ...</span><br><span class="line">[root@rabbitmq-3 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node 'rabbit@rabbitmq-3' ...</span><br><span class="line">[root@rabbitmq-3 ~]# rabbitmqctl join_cluster --ram rabbit@rabbitmq-1</span><br><span class="line">Clustering node 'rabbit@rabbitmq-3' with 'rabbit@rabbitmq-1' ...</span><br><span class="line">[root@rabbitmq-3 ~]# rabbitmqctl start_app</span><br><span class="line">Starting node 'rabbit@rabbitmq-3' ...</span><br><span class="line"> completed with 3 plugins.</span><br><span class="line"></span><br><span class="line">（1）默认rabbitmq启动后是磁盘节点，在这个cluster命令下，mq-2和mq-3是内存节点，</span><br><span class="line">mq-1是磁盘节点。</span><br><span class="line">（2）如果要使mq-2、mq-3都是磁盘节点，去掉--ram参数即可。</span><br><span class="line">（3）如果想要更改节点类型，可以使用命令rabbitmqctl change_cluster_node_type</span><br><span class="line">disc(ram),前提是必须停掉rabbitmq基础应用erlang</span><br><span class="line">注:</span><br><span class="line"><span class="meta">#</span><span class="bash">如果有需要使用磁盘节点加入集群</span></span><br><span class="line"> [root@rabbitmq-2 ~]# rabbitmqctl join_cluster  rabbit@rabbitmq-1</span><br><span class="line"> [root@rabbitmq-3 ~]# rabbitmqctl join_cluster  rabbit@rabbitmq-1</span><br></pre></td></tr></table></figure><p><strong>4.查看集群状态</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在RabbitMQ集群任意节点上执行 rabbitmqctl cluster_status来查看是否集群配置成功。在mq-1磁盘节点上面查看</span></span><br><span class="line">[root@rabbitmq-1 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564158874154.png" alt="1564158874154"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每台机器显示出三台节点，表示已经添加成功！</span><br></pre></td></tr></table></figure><p><strong>5.登录rabbitmq web管理控制台，创建新的队列</strong></p><p>打开浏览器输入<a href="http://192.168.50.138:15672" target="_blank" rel="noopener">http://192.168.50.138:15672</a>, </p><p>输入默认的<code>Username：guest</code>；输入默认的<code>Password:guest</code></p><p>此时会发现之间创建的用户登录不了，这是因为我们修改了rabbitmq的数据目录，导致之前创建的用户消失了。</p><p>登录后出现如图所示的界面。</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564162424739.png" alt="1564162424739"></p><p>根据界面提示创建一条队列</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564159056655.png" alt="1564159056655"></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564159160374.png" alt="1564159160374"></p><h3 id="7、RabbitMQ镜像集群配置"><a href="#7、RabbitMQ镜像集群配置" class="headerlink" title="7、RabbitMQ镜像集群配置"></a>7、RabbitMQ镜像集群配置</h3><p>  上面已经完成RabbitMQ默认集群模式，<strong>但并不保证队列的<code>高可用性</code>，队列内容不会复制。如果队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建镜像队列。</strong></p><p><code>镜像队列是基于普通的集群模式的。</code></p><p><strong>创建镜像集群:在任意一台机器操作</strong></p><p>rabbitmq set_policy ：设置策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq-1 ~]# rabbitmqctl set_policy  ha-all "^" '&#123;"ha-mode":"all"&#125;'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令回显</span></span><br><span class="line">Setting policy "ha-all" for pattern "^" to "&#123;"ha-mode":"all"&#125;" with priority "0" for vhost "/" ...</span><br></pre></td></tr></table></figure><blockquote><p> “^”匹配所有的队列， ha-all 策略名称为ha-all, ‘{“ha-mode”:”all”}’ 策略模式为 all 即复制到所有节点，包含新增节点。</p></blockquote><p>再次查看队列已经同步到其他两台节点:</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564159410040.png" alt="1564159410040"></p><p><strong>“^”匹配所有的队列， ha-all 策略名称为ha-all, ‘{“ha-mode”:”all”}’ 策略模式为 all 即复制到所有节点，包含新增节点。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">设置策略介绍:</span><br><span class="line">rabbitmqctl set_policy [-p Vhost] Name Pattern Definition</span><br><span class="line">-p Vhost： 可选参数，针对指定vhost下的queue进行设置</span><br><span class="line">Name: policy的名称，可以定义</span><br><span class="line">Pattern: queue的匹配模式(正则表达式),也就是说会匹配一组。</span><br><span class="line">Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span><br><span class="line">    ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span><br><span class="line">        all：表示在集群中所有的节点上进行镜像</span><br><span class="line">        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="line">        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br><span class="line">    ha-params：ha-mode模式需要用到的参数</span><br><span class="line">    ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span><br><span class="line">案例:</span><br><span class="line">例如，对队列名称以hello开头的所有队列进行镜像，并在集群的两个节点上完成镜像，policy的设置命令为： </span><br><span class="line">rabbitmqctl set_policy hello-ha “^hello)” ‘&#123;“ha-mode”:”exactly”,”ha-params”:2,”ha-sync-mode”:”automatic”&#125;’</span><br></pre></td></tr></table></figure><p>则此时镜像队列设置成功。已经部署完成。将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态保持一致。</p><h1 id="3、RabbitMQ面试题"><a href="#3、RabbitMQ面试题" class="headerlink" title="3、RabbitMQ面试题"></a>3、RabbitMQ面试题</h1><p>1、消息队列的作用？</p><p>2、RabbitMQ有什么作用？</p><ul><li>消息队列<ul><li>将消息从发送方（生产者）传递到接收方（消费者）。通过消息队列，生产者和消费者可以异步通信，互不干扰。</li></ul></li><li>异步处理<ul><li>通过将任务封装成消息放入队列，应用程序可以实现异步处理，从而提高响应速度和处理效率。例如，Web 应用可以快速响应用户请求，同时在后台处理耗时的任务。</li></ul></li><li>组件解耦<ul><li>通过使用消息队列，系统的不同组件（服务或应用）可以互相解耦。这样，各组件可以独立开发、部署和扩展，而不必直接依赖于其他组件的实现细节。</li></ul></li><li>负载均衡<ul><li>当有多个消费者订阅同一个队列时，RabbitMQ 可以将消息分发给这些消费者，实现负载均衡，确保每个消费者处理的工作量大致均等。</li></ul></li><li>高可用性<ul><li>RabbitMQ 支持集群模式和镜像队列，可以提供高可用性和故障恢复能力，确保在节点故障时系统依然可以正常工作。</li></ul></li><li>灵活的路由<ul><li>RabbitMQ 通过交换器（Exchange）和绑定（Binding）机制，提供灵活的消息路由功能。可以根据不同的路由键、队列绑定和交换器类型，实现复杂的消息路由规则。</li></ul></li></ul><p>3、RabbitMQ的工作模式？</p><ul><li>单节点模式<ul><li>单节点模式是最简单的部署方式，适合小型应用或开发测试环境。</li></ul></li><li>普通集群模式<ul><li>普通集群模式包含多个 RabbitMQ 节点，节点之间可以共享消息队列，但消息本身不会被复制。</li></ul></li><li>镜像模式<ul><li>镜像模式是普通集群模式的扩展，增加了消息的高可用性。队列可以被镜像到集群中的多个节点上。</li></ul></li></ul><p>4、消息队列使用场景</p><ul><li>任务队列<ul><li>后台任务处理（例如发送电子邮件）</li></ul></li><li>事件通知<ul><li>分布式系统中组件之间的事件通知</li></ul></li><li>数据流处理<ul><li>实时数据流的处理和分析，例如日志收集和处理</li></ul></li><li>负载分发<ul><li>将消息负载分发给多个消费者，实现负载均衡和并行处理</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://l66stbz.github.io/tags/Redis/"/>
    
      <category term="Cluster" scheme="https://l66stbz.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Cluster集群</title>
    <link href="https://l66stbz.github.io/2024/08/15/Redis-Cluster%E9%9B%86%E7%BE%A4/"/>
    <id>https://l66stbz.github.io/2024/08/15/Redis-Cluster%E9%9B%86%E7%BE%A4/</id>
    <published>2024-08-15T14:50:00.000Z</published>
    <updated>2024-08-17T07:54:56.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、Redis-Cluster去中心化集群"><a href="#一、Redis-Cluster去中心化集群" class="headerlink" title="一、Redis Cluster去中心化集群"></a>一、Redis Cluster去中心化集群</h1><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240422163108793.png" alt="image-20240422163108793"></p><p>Redis集群是一个由<code>多个</code>主从节点群组成的<code>分布式</code>服务集群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。<strong>redis集群的运用主要是针对海量数据+高并发+高可用的场景。</strong></p><p>分布式：分布式计算是分布式系统的核心思想，指的是将一个复杂的任务分解为多个子任务，并将这些子任务分配给不同的节点（服务器）进行处理。最终，所有节点的计算结果会汇总起来形成最终的结果。<strong>简单的来讲就是将一个单体应用拆分成不同单元的功能模块</strong></p><h2 id="1-为什么要用redis-cluster集群？"><a href="#1-为什么要用redis-cluster集群？" class="headerlink" title="1.为什么要用redis-cluster集群？"></a>1.为什么要用redis-cluster集群？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.首先Redis单实例主要有单点，容量有限，流量压力上限的问题。</span><br><span class="line">Redis单点故障，可以通过主从复制replication，和自动故障转移sentinel哨兵机制。但Redis单Master实例提供写服务，仍然有容量和压力问题，因此需要数据分区，构建多个Master实例同时提供读写服务（不仅限于从replica节点提供读服务）。</span><br><span class="line"></span><br><span class="line">2.并发问题</span><br><span class="line">redis官方声称可以达到 10万/s,每秒执行10万条命令</span><br><span class="line">假如业务需要每秒100万的命令执行呢？</span><br><span class="line"></span><br><span class="line">解决方案如下</span><br><span class="line">1.正确的应该是考虑分布式，加机器，把数据分到不同的位置，分摊集中式的压力，一堆机器做一件事.还需要一定的机制保证数据分区，并且数据在各个主Master节点间不能混乱，当然最好还能支持在线数据热迁移的特性。</span><br></pre></td></tr></table></figure><h2 id="2、什么是Redis-Cluster"><a href="#2、什么是Redis-Cluster" class="headerlink" title="2、什么是Redis-Cluster"></a>2、什么是Redis-Cluster</h2><p>为何要搭建Redis集群。Redis是在内存中保存数据的，而我们的电脑一般内存都不大，这也就意味着Redis不适合存储大数据，Redis更适合处理高并发，一台设备的存储能力是很有限的，但是多台设备协同合作，就可以让内存增大很多倍，这就需要用到集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从redis 3.0之后版本支持redis-cluster集群，它是Redis官方提出的解决方案：</span><br><span class="line">Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其Redis-cluster架构图如下：</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/image-20210224212222130.png#id=zbfSq&originHeight=392&originWidth=350&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><blockquote><p>在这个图中，每一个蓝色的圈都代表着一个redis的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作</p></blockquote><h3 id="2-1-redis-cluster特点"><a href="#2-1-redis-cluster特点" class="headerlink" title="2.1 redis cluster特点"></a>2.1 redis cluster特点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</span><br><span class="line">2.客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</span><br><span class="line">3.节点的fail是通过集群中超过半数的节点检测失效时才生效。</span><br></pre></td></tr></table></figure><h3 id="2-2-redis-cluster数据分布"><a href="#2-2-redis-cluster数据分布" class="headerlink" title="2.2 redis-cluster数据分布"></a>2.2 redis-cluster数据分布</h3><p>Redis-cluster集群中有<strong>16384</strong>（0-16383）个哈希槽，每个redis实例负责一部分slot/槽位，集群中的所有信息通过节点数据交换而更新。一个hash slot中会有很多key和value。</p><h3 id="2-3-数据分布存储原理"><a href="#2-3-数据分布存储原理" class="headerlink" title="2.3 数据分布存储原理"></a>2.3 数据分布存储原理</h3><p>Redis 集群使用数据分片（sharding）来实现：Redis 集群中内置了 <code>16384</code> 个哈希槽，当需要在 Redis 集群中放置一个 key-value（name1: 张三） 时，redis 先对 key 使用 crc16 算法算出一个结果678698，然后把结果对 16384 求余数(集群使用公式 CRC16(key) % 16384)，这样每个key 都会对应一个编号在 0-16383 之间的哈希槽，那么redis就会把这个key 分配到对应范围的节点上了。同样，当连接三个节点任何一个节点想获取这个key时，也会这样的算法，然后内部跳转到存放这个key节点上获取数据。</p><p>例如三个节点：哈希槽分布的值如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster1:  0-5460</span><br><span class="line">cluster2:  5461-10922</span><br><span class="line">cluster3:  10923-16383</span><br></pre></td></tr></table></figure><p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p><ul><li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li><li>如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li></ul><p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p><h2 id="3、Redis-Cluster主从模式"><a href="#3、Redis-Cluster主从模式" class="headerlink" title="3、Redis Cluster主从模式"></a>3、Redis Cluster主从模式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉.</span><br><span class="line"></span><br><span class="line">1.主从切换机制</span><br><span class="line">选举过程是集群中所有master参与,如果半数以上master节点与故障节点通信超过(cluster-node-timeout),认为该节点故障，自动触发故障转移操作.  #故障节点对应的从节点自动升级为主节点</span><br><span class="line"></span><br><span class="line">2.什么时候整个集群就不能用了？</span><br><span class="line">如果集群任意一个主节点挂掉,且当前主节点没有从节点，则集群将无法继续，因为我们不再有办法为这个节点承担范围内的哈希槽提供服务。但是，如果这个主节点和所对应的从节点同时失败，则Redis Cluster无法继续运行。</span><br></pre></td></tr></table></figure><h1 id="二、集群部署"><a href="#二、集群部署" class="headerlink" title="二、集群部署"></a>二、集群部署</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">环境准备:</span><br><span class="line">1.准备三机器，关闭防火墙和selinux</span><br><span class="line">2.制作解析并相互做解析</span><br><span class="line">注:规划架构两种方案，一种是单机多实例，这里我们采用多机器部署</span><br><span class="line">三台机器，每台机器上面两个redis实例，一个master一个slave，第一列做主库，第二列做备库</span><br><span class="line"><span class="meta">#</span><span class="bash">记得选出控制节点</span></span><br><span class="line"></span><br><span class="line">redis-cluster1 192.168.116.172   7000、7001</span><br><span class="line">redis-cluster2 192.168.116.173   7002、7003</span><br><span class="line">redis-cluster3 192.168.116.174   7004、7005</span><br></pre></td></tr></table></figure><h2 id="1-三台机器相同操作"><a href="#1-三台机器相同操作" class="headerlink" title="1.三台机器相同操作"></a>1.三台机器相同操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.安装redis</span><br><span class="line">[root@redis-cluster1 ~]# mkdir /data</span><br><span class="line">[root@redis-cluster1 ~]# yum -y install gcc automake autoconf libtool make</span><br><span class="line">[root@redis-cluster1 ~]# wget https://download.redis.io/releases/redis-6.2.0.tar.gz</span><br><span class="line">[root@redis-cluster1 ~]# tar xzvf redis-6.2.0.tar.gz -C /data/</span><br><span class="line">[root@redis-cluster1 ~]# cd /data/</span><br><span class="line">[root@redis-cluster1 data]# mv redis-6.2.0/ redis</span><br><span class="line">[root@redis-cluster1 data]# cd redis/</span><br><span class="line">[root@redis-cluster1 redis]# make    #编译</span><br><span class="line">[root@redis-cluster1 redis]# mkdir /data/redis/data #创建存放数据的目录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2.创建节点目录:按照规划在每台redis节点的安装目录中创建对应的目录（以端口号命名）</span><br><span class="line">[root@redis-cluster1 redis]# pwd</span><br><span class="line">/data/redis</span><br><span class="line">[root@redis-cluster1 redis]# mkdir cluster #创建集群目录</span><br><span class="line">[root@redis-cluster1 redis]# cd cluster/</span><br><span class="line">[root@redis-cluster1 cluster]# mkdir 7000 7001 #创建节点目录</span><br><span class="line"></span><br><span class="line">[root@redis-cluster2 redis]# mkdir cluster</span><br><span class="line">[root@redis-cluster2 redis]# cd cluster/</span><br><span class="line">[root@redis-cluster2 cluster]# mkdir 7002 7003</span><br><span class="line"></span><br><span class="line">[root@redis-cluster3 redis]# mkdir cluster</span><br><span class="line">[root@redis-cluster3 redis]# cd cluster/</span><br><span class="line">[root@redis-cluster3 cluster]# mkdir 7004 7005</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3.拷贝配置文件到节点目录中，#三台机器相同操作</span><br><span class="line">[root@redis-cluster1 cluster]# cp /data/redis/redis.conf 7000/</span><br><span class="line">[root@redis-cluster1 cluster]# cp /data/redis/redis.conf 7001/</span><br><span class="line"></span><br><span class="line">[root@redis-cluster2 cluster]# cp /data/redis/redis.conf 7002/</span><br><span class="line">[root@redis-cluster2 cluster]# cp /data/redis/redis.conf 7003/</span><br><span class="line"></span><br><span class="line">[root@redis-cluster3 cluster]# cp /data/redis/redis.conf 7004/</span><br><span class="line">[root@redis-cluster3 cluster]# cp /data/redis/redis.conf 7005/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">4.修改集群每个redis配置文件。(主要是端口、ip、pid文件，三台机器相同操作)，修改如下：</span><br><span class="line">[root@redis-cluster1 cluster]# cd 7000/</span><br><span class="line">[root@redis-cluster1 7000]# vim redis.conf #修改如下</span><br><span class="line">bind 192.168.116.172  #每个实例的配置文件修改为对应节点的ip地址</span><br><span class="line">port 7000   #监听端口，运行多个实例时，需要指定规划的每个实例不同的端口号</span><br><span class="line">daemonize yes #redis后台运行</span><br><span class="line">pidfile /var/run/redis_7000.pid #pid文件，运行多个实例时，需要指定不同的pid文件</span><br><span class="line">logfile /var/log/redis_7000.log #日志文件位置，运行多实例时，需要将文件修改的不同。</span><br><span class="line">dir /data/redis/data #存放数据的目录</span><br><span class="line">appendonly yes #开启AOF持久化，redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态。</span><br><span class="line">appendfilename "appendonly.aof"  #AOF文件名称</span><br><span class="line">appendfsync everysec #表示对写操作进行累积，每秒同步一次</span><br><span class="line">以下为打开注释并修改</span><br><span class="line">cluster-enabled yes #启用集群</span><br><span class="line">cluster-config-file nodes-7000.conf #集群配置文件，由redis自动更新，不需要手动配置，运行多实例时请注修改为对应端口</span><br><span class="line">cluster-node-timeout 5000 #单位毫秒。集群节点超时时间，即集群中主从节点断开连接时间阈值，超过该值则认为主节点不可以，从节点将有可能转为master</span><br><span class="line">cluster-replica-validity-factor 10 #在进行故障转移的时候全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了导致数据过于陈旧，不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。（计算方法为：cluster-node-timeout * cluster-replica-validity-factor，此处为：5000 * 10 毫秒）</span><br><span class="line">cluster-migration-barrier 1 #一个主机将保持连接的最小数量的从机，以便另一个从机迁移到不再被任何从机覆盖的主机</span><br><span class="line">cluster-require-full-coverage yes #集群中的所有slot（16384个）全部覆盖，才能提供服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">注：</span></span><br><span class="line">所有节点配置文件全部修改切记需要修改的ip、端口、pid文件...避免冲突。确保所有机器都修改。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5.启动三台机器上面的每个节点(三台机器相同操作)</span><br><span class="line">[root@redis-cluster1 ~]# cd /data/redis/src/</span><br><span class="line">[root@redis-cluster1 src]# nohup ./redis-server ../cluster/7000/redis.conf &amp;</span><br><span class="line">[root@redis-cluster1 src]# nohup ./redis-server ../cluster/7001/redis.conf &amp;</span><br><span class="line"></span><br><span class="line">[root@redis-cluster2 7003]# cd /data/redis/src/</span><br><span class="line">[root@redis-cluster2 src]# nohup ./redis-server ../cluster/7002/redis.conf &amp;</span><br><span class="line">[root@redis-cluster2 src]# nohup ./redis-server ../cluster/7003/redis.conf &amp;</span><br><span class="line"></span><br><span class="line">[root@redis-cluster3 7005]# cd /data/redis/src/</span><br><span class="line">[root@redis-cluster3 src]# nohup ./redis-server ../cluster/7004/redis.conf &amp;</span><br><span class="line">[root@redis-cluster3 src]# nohup ./redis-server ../cluster/7005/redis.conf &amp;</span><br></pre></td></tr></table></figure><p>查看端口</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/image-20210227170755994.png#id=ivIvP&originHeight=134&originWidth=1390&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/image-20210227171013509.png#id=wSIBf&originHeight=142&originWidth=1394&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/image-20210227171119590.png#id=XyVG3&originHeight=141&originWidth=1396&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">6.创建redis-cluster集群：在其中一个节点操作就可以</span><br><span class="line">redis节点搭建起来后，需要完成redis cluster集群搭建，搭建集群过程中，需要保证6个redis实例都是运行状态。</span><br><span class="line">Redis是根据IP和Port的顺序，确定master和slave的，所以要排好序，再执行。</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">--cluster-replicas 1:表示为集群中的每个主节点创建一个从节点.书写流程:主节点ip+port 对应一个从节点ip+port（注意:若节点在不同的机器上，注意主节点的书写位置，要避免主节点在同一台机器上，影响性能。正常是前面三个节点为主节点，后面的为从节点）</span><br><span class="line"></span><br><span class="line">[root@redis-cluster1 src]# cd /data/redis/src/</span><br><span class="line">[root@redis-cluster1 src]# ./redis-cli --cluster create --cluster-replicas 1 192.168.174.130:6379 192.168.174.131:6379 192.168.174.132:6379 192.168.174.133:6379 192.168.174.134:6379 192.168.174.135:6379</span><br><span class="line"></span><br><span class="line">192.168.116.172:7000 192.168.116.172:7001 192.168.116.173:7002 192.168.116.173:7003 192.168.116.174:7004 192.168.116.174:7005</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.116.173:7003 to 192.168.116.172:7000</span><br><span class="line">Adding replica 192.168.116.174:7005 to 192.168.116.173:7002</span><br><span class="line">Adding replica 192.168.116.172:7001 to 192.168.116.174:7004</span><br><span class="line">M: de5b4b2f6a559362ed56d4de1e3994fd529917b5 192.168.116.172:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">S: 2e8c1caa63ac4a1b9a6eea4f0fd5eab4c6b73c21 192.168.116.172:7001</span><br><span class="line">   replicates 60e3755761c9cbdacb183f59e3d6205da5335e86</span><br><span class="line">M: e0370608cd33ddf5bb6de48b5627799e181de3b6 192.168.116.173:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: 4035841f20f07674671e6bff5d4c6db99c00626b 192.168.116.173:7003</span><br><span class="line">   replicates de5b4b2f6a559362ed56d4de1e3994fd529917b5</span><br><span class="line">M: 60e3755761c9cbdacb183f59e3d6205da5335e86 192.168.116.174:7004</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: e200afc33b10bd6975160bfeda7277d02371981a 192.168.116.174:7005</span><br><span class="line">   replicates e0370608cd33ddf5bb6de48b5627799e181de3b6</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes  #写yes同意</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 192.168.116.172:7000)</span></span><br><span class="line">M: de5b4b2f6a559362ed56d4de1e3994fd529917b5 192.168.116.172:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e0370608cd33ddf5bb6de48b5627799e181de3b6 192.168.116.173:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 2e8c1caa63ac4a1b9a6eea4f0fd5eab4c6b73c21 192.168.116.172:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 60e3755761c9cbdacb183f59e3d6205da5335e86</span><br><span class="line">M: 60e3755761c9cbdacb183f59e3d6205da5335e86 192.168.116.174:7004</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4035841f20f07674671e6bff5d4c6db99c00626b 192.168.116.173:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates de5b4b2f6a559362ed56d4de1e3994fd529917b5</span><br><span class="line">S: e200afc33b10bd6975160bfeda7277d02371981a 192.168.116.174:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e0370608cd33ddf5bb6de48b5627799e181de3b6</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/image-20210323164542348.png#id=xfNMs&originHeight=438&originWidth=908&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7.查看集群状态可连接集群中的任一节点，此处连接了集群中的节点192.168.116.172:7000</span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;登录集群客户端，-c标识以集群方式登录</span></span><br><span class="line">[root@redis-cluster1 src]# ./redis-cli -h 192.168.116.172 -c -p 7000</span><br><span class="line">192.168.116.172:7000&gt; ping</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看集群信息</span></span><br><span class="line">192.168.116.173:7002&gt; cluster info</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151322482.png" alt="image-20240815132244405"></p><blockquote><ul><li><strong><code>cluster_state:ok</code></strong>:<ul><li>集群的当前状态。<code>ok</code> 表示集群正常运行。如果为 <code>fail</code>，表示集群出现问题（例如某个节点不可达或有故障）。</li></ul></li><li><strong><code>cluster_slots_assigned:16384</code></strong>:<ul><li>集群中已分配的哈希槽数量。Redis 集群的哈希槽总数是 16384，表示所有槽都已分配。</li></ul></li><li><strong><code>cluster_slots_ok:16384</code></strong>:<ul><li>集群中正常工作的哈希槽数量。这里为 16384，表示所有槽都正常。</li></ul></li><li><strong><code>cluster_slots_pfail:0</code></strong>:<ul><li>处于 <code>pfail</code>（潜在故障）状态的哈希槽数量。<code>pfail</code> 表示集群认为某些节点可能有问题，但尚未完全确认。这里为 0，表示没有节点处于潜在故障状态。</li></ul></li><li><strong><code>cluster_slots_fail:0</code></strong>:<ul><li>处于 <code>fail</code> 状态的哈希槽数量。<code>fail</code> 表示有节点被标记为已故障，并且集群确认它们无法工作。这里为 0，表示没有节点发生故障。</li></ul></li><li><strong><code>cluster_known_nodes:8</code></strong>:<ul><li>集群中已知的节点数量。这里为 8，表示集群中有 8 个节点，这些节点包括主节点和从节点。</li></ul></li><li><strong><code>cluster_size:4</code></strong>:<ul><li>集群的大小，即主节点的数量。这里为 4，表示集群中有 4 个主节点。</li></ul></li><li><strong><code>cluster_current_epoch:8</code></strong>:<ul><li>当前集群的 <code>epoch</code>（纪元）。<code>epoch</code> 用于处理集群的重新分片或节点选举。在集群中，每次重新选主或分配槽时，<code>epoch</code> 会递增。</li></ul></li><li><strong><code>cluster_stats_messages_ping_sent:1923</code></strong>:<ul><li>该节点向集群中其他节点发送的 <code>ping</code> 消息数量。这里为 1923，表示该节点已经发送了 1923 条 <code>ping</code> 消息来监控集群中的其他节点状态。</li></ul></li><li><strong><code>cluster_stats_messages_pong_sent:1955</code></strong>:<ul><li>该节点向集群中其他节点发送的 <code>pong</code> 消息数量。这里为 1955，表示该节点响应了 1955 次其他节点发送的 <code>ping</code> 消息。</li></ul></li><li><strong><code>cluster_stats_messages_sent:3878</code></strong>:<ul><li>该节点发送的所有类型的消息总数，包括 <code>ping</code>、<code>pong</code>等消息类型。这里总计为 3878 条消息。</li></ul></li><li><strong><code>cluster_stats_messages_ping_received:1955</code></strong>:<ul><li>该节点接收到的 <code>ping</code> 消息数量。这里为 1955，表示该节点接收了 1955 条来自其他节点的 <code>ping</code> 消息。</li></ul></li><li><strong><code>cluster_stats_messages_pong_received:1923</code></strong>:<ul><li>该节点接收到的 <code>pong</code> 消息数量。这里为 1923，表示该节点接收了 1923 条来自其他节点的 <code>pong</code> 消息。</li></ul></li><li><strong><code>cluster_stats_messages_received:3878</code></strong>:<ul><li>该节点接收到的所有类型的消息总数。包括 <code>ping</code>、<code>pong</code> 等消息类型。</li></ul></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 查看集群节点</span></span><br><span class="line">192.168.174.50:6379&gt; CLUSTER nodes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151326241.png" alt="image-20240815132602182"></p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">05a613685a2f0e49c5be0603ad5a867ac64bd601 192.168.174.54:6379@16379 master - 0 1723698435000 8 connected 1333-5460</span><br></pre></td></tr></table></figure><ul><li><strong><code>05a613685a2f0e49c5be0603ad5a867ac64bd601</code></strong>:<ul><li>节点的唯一标识符 (Node ID)，用于唯一标识 Redis 集群中的每个节点。</li></ul></li><li><strong><code>192.168.174.54:6379@16379</code></strong>:<ul><li>节点的 IP 地址和端口号。<code>192.168.174.54</code> 是 IP 地址，<code>6379</code> 是 Redis 的服务端口，<code>16379</code> 是集群端口。</li></ul></li><li><strong><code>master</code></strong>:<ul><li>节点的角色。在此行中，该节点是 <code>master</code> 节点，表示它是集群中的主节点，负责管理指定范围的哈希槽。</li></ul></li><li><strong><code>-</code></strong>:<ul><li>此字段用于标记节点的状态或者对某些节点的关系。在此处显示为 <code>-</code>，表示该节点没有故障。</li></ul></li><li><strong><code>0</code></strong>:<ul><li>这是节点的延迟时间（ping-sent），即上次向该节点发送 ping 的时间。<code>0</code> 表示当前未发送 ping。</li></ul></li><li><strong><code>1723698435000</code></strong>:<ul><li>上次接收到节点 pong 响应的时间戳，单位为毫秒。</li></ul></li><li><strong><code>8</code></strong>:<ul><li>节点的 纪元，用于协调集群中的选举和状态同步。</li></ul></li><li><strong><code>connected</code></strong>:<ul><li>节点的连接状态。<code>connected</code> 意味节点目前在线且正常连接到集群。</li></ul></li><li><strong><code>1333-5460</code></strong>:<ul><li>该节点负责的哈希槽范围。</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18ede67545805ff44b1183bdeb3be6a513ded867 192.168.174.55:6379@16379 slave e473d8099e960ce1e5cd44807efd10f80706dfff 0 1723698435170 2 connected</span><br></pre></td></tr></table></figure><ul><li><strong><code>18ede67545805ff44b1183bdeb3be6a513ded867</code></strong>:<ul><li>节点的唯一标识符 (Node ID)。</li></ul></li><li><strong><code>192.168.174.55:6379@16379</code></strong>:<ul><li>节点的 IP 地址和端口号。<code>192.168.174.55</code> 是 IP 地址，<code>6379</code> 是 Redis 的服务端口，<code>16379</code> 是集群端口。</li></ul></li><li><strong><code>slave</code></strong>:<ul><li>该节点的角色是 <code>slave</code>。</li></ul></li><li><strong><code>e473d8099e960ce1e5cd44807efd10f80706dfff</code></strong>:<ul><li><code>slave</code> 节点所属的主节点的 ID。该从节点在从主节点复制数据。</li></ul></li><li><strong><code>0</code></strong>:<ul><li>节点的延迟时间（ping-sent），即上次向该节点发送 ping 的时间。这里的 <code>0</code> 表示当前未发送 ping。</li></ul></li><li><strong><code>1723698435170</code></strong>:<ul><li>这是上次接收到节点 pong 响应的时间戳，单位为毫秒。</li></ul></li><li><strong><code>2</code></strong>:<ul><li>节点的 纪元，用于协调集群中的选举和状态同步。</li></ul></li><li><strong><code>connected</code></strong>:<ul><li>节点的连接状态。<code>connected</code> 意味着该节点目前在线且正常连接到集群。</li></ul></li></ul></blockquote><h1 id="三、集群操作"><a href="#三、集群操作" class="headerlink" title="三、集群操作"></a>三、集群操作</h1><h2 id="1、客户端登陆"><a href="#1、客户端登陆" class="headerlink" title="1、客户端登陆"></a>1、客户端登陆</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">测试链接redis，存取数据(链接集群中任意一台机器就可以。)</span><br><span class="line">存：</span><br><span class="line">[root@redis-cluster1 src]# ./redis-cli -h 192.168.116.172 -c -p 7000</span><br><span class="line">192.168.116.172:7000&gt; ping</span><br><span class="line">PONG</span><br><span class="line">192.168.116.172:7000&gt; set name qianfeng</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [5798] located at 192.168.116.173:7002</span></span><br><span class="line">OK</span><br><span class="line">192.168.116.173:7002&gt;</span><br><span class="line"></span><br><span class="line">读</span><br><span class="line">[root@redis-cluster3 src]# ./redis-cli -h 192.168.116.173 -c -p 7002</span><br><span class="line">192.168.116.173:7002&gt; ping</span><br><span class="line">PONG</span><br><span class="line">192.168.116.173:7002&gt; get name</span><br><span class="line">"qianfeng"</span><br><span class="line">192.168.116.173:7002&gt; exists name  #查看某一个key是否存在</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h2 id="2、Redis-Cluster-添加节点"><a href="#2、Redis-Cluster-添加节点" class="headerlink" title="2、Redis Cluster 添加节点"></a>2、Redis Cluster 添加节点</h2><ol><li><strong>环境准备</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.56 redis07</span><br><span class="line">192.168.174.57 redis08</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>两台服务器安装redis实例</strong></li></ol><p>略</p><ol start="3"><li><strong>添加的master节点操作</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 添加软连接</span></span><br><span class="line">[root@redis07 ~]<span class="comment"># ln -s /usr/local/redis/src/redis-cli  /usr/bin/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 加入Redis Cluster集群</span></span><br><span class="line">[root@redis07 ~]<span class="comment"># redis-cli --cluster add-node 192.168.174.56:6379 192.168.174.51:6379</span></span><br></pre></td></tr></table></figure><blockquote><p>参数解释：</p><ul><li>192.168.174.56:6379   当前需要加入集群的master地址</li><li>192.168.174.51:6379   加入的集群中存在的任意master地址</li></ul></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151909547.png" alt="image-20240815190931101"></p><ol start="4"><li><strong>登录集群任意节点查看</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@redis01 redis]<span class="comment"># redis-cli  -h 192.168.174.50 -c</span></span><br><span class="line">192.168.174.50:6379&gt; cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151910155.png" alt="image-20240815191056049"></p><ol start="5"><li><p><strong>给新节点分配Hash槽</strong></p><p>需要给新节点进行hash槽分配，这样该主节才可以存储数据。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@redis01 redis]<span class="comment"># redis-cli  --cluster reshard 192.168.174.56:6379</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.116.175:7006)</span><br><span class="line">......</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 4000 <span class="comment">#输入要分配的槽数量 </span></span><br><span class="line">What is the receiving node ID?  828c48dc72d52ff5be972512d3d87b70236af87c <span class="comment">#输入接收槽的节点id,通过cluster nodes 查看新增的192.168.174.56:6379 的id</span></span><br><span class="line"></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">输入： all</span><br><span class="line">然后输入输入yes确认</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>查看集群节点分配的槽位</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.52:6379&gt; cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151917575.png" alt="image-20240815191716473"></p><ol start="8"><li><strong>给master添加slave</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@redis01 redis]<span class="comment"># redis-cli --cluster add-node 192.168.174.57:6379 192.168.174.56:6379 --cluster-slave --cluster-master-id d9a270610aad049ab23045f6ed9098c58591c7b3</span></span><br></pre></td></tr></table></figure><blockquote><p>参数解释：</p><ul><li>192.168.174.57:6379  添加的slave节点ip+端口</li><li>192.168.174.56:6379  需要添加slave的master节点ip+端口</li><li>d9a270610aad049ab23045f6ed9098c58591c7b3  需要添加slave的master节点的标识码</li></ul></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151948284.png" alt="image-20240815194824248"></p><ol start="9"><li><strong>平衡各个主节点的槽</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@redis01 redis]<span class="comment"># redis-cli --cluster rebalance --cluster-threshold 1 192.168.174.56:6379</span></span><br><span class="line"><span class="comment"># --cluster-threshold 1 只要不均衡的slot数量超过1,就触发rebanlance</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151951528.png" alt="image-20240815195134465"></p><ol start="10"><li><strong>测试</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.52:6379&gt; <span class="built_in">set</span> ccc ddd</span><br><span class="line">-&gt; Redirected to slot [135] located at 192.168.174.56:6379</span><br><span class="line">OK</span><br><span class="line">192.168.174.56:6379&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"name02"</span></span><br><span class="line">3) <span class="string">"ccc"</span></span><br></pre></td></tr></table></figure><h2 id="3、Redis-Cluster移除节点"><a href="#3、Redis-Cluster移除节点" class="headerlink" title="3、Redis Cluster移除节点"></a>3、Redis Cluster移除节点</h2><p> <strong>如果要下线节点6，节点7，请务必先下线从节点，并且节点6的slot的迁移到其他节点了，如果先线下节点6的话 会发产生故障切换，节点7成主节点了。在移除某个redis节点之前，首先不能在登入该节点当中，否则不能正常移除该节点。</strong></p><ol><li><strong>移除从节点</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@redis01 redis]<span class="comment"># redis-cli --cluster del-node 192.168.174.57:6379 7df33a0481c29290a14769e4f77e9f5654f20e3d</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151957154.png" alt="image-20240815195705121"></p><ol start="2"><li><strong>查看集群节点</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.56:6379&gt; cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151957171.png" alt="image-20240815195753038"></p><ol start="3"><li><strong>查看每个节点槽的数量</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@redis01 redis]<span class="comment"># redis-cli  --cluster info 192.168.174.56:6379</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408152000626.png" alt="image-20240815200036592"></p><blockquote><p>要删除的当前主节点哈希槽状态：<code>0-1364 5461-6826 10923-12287</code><br>共有哈希槽=<code>1365 + 1366 + 1365 = 4096个</code></p></blockquote><ol start="4"><li>将<code>redis06</code>节点上面的槽迁移到其他节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip+port：要移除的节点</span></span><br><span class="line"><span class="comment"># cluster-from:移除节点的id</span></span><br><span class="line"><span class="comment"># cluster-to:接受槽主节点的id，需要将4096平均移动到不同的主节点，需要写不同接受槽的主节点id</span></span><br><span class="line"><span class="comment"># cluster-slots:移除槽的数量</span></span><br><span class="line"></span><br><span class="line">redis-cli --cluster reshard 192.168.174.56:6379 --cluster-from d9a270610aad049ab23045f6ed9098c58591c7b3 --cluster-to 788f2fbe060a59449a31da7a0c8afc384007387b --cluster-slots 1365 --cluster-yes</span><br><span class="line"></span><br><span class="line">redis-cli --cluster reshard 192.168.174.56:6379 --cluster-from d9a270610aad049ab23045f6ed9098c58591c7b3 --cluster-to 98a4ff6a6533f30a2c3211f28f4c5a709949d44e --cluster-slots 1366 --cluster-yes</span><br><span class="line"></span><br><span class="line">redis-cli --cluster reshard 192.168.174.56:6379 --cluster-from d9a270610aad049ab23045f6ed9098c58591c7b3 --cluster-to 58fa947712a4a3af5fde37982f4ea02126655e02 --cluster-slots 1365 --cluster-yes</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>查看集群节点信息</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.56:6379&gt; cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408152007085.png" alt="image-20240815200748940"></p><ol start="6"><li><strong>删除节点</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.174.56:6379  d9a270610aad049ab23045f6ed9098c58591c7b3</span><br></pre></td></tr></table></figure><blockquote><p>参数解释：</p><ul><li>192.168.174.56:6379  需要删除的节点IP+端口</li><li>d9a270610aad049ab23045f6ed9098c58591c7b3  节点标识码</li></ul></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408152010340.png" alt="image-20240815201059309"></p><ol start="7"><li><strong>查看集群节点信息</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.51:6379&gt; cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408152011138.png" alt="image-20240815201150073"></p><h1 id="四、主从切换"><a href="#四、主从切换" class="headerlink" title="四、主从切换"></a>四、主从切换</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line">1.将节点cluster1的主节点7000端口的redis关掉</span><br><span class="line">[root@redis-cluster1 src]# ps -ef |grep redis </span><br><span class="line">root      15991      1  0 01:04 ?        00:02:24 ./redis-server 192.168.116.172:7000 [cluster]</span><br><span class="line">root      16016      1  0 01:04 ?        00:02:00 ./redis-server 192.168.116.172:7001 [cluster]</span><br><span class="line">root      16930   1595  0 08:04 pts/0    00:00:00 grep --color=auto redis</span><br><span class="line">[root@redis-cluster1 src]# kill -9 15991</span><br><span class="line"></span><br><span class="line">查看集群信息：</span><br><span class="line">192.168.116.173:7002&gt; CLUSTER nodes</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/image-20210228001320857.png#id=xicjO&originHeight=311&originWidth=1886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><p>可以看到7000端口这个redis已经是fail失败的了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.将该节点的7000端口redis启动在查看</span><br><span class="line">[root@redis-cluster1 log]# cd /data/redis/src/</span><br><span class="line">[root@redis-cluster1 src]# ./redis-server ../cluster/7000/redis.conf</span><br><span class="line"></span><br><span class="line">查看节点信息：</span><br><span class="line">192.168.116.173:7002&gt; CLUSTER nodes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408151311810.png" alt="image-20240815131113698"></p><h3 id="redis面试问题整理"><a href="#redis面试问题整理" class="headerlink" title="redis面试问题整理"></a>redis面试问题整理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">一、如何解决Redis，mysql双写一致性？</span><br><span class="line">1.最经典的缓存+数据库读写的模式:</span><br><span class="line">读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</span><br><span class="line">更新的时候，先更新数据库，然后再删除缓存。</span><br><span class="line">2.给缓存设置过期时间，这种方案下，可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</span><br><span class="line"></span><br><span class="line">二、缓存雪崩</span><br><span class="line">数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</span><br><span class="line">产生雪崩的简单过程：</span><br><span class="line">1、redis集群大面积故障</span><br><span class="line">2、缓存失效，但依然大量请求访问缓存服务redis</span><br><span class="line">3、redis大量失效后，大量请求转向到mysql数据库，mysql的调用量暴增，很快就扛不住了，甚至直接宕机</span><br><span class="line">4、由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。</span><br><span class="line"><span class="meta">#</span><span class="bash">解决：</span></span><br><span class="line"></span><br><span class="line">1.缓存的高可用性</span><br><span class="line">缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。</span><br><span class="line"></span><br><span class="line">2.缓存降级</span><br><span class="line">可以利用ehcache等本地缓存(暂时支持)，主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。</span><br><span class="line">当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。</span><br><span class="line">降级的最终目的是保证核心服务可用，即使是有损的。</span><br><span class="line">在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体。</span><br><span class="line"></span><br><span class="line">3.Redis备份和快速预热</span><br><span class="line">1)Redis数据备份和恢复</span><br><span class="line">2)快速缓存预热</span><br><span class="line"></span><br><span class="line">4.提前演练</span><br><span class="line">最后，建议还是在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。</span><br><span class="line"></span><br><span class="line">三、缓存穿透</span><br><span class="line">缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</span><br><span class="line">解决：</span><br><span class="line">如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。</span><br><span class="line"></span><br><span class="line">四、缓存并发</span><br><span class="line">这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。</span><br><span class="line"></span><br><span class="line">五、缓存预热</span><br><span class="line">缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。</span><br><span class="line">这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</span><br><span class="line">解决：</span><br><span class="line">1、直接写个缓存刷新页面，上线时手工操作下；</span><br><span class="line">2、数据量不大，可以在项目启动的时候自动进行加载；</span><br><span class="line">目的就是在系统上线前，将数据加载到缓存中。</span><br><span class="line"></span><br><span class="line">其他面试：</span><br><span class="line">1.Redis官方为什么不提供Windows版本？</span><br><span class="line">因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</span><br><span class="line">2.一个字符串类型的值能存储最大容量是多少？</span><br><span class="line">512M</span><br><span class="line">3.Redis集群方案什么情况下会导致整个集群不可用？</span><br><span class="line">有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</span><br><span class="line">4.说说Redis哈希槽的概念？</span><br><span class="line">Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</span><br><span class="line">5.Redis集群之间是如何复制的？</span><br><span class="line">异步复制</span><br><span class="line">6.Redis集群最大节点个数是多少？</span><br><span class="line">16384个。</span><br><span class="line">7.Redis集群如何选择数据库？</span><br><span class="line">Redis集群目前无法做数据库选择，默认在0数据库。</span><br><span class="line">8.怎么测试Redis的连通性？</span><br><span class="line">ping</span><br><span class="line">9.如何与Redis互动？</span><br><span class="line">安装服务器后，您可以运行redis安装提供的Redis客户端，也可以打开命令提示符并使用以下命令：</span><br><span class="line">redis-cli</span><br><span class="line">10.使用Redis有什么好处？</span><br><span class="line">Redis非常快。</span><br><span class="line">它支持服务器端锁定。</span><br><span class="line">它有一个丰富的客户端库。</span><br><span class="line">这是一个很好的反击。</span><br><span class="line">它支持原子操作。</span><br><span class="line">11.使用Redis有哪些缺点/限制？</span><br><span class="line">它是单线程的。</span><br><span class="line">它对一致哈希的客户端支持有限。</span><br><span class="line">它具有很大的持久性开销。</span><br><span class="line">它没有广泛部署。</span><br><span class="line">12.Redis和RDBMS有什么区别？</span><br><span class="line">Redis是NoSQL数据库，而RDBMS是SQL数据库。</span><br><span class="line">Redis遵循键值结构，而RDBMS遵循表结构。</span><br><span class="line">Redis非常快，而RDBMS相对较慢。</span><br><span class="line">Redis将所有数据集存储在主存储器中，而RDBMS将其数据集存储在辅助存储器中。</span><br><span class="line">Redis通常用于存储小型和常用文件，而RDBMS用于存储大文件。</span><br><span class="line">Redis仅为Linux，BSD，Mac OS X，Solaris提供官方支持。它目前没有为Windows提供官方支持，而RDBMS提供对两者的支持</span><br><span class="line">13.什么是redis的事务？</span><br><span class="line">a）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</span><br><span class="line">b）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</span><br><span class="line">14.Redis单点吞吐量</span><br><span class="line">单点TPS达到8万/秒，QPS达到10万/秒，补充下TPS和QPS的概念</span><br><span class="line">1.QPS: 应用系统每秒钟最大能接受的用户访问量</span><br><span class="line">每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。</span><br><span class="line">2.TPS： 每秒钟最大能处理的请求数</span><br><span class="line">每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。</span><br><span class="line"></span><br><span class="line">问题2:Redis的多数据库机制，了解多少？</span><br><span class="line">正常：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，单机下的redis可以支持16个数据库（db0 ~ db15）</span><br><span class="line">集群: 在Redis Cluster集群架构下只有一个数据库空间，即db0。因此，我们没有使用Redis的多数据库功能！</span><br><span class="line"></span><br><span class="line">问题3:Redis集群机制中，你觉得有什么不足的地方吗？</span><br><span class="line">假设我有一个key，对应的value是Hash类型的。如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上！还有就是做批量操作比较麻烦！</span><br><span class="line"></span><br><span class="line">问题4:懂Redis的批量操作么？</span><br><span class="line">正常: 比如mset、mget操作等</span><br><span class="line">集群: 我们在生产上采用的是Redis Cluster集群架构，不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通的。</span><br><span class="line"></span><br><span class="line">问题6:你们有对Redis做读写分离么？</span><br><span class="line">正常:没有做</span><br><span class="line">集群:不做读写分离。我们用的是Redis Cluster的架构，是属于分片集群的架构。而redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</span><br></pre></td></tr></table></figure><p>elk相关面试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.ELK能做什么？</span><br><span class="line">ELK组件在海量日志系统的运维中，可用于解决：</span><br><span class="line">分布式日志数据集中式查询和管理</span><br><span class="line">系统监控，包含系统硬件和应用各个组件的监控</span><br><span class="line">故障排查</span><br><span class="line">安全信息和事件管理</span><br><span class="line">报表功能</span><br><span class="line"></span><br><span class="line">2.ES与关系数据库对比</span><br><span class="line">在 ES 中，文档归属于一种 类型 (type) ，而这些类型存在于索引 (index) 中，类比传统关系型数据库</span><br><span class="line">DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">关系型      数据库          表            行              列  </span><br><span class="line"></span><br><span class="line">ES -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br><span class="line">ES       索引            类型            文档           域（字段）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://l66stbz.github.io/tags/Redis/"/>
    
      <category term="Cluster" scheme="https://l66stbz.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL-Redis</title>
    <link href="https://l66stbz.github.io/2024/08/14/NoSQL-Redis/"/>
    <id>https://l66stbz.github.io/2024/08/14/NoSQL-Redis/</id>
    <published>2024-08-14T14:50:00.000Z</published>
    <updated>2024-08-17T07:53:47.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis-缓存数据库"><a href="#Redis-缓存数据库" class="headerlink" title="Redis 缓存数据库"></a>Redis 缓存数据库</h1><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>缓存数据库是一种<strong><code>位于应用程序与主要后端数据库之间的中间层，用于提高数据访问速度的技术</code></strong>。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405131854766.png" alt="image-20240513185433565"></p><p>以下是一些关于缓存数据库的详细介绍： </p><ol><li><strong>作用</strong>：缓存数据库主要用于存储那些<code>频繁访问</code>或计算成本较高的数据副本。这些数据通常被放置在高速、低延迟的存储介质上，如内存中，以便快速访问。<code>加快访问速度 ,缓解关系型数据库的读压力</code>。</li><li><strong>使用场景</strong>：当应用程序需要数据时，首先会从<code>缓存</code>中查询。如果所需数据在<code>缓存</code>中存在，则可以直接获取，从而避免了<code>直接访问</code>主数据库的步骤，这可以显著减少数据<code>检索</code>的时间，并减轻主数据库的<code>负载</code>。</li><li><strong>常见类型</strong>：<ul><li><strong><code>Redis</code></strong>：它是一种非关系型（NoSQL）<code>内存键值</code>存储数据库，支持多种数据结构，包括字符串、哈希、列表等。Redis以其快速的读写能力和丰富的功能而闻名，适用于缓存、消息传递、会话存储等多种场景。</li><li><strong>Memcached</strong>：同样是键值对形式的内存缓存系统，设计相对简单，主要用于缓存常用数据，特别适应于分布式环境中的数据缓存需求。</li></ul></li><li><strong>优势</strong>：缓存数据库的使用可以减少数据库的<code>读取次数</code>，加快数据的处理速度，改善用户体验，并在高流量环境下保持系统的响应性和稳定性。</li></ol><blockquote><p><strong>注意事项</strong>：缓存数据库固然提供了许多好处，但也要注意数据一致性和缓存失效的问题。必须确保在适当的时候更新或清除缓存，以避免过时或错误的数据被使用。</p></blockquote><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a><strong>1、简介</strong></h3><p>NoSQL产品: <strong>Redis</strong>、<strong>MongoDB</strong>、<strong>Memcached</strong></p><ul><li>MongoDB：<ul><li><strong>基于文档的数据存储</strong>：MongoDB使用BSON（类似JSON）格式存储数据，这使得数据结构灵活且易于扩展。</li></ul></li></ul><p>NOSQL名词解释：非关系型数据库;<code>通常</code>是以键值对的方式存储数据（<strong>Key-Value</strong>）的形式。</p><h3 id="2、NoSQL的优点-缺点"><a href="#2、NoSQL的优点-缺点" class="headerlink" title="2、NoSQL的优点/缺点"></a>2、NoSQL的优点/缺点</h3><p>优点：</p><ul><li><strong>数据模型灵活性</strong><ul><li>NoSQL数据库不需要<code>预先定义表结构</code>，可以根据实际需求动态调整<code>数据类型</code>。</li></ul></li><li><strong>高可扩展性</strong><ul><li>NoSQL数据库采用<code>分布式</code>架构，可以通过水平扩展来处理<code>大规模</code>数据和<code>高并发</code>读写。通过在集群中添加更多的节点，可以提高数据库的性能和容量。这种高可扩展性使得NoSQL数据库适用于大规模数据处理和高并发场景，可以满足业务的快速增长需求。</li></ul></li><li><strong>高性能</strong><ul><li>NoSQL数据库通常采用<code>内存存储</code>，以及并行计算和<code>分布式</code>计算技术，可以提供高性能的数据存储和查询能力。在对数据进行读取和写入操作时，NoSQL数据库可以快速响应，提供低延迟的数据访问。</li></ul></li></ul><p>缺点：</p><ul><li><code>一致性问题</code><ul><li>NoSQL数据库通常采用最终一致性的策略，即在一段时间内达到一致状态，可以容忍一定的数据不一致性。在数据更新和复制过程中，可能会出现数据不一致的情况。</li></ul></li><li>查询能力限制<ul><li>NoSQL数据库的查询能力相对较弱，通常只支持基本的查询操作。与传统关系型数据库相比，NoSQL数据库缺少复杂的查询操作和聚合函数。在需要进行复杂的数据查询和分析的场景中，NoSQL数据库的查询能力可能无法满足需求。</li></ul></li><li>缺乏标准化<ul><li>NoSQL数据库的种类繁多，没有一个统一的标准化规范。不同的NoSQL数据库具有不同的查询语言。</li></ul></li></ul><h3 id="3、关系型数据库与非关系型数据库的区别：———面试高频率问题"><a href="#3、关系型数据库与非关系型数据库的区别：———面试高频率问题" class="headerlink" title="3、关系型数据库与非关系型数据库的区别：———面试高频率问题"></a>3、关系型数据库与非关系型数据库的区别：———面试高频率问题</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.首先了解一下 什么是关系型数据库？</span><br><span class="line">关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">1、易于维护：都是使用表结构，格式一致；</span><br><span class="line">2、使用方便：SQL语言通用，可用于复杂查询；</span><br><span class="line">3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</span><br><span class="line">缺点：</span><br><span class="line">1、读写性能比较差，尤其是海量数据的高效率读写；</span><br><span class="line">2、固定的表结构，灵活度稍欠；</span><br><span class="line">3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈；</span><br><span class="line"></span><br><span class="line">二 非关系型数据库</span><br><span class="line">什么非关系型数据库呢？</span><br><span class="line"></span><br><span class="line">非关系型数据是一种数据结构化存储方法的集合，可以是文档或者键值对等</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</span><br><span class="line">2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；</span><br><span class="line">3、高扩展性；</span><br><span class="line">4、成本低：nosql数据库部署简单，基本都是开源软件。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1、不提供sql支持，学习和使用成本较高；</span><br><span class="line">2、无事务处理；</span><br><span class="line">3、数据结构相对复杂，复杂查询方面稍欠。</span><br></pre></td></tr></table></figure><h2 id="2、Memcached"><a href="#2、Memcached" class="headerlink" title="2、Memcached"></a>2、Memcached</h2><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ol><li><code>分布式缓存</code><br>Memcached是一个分布式的缓存系统，可以将<code>数据存储</code>在多个服务器上，从而提供更高的<code>可用性</code>和<code>可扩展</code>性。</li><li><code>内存存储</code><br>Memcached将缓存数据存储在<code>内存</code>中，因此读取速度<code>非常快</code>，适用于需要快速访问的数据。由于数据存储在内存中，读取速度非常快，适用于缓存热点数据。但是服务器重启后，数据会丢失。</li><li>键值存储<br>Memcached采用键值对存储数据，通过键(key)快速定位和检索数据值(value)。</li><li>自动过期<br>缓存数据可以设置过期时间，过期后自动从缓存中移除，避免数据过时或脏数据的问题。</li><li><code>缓存逐出策略</code><br>当内存不足时，Memcached会根据一定的策略逐出部分数据，为新数据腾出空间。</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405131914933.png" alt></p><h3 id="2-2-服务框架"><a href="#2-2-服务框架" class="headerlink" title="2.2 服务框架"></a>2.2 服务框架</h3><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405131914275.png" alt></p><p><strong>原理</strong></p><p>1、检查客户端的请求数据是否在memcached中，如有，直接把请求2数据返回，不再对数据库进行任何操作，路径操作为①②③⑦。<br>2、如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现），路径操作为①②④⑤⑦⑥。</p><p>3、保持缓存的<code>新鲜性</code>，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步更新的缓存信息，确保用户不会在缓存取到旧的数据。</p><h3 id="2-3-配置安装Memcached"><a href="#2-3-配置安装Memcached" class="headerlink" title="2.3 配置安装Memcached"></a>2.3 配置安装Memcached</h3><p>memcache能存放多少数据，取决于服务器本身的内存有多大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1.安装----准备一台服务器</span><br><span class="line">[root@memcached ~]# yum install memcached -y</span><br><span class="line">[root@memcached ~]# systemctl start memcached  #启动</span><br><span class="line">2.修改配置文件</span><br><span class="line">[root@memcached ~]# vim /etc/sysconfig/memcached</span><br><span class="line">PORT="11211"    ---监听的端口，默认11211可以修改</span><br><span class="line">USER="memcached"  -----用户</span><br><span class="line">MAXCONN="1024"   -----默认并发，可以修改</span><br><span class="line">CACHESIZE="64"    ------给的内存。默认是M</span><br><span class="line">OPTIONS=""       ----监听的网络地址</span><br><span class="line">然后把ip地址发给开发人员，开发的会使用api接口连接memcached.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装telent,Telnet是一种用于远程登录的协议。传输数据是明文的，存在安全性问题。</span></span><br><span class="line">[root@memcached ~]# yum install -y telnet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 测试</span></span><br><span class="line">[root@memcached ~]# telnet 192.168.246.188 11211</span><br><span class="line">Trying 192.168.246.188...</span><br><span class="line">Connected to 192.168.246.188.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">set name 0 60 10    # key名   标记位(id号)   过期时间  大小</span><br><span class="line">helloworld        #  name的key值</span><br><span class="line">STORED         # 出现stoped表示已经存储成功。</span><br><span class="line">get name       #查询key值</span><br><span class="line">VALUE name 0 10</span><br><span class="line">helloword</span><br><span class="line">END</span><br><span class="line">quit   ---退出</span><br><span class="line">参数解释:</span><br><span class="line"><span class="meta">#</span><span class="bash"> name：key的名字 自己定义</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0：key的id号，需要和其他的key不一样</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 60：缓存过期时间,单位为秒，0为永远</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9：字符串最大长度</span></span><br><span class="line"></span><br><span class="line">不用它的原因：存储的数据类型单一，而且数据只能存储在内存中。无法实现数据的持久化，服务器重启，数据将消失。</span><br><span class="line">========================================================================</span><br><span class="line">扩展:安装php支持memcached的扩展模块: 安装php7.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装PHP依赖的epel源</span></span><br><span class="line">[root@memcached ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装PHP yum源</span></span><br><span class="line">[root@memcached ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装PHP</span></span><br><span class="line">[root@memcached ~]# yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 php70w-devel zlib-devel make gcc zlib-devel libmemcached-devel git php70w-fpm -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 下载PHP Memcache 扩展包</span></span><br><span class="line">[root@memcached ~]# yum install libmemcached php70w-pecl-memcached -y</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装nginx</span></span><br><span class="line">[root@memcached ~]# yum -y install nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 配置默认界面</span></span><br><span class="line">[root@memcached ~]# vim /etc/nginx/conf.d/default.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        root           /usr/share/nginx/html;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编辑php页面</span></span><br><span class="line">[root@memcached ~]# cd /usr/share/nginx/html/index.php</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动服务</span></span><br><span class="line">[root@memcached ~]# systemctl enable --now nginx php-fpm</span><br></pre></td></tr></table></figure><blockquote><p>游览器访问：<a href="http://192.168.174.38/index.php" target="_blank" rel="noopener">http://192.168.174.38/index.php</a></p></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408131446837.png" alt="image-20240813144523867"></p><h2 id="3、Redis服务"><a href="#3、Redis服务" class="headerlink" title="3、Redis服务"></a>3、Redis服务</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p><strong>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库</strong>，它支持多种数据结构，如<code>字符串</code>（strings）、<code>散列</code>（hashes）、列表</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/4c8ac61a7ac746b693b4237ed8b9b7f5.png" alt="img"></p><p><strong>redis的官网：</strong><a href="http://www.redis.io" target="_blank" rel="noopener">www.redis.io</a></p><h4 id="3-1-1-redis的特点"><a href="#3-1-1-redis的特点" class="headerlink" title="3.1.1 redis的特点:"></a>3.1.1 redis的特点:</h4><ul><li><strong>高性能</strong>：由于数据存储在内存中，Redis能够实现<code>微秒级</code>的读写速度。</li><li><strong>持久化</strong>：虽然数据主要<code>存储</code>在<code>内存</code>中，但Redis提供了数据<code>持久化</code>的功能，可以将内存中的数据定期保存到<code>磁盘</code>中，以防止<code>数据丢失</code>。</li><li><strong>支持丰富数据类型</strong>：除了基本的键值对存储，Redis还支持列表、集合、有序集合等多种数据结构，这使得它能够适应更多样的应用场景。</li><li><strong>原子性操作</strong>：Redis的所有操作都是<code>原子性</code>的，这意味着每一个操作都将完整地执行，不会被其他客户端的命令所干扰，确保了数据的一致性和完整性。</li></ul><h4 id="3-1-2-Redis和memcached区别（面试题）"><a href="#3-1-2-Redis和memcached区别（面试题）" class="headerlink" title="3.1.2 Redis和memcached区别（面试题）"></a>3.1.2 Redis和memcached区别（面试题）</h4><ul><li><strong>数据结构</strong>：Redis提供了更丰富的数据类型，包括<code>字符串</code>、<code>列表</code>、<code>集合</code>、<code>有序集合</code>和<code>散列</code>等，而Memcached主要支持简单的<code>键值对结构</code>。这使得Redis能够支持更复杂的数据操作，减少网络IO次数和数据体积。</li><li><strong>数据持久化</strong>：Memcached不支持数据<code>持久化</code>，服务器重启后数据会<code>丢失</code>，但这使得它在运行时拥有更高的性能。相比之下，Redis支持数据持久化到磁盘，提供了数据的恢复能力，但这也意味着它需要承担额外的<code>性能开销</code>。</li><li><strong>性能考虑</strong>：Memcached在存储大数据时性能更高，因为它的<code>内存管理</code>机制简单高效。而Redis虽然在处理大量数据时性能有所下降，但它提供了更多的<code>数据结构</code>和操作。</li><li><strong>应用场景</strong>：Memcached通常用于<code>缓存系统</code>中，以减轻数据库的读负载，适合<code>多读少写</code>的场景。而Redis不仅适用于缓存，还适用于对<code>读写效率</code>要求高、数据处理复杂和对<code>安全</code>性要求较高的系统。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2350b528a088429d972d2fdcfe6e18d3.jpeg" alt="img"></p><h2 id="4、安装Redis"><a href="#4、安装Redis" class="headerlink" title="4、安装Redis"></a>4、安装Redis</h2><h3 id="4-1-安装单机版redis"><a href="#4-1-安装单机版redis" class="headerlink" title="4.1  安装单机版redis"></a>4.1  安装单机版redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 下载redis安装包</span></span><br><span class="line">[root@redis-master ~]# wget https://download.redis.io/releases/redis-6.2.7.tar.gz   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 解压安装包到指定目录</span></span><br><span class="line">[root@redis-master ~]# tar xzf redis-6.2.7.tar.gz -C /usr/local/ &amp;&amp; cd /usr/local   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建软链接</span></span><br><span class="line">[root@localhost local]# ln -s redis-6.2.7 redis</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 切换redis家目录</span></span><br><span class="line">[root@localhost local]# cd redis/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装编译环境</span></span><br><span class="line">[root@redis-master redis]# yum install -y gcc make</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编译</span></span><br><span class="line">[root@redis-master redis]# make</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 备份文件</span></span><br><span class="line">[root@redis-master redis]# cp redis.conf redis.conf.bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-master redis]# vim redis.conf</span><br><span class="line">bind 192.168.246.202     # 只监听内网IP</span><br><span class="line">daemonize yes            # 开启后台模式将no改为yes</span><br><span class="line">port 6379                # 端口号</span><br><span class="line">dir /data/redis/data     # 本地数据库存放持久化数据的目录该目录需要存在创建存放数据的目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 配置systemctl的redis启动脚本</span></span><br><span class="line">[root@redis-master redis]# cat &gt;&gt; /lib/systemd/system/redis.service &lt;&lt;-EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/redis/src/redis-server /usr/local/redis/redis.conf  --daemonize no</span><br><span class="line">ExecStop=/usr/local/redis/src/redis-cli -h 127.0.0.1 -p 6379 shutdown</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">E</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 重新加载并且启动服务</span></span><br><span class="line">[root@redis-master system]# systemctl daemon-reload</span><br><span class="line">[root@redis-master system]# systemctl enable --now redis</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564302473951.png#id=m3S85&originHeight=202&originWidth=1195&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 登陆redis</span></span><br><span class="line">[root@redis-master system]# cd /usr/local/redis/src/</span><br><span class="line">[root@redis-master src]# ./redis-cli -h 192.168.246.202 -p 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 测试redis是否可以用</span></span><br><span class="line">192.168.246.202:6379&gt; ping    </span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 设置key--name，并设置值</span></span><br><span class="line">192.168.246.202:6379&gt; set name xiaoming    </span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 获取到key</span></span><br><span class="line">192.168.246.202:6379&gt; get name    </span><br><span class="line">"xiaoming"</span><br><span class="line"></span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">192.168.246.202:6379&gt; set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> EX seconds ： 将键的过期时间设置为 seconds 秒。默认为秒；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。默认为毫秒；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NX ： 只在键不存在时， 才对键进行设置操作。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> XX ： 只在键已经存在时， 才对键进行设置操作。会覆盖原有的values值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 使用 EX 选项：</span></span><br><span class="line">[root@localhost src]# ./redis-cli -h 192.168.62.231 -p 6379</span><br><span class="line">192.168.62.231:6379&gt; set name1 xiaohong EX 10</span><br><span class="line">OK</span><br><span class="line">192.168.62.231:6379&gt; get name1</span><br><span class="line">"xiaohong"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 等待10s，再次查看</span></span><br><span class="line">192.168.62.231:6379&gt; get name1</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 使用 PX 选项：</span></span><br><span class="line">192.168.62.231:6379&gt; set name2 xiaohong PX 3233</span><br><span class="line">OK</span><br><span class="line">192.168.62.231:6379&gt; get name2</span><br><span class="line">"xiaohong"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 等待3s，再次查看</span></span><br><span class="line">192.168.62.231:6379&gt; get name2</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt;  NX 选项：</span></span><br><span class="line">192.168.62.231:6379&gt; set class 2204 NX</span><br><span class="line">OK # 键不存在，设置成功</span><br><span class="line">192.168.62.231:6379&gt; get class</span><br><span class="line">"2204"</span><br><span class="line">192.168.62.231:6379&gt; set class 2205 NX</span><br><span class="line">(nil)  # 键已经存在，设置失败</span><br><span class="line">192.168.62.231:6379&gt; get class</span><br><span class="line">"2204"  # 维持原值不变</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; XX 选项：</span></span><br><span class="line">192.168.62.231:6379&gt; set home taikang XX</span><br><span class="line">(nil)  # 因为键不存在，设置失败</span><br><span class="line">192.168.62.231:6379&gt; set home taikang</span><br><span class="line">OK # 先给键设置一个值</span><br><span class="line">192.168.62.231:6379&gt; set home zhengzhou XX</span><br><span class="line">OK # 设置新值成功</span><br><span class="line">192.168.62.231:6379&gt; get home</span><br><span class="line">"zhengzhou"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 删除key</span></span><br><span class="line">192.168.62.231:6379&gt; del class</span><br><span class="line">(integer) 1</span><br><span class="line">192.168.62.231:6379&gt; get class</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 切换数据库</span></span><br><span class="line">127.0.0.1:6379[1]&gt; SELECT 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看当前库所有的数据</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br></pre></td></tr></table></figure><h3 id="4-2-redis的相关工具"><a href="#4-2-redis的相关工具" class="headerlink" title="4.2  redis的相关工具"></a><strong>4.2  redis的相关工具</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli           # redis的客户端</span><br><span class="line">./redis-server        # redis的服务端</span><br><span class="line">./redis-check-aof     # 用于修复出问题的AOF文件</span><br><span class="line">./redis-sentinel      # 用于集群管理</span><br></pre></td></tr></table></figure><h2 id="5、Redis设置密码的两种方式"><a href="#5、Redis设置密码的两种方式" class="headerlink" title="5、Redis设置密码的两种方式"></a>5、Redis设置密码的两种方式</h2><p>Redis修改密码的方式主要有两种：使用<code>redis-cli</code>命令行工具和通过配置文件。</p><h3 id="5-1-命令行临时修改密码"><a href="#5-1-命令行临时修改密码" class="headerlink" title="5.1 命令行临时修改密码"></a><strong>5.1 命令行临时修改密码</strong></h3><ol><li><strong>登录Redis</strong>：首先，你需要使用当前没有密码的Redis客户端登录到Redis服务器。</li><li><strong>设置新密码</strong>：使用<code>CONFIG SET</code>命令来设置新的密码。例如，要设置密码为<code>qfyyds</code>，你可以执行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET requirepass <span class="string">"qfyyds"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 密码使用方式</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 方式一：</span></span><br><span class="line">192.168.174.48:6379&gt; AUTH qfyyds</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 方式二：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># redis-cli  -h 192.168.174.48  -p 6379 -a qfyyds</span></span><br></pre></td></tr></table></figure><blockquote><p> 注意：这种方式设置的密码只会<code>临时生效</code>，重启Redis服务后密码会失效。</p></blockquote><h3 id="5-2-配置文件永久修改密码"><a href="#5-2-配置文件永久修改密码" class="headerlink" title="5.2 配置文件永久修改密码"></a><strong>5.2 配置文件永久修改密码</strong></h3><ol><li><strong>找到Redis配置文件</strong>：通常，Redis的配置文件名为<code>redis.conf</code>，它位于Redis安装目录或数据目录中。</li><li><strong>编辑配置文件</strong>：编辑<code>redis.conf</code>。</li><li><strong>设置密码</strong>：在配置文件中找到<code># requirepass foobared</code>这一行（没有<code>#</code>注释符号），将<code>foobared</code>替换为你想要设置的新密码。例如，设置为<code>afyyds</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># vim redis.conf</span></span><br><span class="line">···</span><br><span class="line">requirepass qfyyds</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重启服务</span></span><br><span class="line">[root@localhost redis]<span class="comment"># systemctl restart redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 查看服务状态</span></span><br><span class="line">[root@localhost redis]<span class="comment"># systemctl status redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 测试</span></span><br><span class="line">[root@localhost src]<span class="comment"># ./redis-cli </span></span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth qfyyds</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line"><span class="string">"zhangsan"</span></span><br></pre></td></tr></table></figure><p><strong>保存并重启Redis</strong>：保存配置文件并重启Redis服务，新的密码设置就会生效。</p><blockquote><p>注意事项：在修改密码后，确保所有客户端都已更新为使用新密码进行<code>连接</code>，否则可能会出现认证失败的问题。</p></blockquote><hr><h3 id="5-3-Redis配置文件详解"><a href="#5-3-Redis配置文件详解" class="headerlink" title="5.3 Redis配置文件详解"></a>5.3 Redis配置文件详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># egrep -v "^#|^$" redis.conf</span></span><br><span class="line"><span class="comment"># 设置Redis服务器监听所有IP地址，即允许任何客户端连接。</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 关闭保护模式，允许非本机客户端连接。</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 设置Redis服务器监听的端口号为6379。</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 设置TCP连接队列的大小为511，即允许最多有511个连接等待被处理。</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"><span class="comment"># 设置超时时间</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="comment"># 设置TCP心跳间隔为300秒。</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"><span class="comment"># 以守护进程方式运行Redis服务器。</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 指定Redis服务器的进程ID文件路径。</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"><span class="comment"># 设置日志级别为notice，只记录警告和错误信息。</span></span><br><span class="line">loglevel notice</span><br><span class="line"><span class="comment"># 指定日志文件的路径。</span></span><br><span class="line">logfile <span class="string">"/var/log/redis.log"</span></span><br><span class="line"><span class="comment"># 设置Redis支持的数据库数量为16个。</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="comment"># 在后台保存出错时停止写入操作。</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="comment"># rdbcompression yes：启用RDB文件压缩。</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment"># 在RDB文件中包含CRC64校验和</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="comment"># 指定RDB文件的名称。</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># 不删除同步生成的RDB文件。</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"><span class="comment"># 指定RDB文件和AOF文件的存储目录。</span></span><br><span class="line">dir /data/redis/data</span><br><span class="line"><span class="comment"># 设置副本节点为只读模式。</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"><span class="comment"># 设置密码为"qfyyds"，用于验证客户端连接。</span></span><br><span class="line">requirepass qfyyds</span><br><span class="line"><span class="comment"># 禁用AOF持久化。</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># 指定AOF文件的名称。</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"><span class="comment"># 每秒执行一次fsync操作，将缓冲区的数据写入磁盘。</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><h2 id="6、数据持久化"><a href="#6、数据持久化" class="headerlink" title="6、数据持久化"></a>6、数据持久化</h2><p>Redis是一个内存数据库，一旦断电或服务器进程退出，内存数据库中的数据将<code>全部丢失</code>，所以需要redis持久化；Redis持久化就是把<code>数据保存在磁盘上</code>，利用<code>永久性存储介质</code>将数据保存，在特定的时间将保存的数据进行恢复的工作机制。</p><h3 id="6-1-redis持久化-–-两种方式"><a href="#6-1-redis持久化-–-两种方式" class="headerlink" title="6.1 redis持久化 – 两种方式"></a><strong>6.1 redis持久化 – 两种方式</strong></h3><h4 id="6-1-1-RDB"><a href="#6-1-1-RDB" class="headerlink" title="6.1.1  RDB"></a>6.1.1  RDB</h4><p>​    在指定的时间间隔内将内存中的数据集写入磁盘，也就是<code>快照</code>(Snapshot),数据恢复是将快照文件直接读到<code>内存中</code>redis会单独创建(<code>fork</code>)一个<code>子进程</code>来进行<code>持久化</code>，会先将数据写入一个到一个<code>临时文件</code>(dump.rdb)中,待持久化过程结束后，再用本次的临时文件替换上次持久化后的文件。</p><p><code>fork函数</code>的作用是复制一个与当前进程一样的进程，新进程的所有数据数值都和原进程一致，但是一个全新的进程，并作为<code>原进程的子进程</code>。</p><p>redis服务器在处理<code>bgsave</code>采用<code>子线程</code>进行IO写入，而主进程仍然可以接收其他请求，但创建子进程是同步阻塞的，此时不接受其他请求。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2231965-20221006153432205-771654931.png" alt="img"></p><blockquote><p><code>save</code>: 该命令会阻塞当前redis服务器，执行save命令期间，redis不能处理其他命令，直到RDB过程结束为止(会造成长时间阻塞，不建议使用)</p><p> <code>bgsave</code>:该命令执行后，redis会在后台异步进行快照操作，快照同时还可以响应客户端的请求，阻塞只发生在fork阶段，基本上redis内部的所有RDB操作都是采用bgsave命令。</p></blockquote><h5 id="1-RDB持久化配置"><a href="#1-RDB持久化配置" class="headerlink" title="1.  RDB持久化配置"></a>1.  RDB持久化配置</h5><p>​    RDB持久化默认开启，但是需要配置触发规则。如下列代码所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@redis-master redis]<span class="comment"># vim /usr/local/redis/redis.conf</span></span><br><span class="line">···</span><br><span class="line"><span class="comment"># dbfilename：持久化数据存储在本地的文件</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir：持久化数据存储在本地的路径,可自定义</span></span><br><span class="line">dir /data/redis/data</span><br><span class="line"></span><br><span class="line"><span class="comment">##snapshot触发的时机，save &lt;seconds&gt; &lt;changes&gt; </span></span><br><span class="line"><span class="comment">##对于此值的设置，需要谨慎，评估系统的变更操作密集程度  </span></span><br><span class="line"><span class="comment">##可以通过save “”来关闭snapshot功能  </span></span><br><span class="line"><span class="comment"># 900秒内如果至少有一个key进行了修改则进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 300秒内如果至少有10个key进行了修改则进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 60秒内，如果至少有10000个key进行了修改则进行持久化操作</span></span><br><span class="line">save 60 10000 </span><br><span class="line"></span><br><span class="line"><span class="comment">##yes代表当使用bgsave命令持久化出错时候停止写RDB快照文件,no表明忽略错误继续写文件，“错误”可能因为磁盘已满/磁盘故障/OS级别异常等</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment">##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，同时也意味着较短的网络传输时间  </span></span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><h5 id="2-RDB持久化数据恢复"><a href="#2-RDB持久化数据恢复" class="headerlink" title="2. RDB持久化数据恢复"></a>2. RDB持久化数据恢复</h5><p>​    将备份文件(dump.rdb)移动到redis路径下(可以配置文件的存放路径)启动服务即可，redis启动会将文件数据加载到内存，在此期间redis会处于阻塞状态，直到全部数据存入内存。</p><h5 id="3-RDB持久化的优缺点"><a href="#3-RDB持久化的优缺点" class="headerlink" title="3. RDB持久化的优缺点"></a>3. RDB持久化的优缺点</h5><ul><li><p>优点：</p><ul><li><p>数据恢复快；</p></li><li><p>体积小；</p></li><li><p>数据备份使用子进程，对redis服务性能影响小。</p></li></ul></li><li><p>缺点：</p><ul><li>在一定时间间隔进行备份，当redis意外宕机，将会丢失最后一次修改的数据，无法做到秒级持久化；</li><li>fork进程时，会占用一定的内存空间；</li><li>RDB文件是二进制的没有可读性。</li></ul></li></ul><h4 id="6-1-2-AOF"><a href="#6-1-2-AOF" class="headerlink" title="6.1.2 AOF"></a>6.1.2 AOF</h4><p>​    将客户端的每一个<strong>写操作命令</strong>以日志的形式记录下来，追加到<code>appendonly.aof</code>的文件末尾，在redis服务器重启时，会加载aof文件中的所有命令，来达到数据恢复的目的。</p><p>当有写命令请求时，会追加到AOF缓冲区内，AOF缓冲区根据AOF持久化策略[<code>always</code>,<code>everysec</code>,<code>no</code>]将操作同步到磁盘的AOF文件中，当AOF文件大小超过重写策略或手动重写时，会对AOF文件进行重写来压缩AOF文件容量，redis服务重启时，会重新加载AOF文件中的写操作来进行数据恢复。</p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2231965-20221006153451739-1327556975.png" alt="img"><h5 id="1-AOF持久化策略"><a href="#1-AOF持久化策略" class="headerlink" title="1. AOF持久化策略"></a>1. AOF持久化策略</h5><ul><li><code>always</code>: 把每个写命令立即同步到AOF文件，很慢但安全；</li><li><code>everysec</code>: 每秒同步一次，默认配置；</li><li><code>no</code>: redis不执行写入磁盘。</li></ul><h5 id="2-AOF的触发方式"><a href="#2-AOF的触发方式" class="headerlink" title="2. AOF的触发方式"></a>2. AOF的触发方式</h5><ol><li>手动触发<code>bgrewriteaof</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGREWRITEAOF</span><br><span class="line">Background append only file rewriting started</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost data]<span class="comment"># stat appendonly.aof </span></span><br><span class="line">  文件：<span class="string">"appendonly.aof"</span></span><br><span class="line">  大小：112       块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fd00h/64768dInode：17874728    硬链接：1</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">最近访问：2024-05-14 22:03:51.707774066 +0800</span><br><span class="line">最近更改：2024-05-14 22:03:51.707774066 +0800</span><br><span class="line">最近改动：2024-05-14 22:03:51.818774763 +0800</span><br></pre></td></tr></table></figure><p><strong>默认情况，redis是没有开启AOF(默认使用RDB持久化)，需要通过配置文件开启。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 是否开启 Redis AOF持久化，默认为no</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; AOF持久化文件名</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; AOF持久化策略，默认为eveysec，每秒同步一次</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><ul><li><strong>Always</strong>：每次执行<code>写入操作</code>后，都会立即调用fsync将数据<code>同步到磁盘</code>。这确保了极高的数据<code>持久性</code>，因为即使在系统崩溃的情况下，也最多只会丢失一次写入操作的数据。然而，这种模式会对性能产生较大影响，因为在每次写入后都进行fsync会导致较高的I/O开销。</li><li><strong>Everysec</strong>：这是默认设置，<code>每秒</code>执行一次fsync。它在性能和持久性之间取得了平衡，既保证了较好的数据安全性，又避免了频繁的I/O操作对性能的影响。</li><li><strong>No</strong>：不做持久化</li></ul><h5 id="3-AOF的重写机制"><a href="#3-AOF的重写机制" class="headerlink" title="3. AOF的重写机制"></a>3. AOF的重写机制</h5><p>​    AOF持久化，会把每次写命令都<code>追加</code>到<code>appendonly.aof</code>文件中，当文件过大，redis的数据恢复时间就会变长，因此加入重写策略对aof文件进行重写，生成一个恢复当前数据的最少命令集。<code>通过压缩AOF文件里面的相同指令保留最新的一个数据操作指令，即将存储了某个key的多次变更记录。只是存储最新的变更记录即可，丢弃历史变更记录 。</code></p><p>​        <img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/2231965-20221006153525610-1156564768.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis 重写机制配置</span></span><br><span class="line">[root@localhost redis]<span class="comment">#  vim redis.conf</span></span><br><span class="line">···</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">···</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>auto-aof-rewrite-percentage</strong>：当前 AOF 文件大小超过上次重写后 AOF 文件大小的百分比时，触发 AOF 重写机制<strong>，默认值为 100 。</strong></li><li><strong>auto-aof-rewrite-min-size</strong>：表示当当前 AOF 文件大小超过指定值时，才可能触发 AOF 重写机制，<strong>默认值为 64 MB 。</strong></li></ol><ul><li>系统自动触发 AOF 重写机制还需要满足以下条件 ：<ul><li><code>当前没有正在执行 BGSAVE 或 BGREWRITEAOF 的子进程</code></li><li><code>当前没有正在执行 SAVE 的主进程</code></li><li><code>当前没有正在进行集群切换或故障转移</code></li></ul></li></ul></blockquote><h6 id="3-1-Redis-AOF-重写机制原理"><a href="#3-1-Redis-AOF-重写机制原理" class="headerlink" title="3.1 Redis AOF 重写机制原理"></a>3.1 Redis AOF 重写机制原理</h6><p>Redis AOF（Append Only File）重写流程是一个<code>用于优化</code>和<code>压缩AOF文件</code>的过程，以减少存储空间和提高写入效率。以下是AOF重写的流程：</p><ol><li><p>触发条件：当满足一定条件时，Redis会自动触发AOF重写。常见的触发条件包括<code>文件大小超过阈值</code>、系统负载较低等。</p></li><li><p>创建子进程：<code>Redis启动一个子进程进行AOF重写操作。这个子进程与主进程并行运行，不会阻塞主进程的处理</code>。</p></li><li><p>遍历数据库：<code>子进程开始遍历Redis数据库中的所有键值对</code>。这个过程中，子进程会记录下每个键值对的操作命令，但不会执行这些命令。</p></li><li><p>生成重写缓冲区：在遍历数据库的过程中，<code>子进程会将记录的操作命令写入一个临时文件，即重写缓冲区。这个临时文件最终会成为新的AOF文件。</code></p></li><li><p>同步命令到主进程：<code>在重写过程中，子进程会将部分命令同步回主进程，以确保主进程和子进程的数据一致性。</code>这是通过Redis的内部机制实现的，确保在重写过程中主进程的数据不会被破坏。</p></li><li><p>重写AOF文件：当子进程遍历完整个数据库并生成重写缓冲区后，它会根据一定的规则对缓冲区中的命令进行优化和压缩，生成新的AOF文件。这个<code>新文件会替换原有的AOF文件，具有更小的体积和更高的写入效率</code>。</p></li><li><p>更新配置：<code>一旦新的AOF文件生成并替换原有的文件，Redis会更新其配置信息，将新的AOF文件名写入配置文件中。</code>这样，在下次启动时，Redis就会使用新的AOF文件作为持久化存储。</p></li><li><p><strong>AOF重写机制带来优点</strong></p></li></ol><p>通过AOF重写流程，Redis可以有效地优化和压缩AOF文件，减少存储空间的使用，并提高写入效率。同时，由于重写过程是在子进程中进行的，不会阻塞主进程的处理，因此对Redis的性能影响较小。</p><p><strong>白话文解释：</strong></p><ul><li>旧AOF文件过大触发重写机制</li><li>创建子进程构建一个新的aof文件</li><li>子进程读取当前redis里面的数据，写入到新的aof文件里面</li><li>读取redis数据期间，主进程如果有其他新的操作指令则写入重写缓存中</li><li>重写完成以后，将重写缓存追加到新的aof文件中</li><li>用新的aof文件覆盖现有的aof文件 </li></ul><h5 id="4-AOF的优点和缺点"><a href="#4-AOF的优点和缺点" class="headerlink" title="4. AOF的优点和缺点"></a>4. AOF的优点和缺点</h5><p>​    优点：</p><ul><li><p>数据安全性高，不易丢数据；</p></li><li><p>AOF文件有序保存了所有写操作，可读性强。</p><p>缺点：</p></li><li><p>AOF方式生成文件体积大；</p></li><li><p>数据恢复速度比RDB慢。</p></li></ul><p>持久化配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3、AOF默认关闭--开启</span><br><span class="line">[root@redis-master src]# cd ..</span><br><span class="line">[root@redis-master redis]# vim redis.conf</span><br><span class="line">修改如下:</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564304309935.png#id=WCMEC&originHeight=149&originWidth=362&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能,只有在“yes”下，aof重写/文件同步等特性才会生效</span><br><span class="line">====================================</span><br><span class="line">2、指定aof文件名称</span><br><span class="line">appendfilename appendonly.aof  </span><br><span class="line">====================================</span><br><span class="line">3、指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec</span><br><span class="line">appendfsync everysec</span><br><span class="line">always     #每次有数据修改发生时都会写入AOF文件</span><br><span class="line">everysec   #每秒钟同步一次，该策略为AOF的缺省策略/默认策略</span><br><span class="line">no         #从不同步。高效但是数据不会被持久化</span><br></pre></td></tr></table></figure><p><strong>开启持久化功能后，重启redis后，数据会自动通过持久化文件恢复。<code>RDB是默认持久化方式，但 Redis 允许 RDB 与 AOF 两种持久化技术同时开启。不过如果同时存在两种持久化方式，会默认采取AOF的方式，AOF持久化方式的优先级更高。</code></strong></p><p><strong>拓展RDB快照备份恢复：</strong></p><p>redis数据库备份与恢复（dump.rdb快照方式），两台机器</p><p><strong>备份Redis实例配置</strong></p><ol><li><strong>备份redis实例操作</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 备份机器的redis.conf配置文件内容</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim  /usr/local/redis/redis.conf </span></span><br><span class="line">···</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /data/redis/data</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ./src/redis-cli </span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zhangsan</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BGSAVE </span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls /data/redis/data</span></span><br><span class="line">dump.rdb</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># scp /data/redis/data/dump.rdb 192.168.174.49:/data/redis/data/</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>恢复Redis实例配置</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 配置文件修改</span></span><br><span class="line">[root@redis-backup ~]<span class="comment"># vim /usr/local/redis/redis.conf </span></span><br><span class="line">···</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /data/redis/data/</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">daemonize yes</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;启动实例</span></span><br><span class="line">[root@redis-backup ~]<span class="comment"># cd /usr/local/redis/src/</span></span><br><span class="line">[root@redis-backup redis]<span class="comment"># ./src/redis-server redis.conf </span></span><br><span class="line">[root@redis-backup redis]<span class="comment"># ./src/redis-cli </span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br></pre></td></tr></table></figure><h2 id="7、Redis主从配置"><a href="#7、Redis主从配置" class="headerlink" title="7、Redis主从配置"></a>7、Redis主从配置</h2><h3 id="7-1-主从简介"><a href="#7-1-主从简介" class="headerlink" title="7.1 主从简介"></a>7.1 主从简介</h3><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240418113140326.png" alt="image-20240418113140326" style="zoom:50%;"><p>持久化技术只是解决了Redis服务故障之后，快速数据恢复的问题。宕机和数据恢复的过程中整个业务系统来说，还是有损失的，并没有根本上提升可用性问题，而且持久化技术对于Redis服务性能来说是有损的。我们需要的是保障<code>Redis的高可用</code>，减少甚至避免Redis服务<code>发生宕机</code>的可能。</p><p>目前实现Redis高可用的模式主要有三种： <code>主从模式</code>、<code>哨兵模式</code>、<code>集群模式</code>。我们先来聊一下主从模式。<br>Redis 提供的主从模式，是通过复制的方式，将主服务器上的Redis的数据同步复制一份到从 Redis 服务器，这种做法很常见，MySQL通过binlog进行的主从复制也是这么做的。<br>主节点的Redis我们称之为master，从节点的Redis我们称之为slave，<code>主从复制为单向复制，只能由主到从，不能由从到主。</code>可以有多个从节点，比如1主3从甚至n从，从节点的多少根据实际的业务需求来判断。</p><p>主从结构，一是为了纯粹的<code>冗余备份</code>，二是为了<code>提升读性能</code>，比如很消耗性能的操作就可以由从服务器来处理。<br>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。<br><strong><code>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</code></strong></p><h3 id="7-2-主从复制的意义"><a href="#7-2-主从复制的意义" class="headerlink" title="7.2 主从复制的意义"></a>7.2 主从复制的意义</h3><ul><li><p><strong>故障隔离和恢复</strong></p><p>无论主节点或者从节点<code>宕机</code>，其他节点依然可以保证服务的正常运行，并可以手动或自动切换主从。</p><ul><li>如果Slave库故障，则读写操作全部走到Master库中</li><li>如果Master库故障，则将Slave转成Master库，仅丢失Master库来不及同步到Slave的小部分数据</li></ul></li><li><p><strong>读写隔离</strong>：Master 节点提供写服务，Slave 节点提供读服务，分摊流量压力，均衡流量的负载。</p></li><li><p><strong>提供高可用保障</strong>：主从模式是高可用的最基础版本，也是 <code>sentinel 哨兵模式</code>和<code>cluster 集群模式</code>实施的前置条件。</p></li></ul><h3 id="7-3-主从同步原理偏移"><a href="#7-3-主从同步原理偏移" class="headerlink" title="7.3 主从同步原理偏移"></a><strong>7.3 主从同步原理</strong>偏移</h3><ol><li>从服务器会向主服务器发出<code>SYNC指令</code>；</li><li>当主服务器接到此命令后，就会调用<code>BGSAVE</code>指令来<code>fork</code>一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入<code>RDB文件</code>中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中；</li><li>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，</li><li>从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。</li><li>这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</li></ol><p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个从服务器。</p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240418113526905.png" alt="image-20240418113526905" style="zoom: 200%;"><p>2.8版本之后，redis支持了效率更高的<code>增量同步策略</code>，这大大降低了连接断开的恢复成本。主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，主服务器就会向从服务器发送增量内容。增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。<img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240418114706094.png" alt="image-20240418114706094" style="zoom:67%;"></p><p><code>扩展内容</code>：</p><p><strong>1. 首次配置完成主从库之后的全量复制</strong>：在从库第一次连接到主库时，将采用psync复制方式进行全量复制。 这意味着从库会从头开始复制主库中的全部数据。<br><strong>2. 主从正常运行期间，准实时同步</strong>：在正常运行状态下，从库通过读取主库的<code>缓冲区来</code>进行增量复制。 这个过程涉及复制主库上发生的新的数据变更。<br><strong>3. 从库第二次启动（异常或主从网络断开后恢复）</strong>： Append增量数据 + 准实时同步将通过读取主库的缓冲区进行部分复制。 这种方式能够快速同步中断期间发生的数据变更，而不会对主库造成重大影响。</p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/167509-20240327210817418-1726205885.png" alt="image" style="zoom: 50%;"><p><code>PSYNC</code> 命令是Redis中用于从节点与主节点之间数据同步的关键命令。它的工作原理包括以下几个步骤：</p><p><strong>1. 启动或重连判断：</strong><br>当从节点（Slave）启动或与主节点（Master）的连接断开后重连时，从节点需要确定是否曾经同步过。如果从节点没有保存任何主节点的运行ID（runid），它将视为第一次连接到主节点。</p><p><strong>2. 首次同步处理：</strong><br>如果是第一次同步的情况下，从节点会发送 <code>PSYNC -1</code> 命令给主节点，代表请求全量数据同步。 全量同步是指主节点将其所有数据完整地<code>Copy</code>一份给从节点。</p><p><strong>3. 主从重连后的处理：</strong><br>对于之前已经同步过的从节点，它会发送 <code>PSYNC runid offset</code> 命令，其中runid是主节点的唯一标识符，offset是从节点上次同步数据的偏移量。这样本质就是增量同步。</p><p><strong>4. 主节点响应：</strong><br>主节点接收到PSYNC命令后，会检查runid是否匹配，以及offset是否在复制积压缓冲区的范围内。如果匹配且offset有效，主节点将回复<code>CONTINUE</code>，并发送自从节点上次断开连接以来的所有写命令。</p><p><strong>5. 触发全量同步的条件：</strong><br>如果runid不匹配，或offset超出了积压缓冲区的范围，主节点将通知从节点执行全量同步，回复<code>FULLRESYNC runid offset</code>。</p><p><strong>6. 积压缓冲区的作用：</strong><br>主节点会在处理写命令的同时，将这些命令存入复制积压队列（缓冲池），同时记录队列中存放命令的全局offset。<br>这样做法是保证了效率。当从节点断线重连，且条件允许时（runid和offset都具备），它可以通过offset从积压队列中进行增量复制，而不是全量复制，这样复制的成本就低很多。</p><p><strong>7. 保障数据一致性：</strong><br>PSYNC机制允许从节点在网络不稳定或其他意外断开连接的情况下，能够以增量方式重新同步数据。这也是它的一大优势，那就是保持主从节点数据的一致性。</p><p><strong>8. 什么时候启动重连工作</strong><br>判断是否进行全量同步，需要考虑两个关键因素：首先，确认这是否是第一次进行数据同步；其次，检查缓存区是否已经达到或超过其容量上限。只有在是第一次同步，或者缓存区已溢出的情况下，才会执行全量同步。</p><h3 id="7-4-1主n从的同步说明"><a href="#7-4-1主n从的同步说明" class="headerlink" title="7.4 1主n从的同步说明"></a>7.4 1主n从的同步说明</h3><p>如果你有多个从库，则在每次连接的时候需要注意一些细节，如下:</p><ul><li><p>多个从库情况下，每个从库都会记录自己的 <code>slave_repl_offset</code>，各自复制的进度也不相同。</p></li><li><p>重连主库进行恢复时，从库会通过<code>psync</code>命令将 slave_repl_offset 告知主库，主库判断从库的状态，来决定进行增量复制，还是全量复制。</p></li><li><p>replication buffer(复制缓冲区) 和 repl_backlog 的说明</p><ul><li><code>replication buffer</code>： 与每个从节点（slave）相关联的缓冲区，存在于主节点（master）上。当主从连接稳定时，主节点会将其接收到的所有写命令放入这个缓冲区中，并异步地发送给从节点。这样，从节点就可以通过执行这些写命令来更新自己的数据集。可以通过<code>client-output-buffer-limit</code>配置来设定其大小限制，以防止因从节点处理速度慢而导致主节点内存溢出。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405102015164.webp" alt></p><ul><li><code>repl_backlog_buffer</code>：是为了解决从库断连后找不到主从差异数据而设立的环形缓冲区，从而避免全量同步带来的性能开销。在redis.conf配置文件中可以设置大小，如果从库断开时间过长，repl_backlog_buffer<code>环形缓冲区</code>会被主库的写命令覆盖，那么从库重连后只能全量同步，所以repl_backlog_size配置尽量大一点可以降低从库连接后全量同步的频率。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405102014054.webp" alt></p></li><li><p>主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，需要将自己的复制进度（slave_repl_offset）发给主库，主库才可以按照偏移量取数据跟它同步。</p></li></ul><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240422111235791.png" alt="image-20240422111235791" style="zoom: 33%;"><h3 id="7-5-部署三台机器Redis—主从同步"><a href="#7-5-部署三台机器Redis—主从同步" class="headerlink" title="7.5 部署三台机器Redis—主从同步"></a>7.5 部署三台机器Redis—主从同步</h3><ol><li><strong>集群环境准备</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 三台服务器关闭防火墙</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">disable</span> --now firewalld &amp;&amp; setenforce 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 三台服务器添加本地解析</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &gt;&gt; /etc/hosts &lt;&lt;-EOF</span></span><br><span class="line">redis-master192.168.174.38</span><br><span class="line">redis-slave-1192.168.174.39</span><br><span class="line">redis-slave-2192.168.174.40</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol start="2"><li><strong><code>redis-master</code>节点配置</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-master ~]# vim /usr/local/redis/redis.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置Redis监听的IP地址和端口号，默认监听所有IP地址和6379端口</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭保护模式，允许远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定Redis监听的端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加Redis的最大内存限制，以容纳更多数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash">maxmemory 16GB   增加内存限制，根据您的服务器实际内存调整</span></span><br><span class="line">maxmemory 20480mb</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动主节点redis服务</span></span><br><span class="line">[root@redis-master ~]# cd /usr/local/redis/src</span><br><span class="line">[root@redis-master src]# ./redis-server ../redis.conf &amp;   会加载此文件中的配置信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看端口</span></span><br><span class="line">[root@redis-master src]# ss -tunlp | grep  6379</span><br><span class="line">tcp    LISTEN     0      128       *:6379                  *:*                   users:(("redis-server",pid=1360,fd=6))</span><br></pre></td></tr></table></figure><blockquote><p> 关闭protected-mode模式，此时外部网络可以直接访问</p><p>开启protected-mode保护模式，需配置bind ip或者设置访问密码</p></blockquote><ol start="3"><li><strong><code>redis-slave01</code>配置</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-slave01 ~]# vim /usr/local/redis/redis.conf</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置Redis监听的IP地址和端口号，默认监听所有IP地址和6379端口</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要同步的主库信息</span></span><br><span class="line">replicaof 192.168.174.39 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭保护模式，允许远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义数据目录</span></span><br><span class="line">dir /data/redis</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动redis服务</span></span><br><span class="line">[root@redis-slave-1 ~]# cd /usr/local/redis/src/</span><br><span class="line">[root@redis-slave-1 src]# ./redis-server ../redis.conf &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看端口</span></span><br><span class="line">[root@redis-slave01 src]# ss -tunlp | grep  6379</span><br><span class="line">tcp    LISTEN     0      128       *:6379                  *:*                   users:(("redis-server",pid=1360,fd=6))</span><br></pre></td></tr></table></figure><blockquote><p>可以通过 <code>replicaof（Redis 5.0 之前使用 slaveof）</code>命令形成主库和从库的关系。</p></blockquote><ol start="4"><li><strong><code>redis-slave02</code>配置</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@redis-slave01 ~]# vim /usr/local/redis/redis.conf</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置Redis监听的IP地址和端口号，默认监听所有IP地址和6379端口</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加需要同步的主库信息</span></span><br><span class="line">replicaof 192.168.174.48 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭保护模式，允许远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义数据目录</span></span><br><span class="line">dir /data/redis</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动redis服务</span></span><br><span class="line">[root@redis-slave-1 ~]# cd /usr/local/redis/src/</span><br><span class="line">[root@redis-slave-1 src]# ./redis-server ../redis.conf &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看端口</span></span><br><span class="line">[root@redis-slave01 src]# ss -tunlp | grep  6379</span><br><span class="line">tcp    LISTEN     0      128       *:6379                  *:*                   users:(("redis-server",pid=1360,fd=6))</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>测试主从复制</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; redis-master执行</span></span><br><span class="line">[root@redis-master redis]# cd src/</span><br><span class="line">[root@redis-master src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; set name jack</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"jack"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 分别在slave-1和slave-2上面执行</span></span><br><span class="line">[root@redis-slave01 redis]# cd src/</span><br><span class="line">[root@redis-slave01 src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"jack"</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">[root@redis-slave-2 src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"jack"</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; redis-master查看复制状态</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.246.203,port=6379,state=online,offset=490,lag=0</span><br><span class="line">slave1:ip=192.168.246.204,port=6379,state=online,offset=490,lag=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; redis-slave执行</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.246.202</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br></pre></td></tr></table></figure><p><strong>注意：从服务器一般默认禁止写入操作：<code>slave-read-only yes</code></strong></p><p><code>redis-master</code>执行<code>info repliaction</code>参数解释</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408132333247.png" alt="image-20240813233259506"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示当前节点的角色是主节点</span></span><br><span class="line">role:master</span><br><span class="line"><span class="comment"># 表示当前主节点连接了两个从节点。</span></span><br><span class="line">connected_slaves:2</span><br><span class="line"><span class="comment"># 表示第一个从节点的IP地址为192.168.174.49，端口号为6379，状态为在线（online），复制偏移量为3276，与主节点的延迟为1。</span></span><br><span class="line">slave0:ip=192.168.174.49,port=6379,state=online,offset=3276,lag=1</span><br><span class="line"><span class="comment"># 表示第二个从节点的IP地址为192.168.174.50，端口号为6379，状态为在线（online），复制偏移量为3276，与主节点的延迟为1。</span></span><br><span class="line">slave1:ip=192.168.174.50,port=6379,state=online,offset=3276,lag=1</span><br><span class="line"><span class="comment"># 表示当前没有进行故障转移。</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line"><span class="comment"># 表示主节点的复制ID。</span></span><br><span class="line">master_replid:169726e22cc9736afd05f50b7fef4d8b6e48b47a</span><br><span class="line"><span class="comment"># 表示主节点的第二个复制ID，这里为全零。</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line"><span class="comment"># 表示主节点当前的复制偏移量。</span></span><br><span class="line">master_repl_offset:3276</span><br><span class="line"><span class="comment"># 表示第二个从节点的复制偏移量，这里为-1，表示没有设置。</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区是否处于活动状态，1表示活动。</span></span><br><span class="line">repl_backlog_active:1</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区的大小，单位为字节。</span></span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区中第一个字节的偏移量。</span></span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line"><span class="comment"># 表示复制积压缓冲区的历史长度。</span></span><br><span class="line">repl_backlog_histlen:3276</span><br></pre></td></tr></table></figure><p><code>redis-slave</code>执行<code>info replication</code>参数解释</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408132336143.png" alt="image-20240813233652087"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> slave 节点执行 info replication 命令回显参数解释</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前节点的角色是从节点。</span></span><br><span class="line">role:slave</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的IP地址为192.168.174.48。</span></span><br><span class="line">master_host:192.168.174.48</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的端口号为6379。</span></span><br><span class="line">master_port:6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示与主节点的连接状态为正常（up）。</span></span><br><span class="line">master_link_status:up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示距离上一次与主节点进行IO操作的时间过去了8秒。</span></span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前没有正在进行的主从同步操作。</span></span><br><span class="line">master_sync_in_progress:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点读取复制数据时的偏移量。</span></span><br><span class="line">slave_read_repl_offset:3794</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点当前的复制偏移量。</span></span><br><span class="line">slave_repl_offset:3794</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点的优先级为100。</span></span><br><span class="line">slave_priority:100</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点以只读模式运行。</span></span><br><span class="line">slave_read_only:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示从节点已经向其他节点宣告自己是复制节点。</span></span><br><span class="line">replica_announced:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前从节点没有连接其他从节点。</span></span><br><span class="line">connected_slaves:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前没有进行故障转移。</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的复制ID。</span></span><br><span class="line">master_replid:169726e22cc9736afd05f50b7fef4d8b6e48b47a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点的第二个复制ID，这里为全零。</span></span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示主节点当前的复制偏移量。</span></span><br><span class="line">master_repl_offset:3794</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示第二个从节点的复制偏移量，这里为-1，表示没有设置。</span></span><br><span class="line">second_repl_offset:-1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区是否处于活动状态，1表示活动。</span></span><br><span class="line">repl_backlog_active:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区的大小，单位为字节。</span></span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区中第一个字节的偏移量。</span></span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示复制积压缓冲区的历史长度。</span></span><br><span class="line">repl_backlog_histlen:3794</span><br></pre></td></tr></table></figure><h3 id="7-6-主从同步保证数据一致性"><a href="#7-6-主从同步保证数据一致性" class="headerlink" title="7.6 主从同步保证数据一致性"></a>7.6 主从同步保证数据一致性</h3><p>​    为了保证主服务器Redis的数据和从服务器Redis的数据的一致性，也为了分担访问压力，均衡负载，应用层面一般采取读写分离的模式。读操作：主、从库都可以执行，一般是在从库上读数据，对实时性和准确性有100%高真要求的部分业务，在谨慎评估之后也可以读主库，前提是不能给Master带来高压力和风险。写操作：只在主库上写数据，写完之后将写操作指令同步到从库。</p><h3 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7 总结"></a>7.7 总结</h3><ul><li>主从复制的作用一个是为分担读写压力，均衡负载，另一个是为了保证部分实例宕机之后服务的持续可用性，所以Redis演变出主从架构和读写分离。</li><li>主从复制的步骤包括：建立连接的阶段、数据同步的阶段、基于长连接的命令传播阶段。</li><li>数据同步可以分为<code>全量复制</code>和<code>部分复制</code>，全量复制一般为第一次全量或者长时间主从连接断开。</li><li>主从模式是比较低级的可用性优化，要做到故障自动转移，异常预警，高保活，还需要更为复杂的哨兵或者集群模式，这个后面我们继续介绍。</li></ul><h2 id="8、Redis-sentinel—哨兵模式"><a href="#8、Redis-sentinel—哨兵模式" class="headerlink" title="8、Redis-sentinel—哨兵模式"></a><strong>8、Redis-sentinel—哨兵模式</strong></h2><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405141432953.png" alt="img"></p><h3 id="8-1-哨兵简介-Redis-Sentinel"><a href="#8-1-哨兵简介-Redis-Sentinel" class="headerlink" title="8.1 哨兵简介:Redis Sentinel"></a>8.1 哨兵简介:Redis Sentinel</h3><p><strong>Sentinel(哨兵)进程</strong>是用于监控redis集群中Master主服务器工作的状态，在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用。</p><p>哨兵(Sentinel) 是一个分布式系统，你可以在一个架构中运行<code>多个哨兵(sentinel) 进程</code>，这些进程使用<code>流言协议</code>来接收关于Master主服务器是否下线的信息，并使用<code>投票协议</code>来决定是否执行<code>自动故障迁移</code>,以及选择哪个Slave作为新的Master。</p><p>流言协议：</p><p>​    流言协议是一种<code>去中心化</code>的信息传播方式，其工作原理类似于人们在日常生活中传播流言：<strong>每个节点都将自己所知的信息告诉给它所连接的其他节点，这些节点再将信息传播给它们所连接的节点，以此类推，直到所有节点都获得了这条信息。</strong></p><h5 id="1、Redis哨兵集群的角色划分"><a href="#1、Redis哨兵集群的角色划分" class="headerlink" title="1、Redis哨兵集群的角色划分"></a>1、Redis哨兵集群的角色划分</h5><ul><li><strong>主节点（Master）：</strong> 处理客户端的读写请求。</li><li><strong>从节点（Slave）：</strong> 复制主节点的数据，用于提供读取服务和备份。</li><li><strong>哨兵节点（Sentinel）：</strong> 监控集群中各节点的健康状态，负责选举和故障转移。</li></ul><h5 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h5><ul><li><strong><code>监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</code></strong></li><li>提醒(Notification)：当被 监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作，它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</li></ul><p><strong>哨兵之间如何通信</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408150827546.png" alt="image-20240815082655417"></p><p>哨兵实例之间可以相互发现，要归功于 Redis 提供的 <strong>pub/sub</strong> 机制，也就是发布 / 订阅机制。</p><p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p><p>为了区分不同应用的消息，Redis 会以<strong>频道</strong>的形式，对这些消息进行分门别类的管理。<strong>所谓的频道，实际上就是消息的类别。</strong>当消息类别相同时，它们就属于同一个频道。反之，就属于不同的频道。<strong>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换</strong>。</p><p>在主从集群中，主库上有一个名为<strong><code>“sentinel:hello”</code></strong>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p><p>在上图图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到“<strong><code>sentinel:hello</code></strong>”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。</p><p>然后，哨兵 2、3 可以和哨兵 1 建立网络连接。通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。</p><p><strong>哨兵如何知道从库的ip地址和端口呢？</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408150832516.png" alt="image-20240815083231411"></p><p>由哨兵向主库发送 INFO 命令来完成的。就像上图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p><h5 id="3、工作模式"><a href="#3、工作模式" class="headerlink" title="3、工作模式"></a>3、工作模式</h5><ul><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。并通过实例返回的结果来判断实例是否在线。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 <code>down-after-milliseconds</code> 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</li><li>如果一个Master主服务器被标记为<strong>主观下线</strong>（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了<strong>主观下线状态</strong>。</li><li>当有足够数量的 Sentinel（哨兵）进程（<strong>大于等于配置文件指定的值</strong>）在指定的时间范围内确认Master主服务器进入了<strong>主观下线</strong>状态（SDOWN）， 则Master主服务器会被标记为<strong>客观下线</strong>（ODOWN）。</li><li>在一般情况下， 每个 Sentinel（哨兵）进程会以<strong>每 10 秒一次</strong>的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 <strong>Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次</strong>。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线操作就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ul><h5 id="4、主观下线和客观下线"><a href="#4、主观下线和客观下线" class="headerlink" title="4、主观下线和客观下线"></a>4、主观下线和客观下线</h5><p>主观下线：<code>Subjectively Down</code>，简称 <code>SDOWN</code>，指的是当前一个Sentinel 实例对某个redis服务器做出的下线判断。<br>客观下线：<code>Objectively Down</code>， 简称<code>ODOWN</code>，指的是多个 Sentinel 实例在对Master Server做出 SDOWN  判断，并且通过<code>SENTINEL is-master-down-by-addr</code> 命令互相交流之后，得出的Master  Server下线判断，然后开启failover/故障转移</p><h5 id="5、配置哨兵模式"><a href="#5、配置哨兵模式" class="headerlink" title="5、配置哨兵模式"></a>5、配置哨兵模式</h5><ul><li>每台机器上修改redis主配置文件<code>redis.conf</code>文件设置：<code>bind 0.0.0.0</code></li><li>每台机器上修改<code>sentinel.conf</code>配置文件：修改如下配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@redis-master ~]#  cd /usr/local/redis/</span><br><span class="line"></span><br><span class="line">[root@redis-master redis]# vim sentinel.conf</span><br><span class="line">...</span><br><span class="line">sentinel monitor mymaster 192.168.174.48 6379 2 </span><br><span class="line">sentinel down-after-milliseconds mymaster 3000 </span><br><span class="line">sentinel failover-timeout mymaster 10000 </span><br><span class="line">protected-mode no </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每台机器启动哨兵服务：</span></span><br><span class="line">[root@redis-master redis]# ./src/redis-sentinel sentinel.conf </span><br><span class="line">注意:在生产环境下将哨兵模式启动放到后台执行:     ./src/redis-sentinel sentinel.conf &amp;</span><br></pre></td></tr></table></figure><blockquote><p>参数解释：</p><p><code>sentinel down-after-milliseconds mymaster 3000</code>：</p><p>​    当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了。 (slave上面写的是master的ip，master写自己ip)</p><p><code>sentinel down-after-milliseconds mymaster 3000</code>： </p><p>​    表示如果名为 <code>mymaster</code> 的主节点在3秒（3000毫秒）内未对 Sentinel 的 PING 命令做出有效响应，那么 Sentinel 会开始考虑该主节点可能已经出现故障，并做好相应的故障转移准备。</p><p><code>sentinel failover-timeout mymaster 10000</code> ：</p><p>​    表示在进行名为 <code>mymaster</code> 的主节点的故障转移操作时，Sentinel 最多允许花费10秒（10000毫秒）的时间来完成整个操作。</p><p><code>protected-mode no</code>：</p><p>​    关闭加密保护模式</p></blockquote><p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564310139143.png#id=T6LR2&originHeight=666&originWidth=1751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><p><strong>将master的哨兵模式退出（Crtl+c），再将redis服务stop了，在两台slave上面查看其中一台是否切换为master:(没有优先级，为随机切换)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^C4854:signal-handler (1564349039) Received SIGINT scheduling shutdown...</span><br><span class="line">4854:X 29 Jul 05:23:59.592 # User requested shutdown...</span><br><span class="line">4854:X 29 Jul 05:23:59.592 # Sentinel is now ready to exit, bye bye...</span><br><span class="line">[root@redis-master redis]# systemctl stop redis.service</span><br><span class="line">或者用kill命令杀死</span><br></pre></td></tr></table></figure><p>在slave机器上面查看:</p><p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564320905579.png#id=Cshe1&originHeight=594&originWidth=1882&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><p><img src="https://gitee.com/youngfit/typora/raw/master/images/1564320763210.png#id=UPfuL&originHeight=339&originWidth=1897&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt></p><h5 id="6、Redis故障Master选举算法（了解）"><a href="#6、Redis故障Master选举算法（了解）" class="headerlink" title="6、Redis故障Master选举算法（了解）"></a>6、Redis故障Master选举算法（了解）</h5><ul><li><strong>优先级：</strong> 每个节点都有一个优先级，选择优先级最高的节点作为新的主节点。</li><li><strong>复制偏移量：</strong> 选择复制偏移量最大的从节点，确保数据同步性。</li><li><strong>运行ID：</strong> 选择运行ID最大的节点，确保节点唯一性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisSentinelPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.exceptions.JedisException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterElection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">        Set&lt;String&gt; sentinels = Set.of(<span class="string">"sentinel1:26379"</span>, <span class="string">"sentinel2:26379"</span>, <span class="string">"sentinel3:26379"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels)) &#123;</span><br><span class="line">            Jedis jedis = sentinelPool.getResource();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取当前主节点</span></span><br><span class="line">            String currentMaster = jedis.sentinelGetMasterAddrByName(masterName).getHost();</span><br><span class="line">            System.out.println(<span class="string">"Current Master: "</span> + currentMaster);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 模拟主节点故障</span></span><br><span class="line">            simulateMasterFailure(jedis, masterName);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 等待哨兵节点进行选举</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取新的主节点</span></span><br><span class="line">            String newMaster = jedis.sentinelGetMasterAddrByName(masterName).getHost();</span><br><span class="line">            System.out.println(<span class="string">"New Master: "</span> + newMaster);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simulateMasterFailure</span><span class="params">(Jedis jedis, String masterName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟主节点故障，停止主节点</span></span><br><span class="line">        jedis.sentinelFailover(masterName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试"><a href="#面试" class="headerlink" title="面试:"></a>面试:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis有哪些优点</span><br><span class="line">(1) 速度快，因为数据存在内存中。</span><br><span class="line">(2) 支持丰富数据类型，支持string，list，set，hash等</span><br><span class="line">(3) 支持事务，操作都是原子性，就是对数据的更改要么全部执行，要么全部不执行</span><br><span class="line">(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</span><br><span class="line"></span><br><span class="line">redis相比memcached有哪些优势</span><br><span class="line">(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</span><br><span class="line">(2) redis可以持久化其数据</span><br><span class="line"></span><br><span class="line">redis常见性能问题和解决方案</span><br><span class="line">(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</span><br><span class="line">(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</span><br><span class="line">(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</span><br><span class="line">(4) 尽量避免在压力很大的主库上增加从库</span><br><span class="line">(5) 主从复制不要用树状结构，用单向链表结构更为稳定，即：Master（写） &lt;- Slave1（读） &lt;- Slave2（读） &lt;- Slave3（读）...</span><br><span class="line">这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</span><br><span class="line">redis集群的工作原理</span><br><span class="line">主多从+哨兵模式</span><br></pre></td></tr></table></figure><p>了解:</p><p>redis–快照</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">快照，主要涉及的是redis的RDB持久化相关的配置</span><br><span class="line"></span><br><span class="line">用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：</span><br><span class="line"></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">举例</span><br><span class="line">save 900 1 //表示每15分钟且至少有1个key改变，就触发一次持久化</span><br><span class="line">save 300 10 //表示每5分钟且至少有10个key改变，就触发一次持久化</span><br><span class="line">save 60 10000 //表示每60秒至少有10000个key改变，就触发一次持久化</span><br><span class="line"></span><br><span class="line">如果想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果，就像这样：</span><br><span class="line"></span><br><span class="line">save ""</span><br></pre></td></tr></table></figure><p>安全:为redis加密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以要求redis客户端在向redis-server发送请求之前，先进行密码验证。当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。</span><br><span class="line"></span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line">这里我们通过requirepass将密码设置成“123456”。</span><br></pre></td></tr></table></figure><p>修改了Redis的哨兵配置文件后，先把文件拷贝到从机再启动，否则会出现myid冲突的情况。</p><p>解决方法：将哨兵停掉，哨兵配置文件删除后，重新弄一份新的，然后再启动即可。</p><p>+slave ：取消主观下线<br>-slave ：标记为主观下线</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://l66stbz.github.io/tags/Redis/"/>
    
      <category term="RDB" scheme="https://l66stbz.github.io/tags/RDB/"/>
    
      <category term="AOF" scheme="https://l66stbz.github.io/tags/AOF/"/>
    
      <category term="Sentinel" scheme="https://l66stbz.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>LVS-NAT-Keepalived</title>
    <link href="https://l66stbz.github.io/2024/08/13/LVS-NAT-Keepalived/"/>
    <id>https://l66stbz.github.io/2024/08/13/LVS-NAT-Keepalived/</id>
    <published>2024-08-13T14:30:00.000Z</published>
    <updated>2024-08-17T07:11:55.370Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LVS-Nat模式-Keepalived"><a href="#LVS-Nat模式-Keepalived" class="headerlink" title="LVS-Nat模式+Keepalived"></a>LVS-Nat模式+Keepalived</h1><p>四台机器（网络模式都设置为NAT模式）</p><p>两台做lvs-nat模式的keepalived集群:分别添加一块桥接网卡</p><p>两台做RS(Nginx提供静态页面即可)</p><h2 id="两台lvs操作"><a href="#两台lvs操作" class="headerlink" title="两台lvs操作"></a>两台lvs操作</h2><p>都添加一块桥接的网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">lvs的master节点配置文件</span><br><span class="line">[root@lvs-master ~]# yum -y install ipvsadm keepalived</span><br><span class="line">[root@lvs-master ~]# cat /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id lvs-keepalived-master</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens37#桥接网卡名称</span><br><span class="line">    virtual_router_id 80</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">      192.168.31.250/24#注意自己的网段</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.31.250 80 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    nat_mask 255.255.255.0</span><br><span class="line">    protocol TCP</span><br><span class="line">real_server 192.168.62.168 80 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    inhibit_on_failure</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">        connect_port 80</span><br><span class="line">        connect_timeout 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.62.166 80 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    inhibit_on_failure</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">    connect_timeout 3</span><br><span class="line">    connect_port 80</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33#NAT模式网卡名称</span><br><span class="line">    virtual_router_id 100</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2222</span><br><span class="line">        &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.62.112/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@lvs-slave ~]# yum -y install ipvsadm keepalived</span><br><span class="line">[root@lvs-slave ~]# cat /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id lvs-keepalived-slave</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens37</span><br><span class="line">    nopreempt</span><br><span class="line">    virtual_router_id 80</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">    192.168.31.250/24</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.31.250 80 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    nat_mask 255.255.255.0</span><br><span class="line">    protocol TCP</span><br><span class="line">real_server 192.168.62.168 80 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    inhibit_on_failure</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">        connect_port 80</span><br><span class="line">        connect_timeout 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.62.166 80 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    inhibit_on_failure</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">    connect_timeout 3</span><br><span class="line">    connect_port 80</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    nopreempt</span><br><span class="line">    virtual_router_id 100</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2222</span><br><span class="line">        &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.62.112/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意开启路由转发</span><br><span class="line">[root@lvs-master ~]# vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">[root@lvs-master ~]# sysctl -p</span><br><span class="line"></span><br><span class="line">[root@lvs-slave ~]# vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">[root@lvs-slave ~]# sysctl -p</span><br><span class="line">====================================================================================</span><br><span class="line">启动Keepalived服务</span><br><span class="line">[root@lvs-master ~]# systemctl start keepalived</span><br><span class="line">[root@lvs-slave ~]# systemctl start keepalived</span><br></pre></td></tr></table></figure><h2 id="两台RS-Nginx服务器-操作"><a href="#两台RS-Nginx服务器-操作" class="headerlink" title="两台RS(Nginx服务器)操作"></a>两台RS(Nginx服务器)操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装nginx服务器，配置不同的静态页面过程：略</span><br><span class="line"></span><br><span class="line">[root@test-nginx1 ~]# route add default gw 192.168.62.112  dev ens33</span><br><span class="line">[root@test-nginx2 ~]# route add default gw 192.168.62.112  dev ens33</span><br><span class="line">提示：由于临时添加的方式，网关有可能会消失，消失就添加即可。</span><br></pre></td></tr></table></figure><h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><p>当两个vip在master节点上时，访问浏览器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-master ~]# ip a</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1587459192373.png" alt="1587459192373"></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1587459211968.png" alt="1587459211968"></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1587459227691.png" alt="1587459227691"></p><p>把master节点的keepalived服务停止，两个vip会漂移到backup节点，再次用浏览器访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-slave ~]# ip a</span><br></pre></td></tr></table></figure><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1587459343612.png" alt="1587459343612"></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1587459371034.png" alt="1587459371034"></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1587459411871.png" alt="1587459411871"></p><p>总结：如果ip漂移之后，访问不到，</p><p>1.查看backup节点是否开启了路由转发</p><p>2.查看RS上面的网关有没有消失</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Keepalived" scheme="https://l66stbz.github.io/tags/Keepalived/"/>
    
      <category term="LVS" scheme="https://l66stbz.github.io/tags/LVS/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡+keepalived</title>
    <link href="https://l66stbz.github.io/2024/08/12/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1+keepalived/"/>
    <id>https://l66stbz.github.io/2024/08/12/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1+keepalived/</id>
    <published>2024-08-12T14:50:00.000Z</published>
    <updated>2024-08-17T07:16:02.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="keepalived-高可用实战"><a href="#keepalived-高可用实战" class="headerlink" title="keepalived 高可用实战"></a>keepalived 高可用实战</h1><p>[TOC]</p><h2 id="1、Keepalived相关概念"><a href="#1、Keepalived相关概念" class="headerlink" title="1、Keepalived相关概念"></a>1、Keepalived相关概念</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>​    Keepalived是一种用于实现高可用性（High Availability）的软件，主要通过VRRP（Virtual Router Redundancy Protocol）协议来实现IP地址的热备份。它可以在两台或多台服务器之间进行故障切换，确保当一台服务器出现故障时，其他服务器能够接管其服务，从而提高系统的可用性和稳定性。</p><h3 id="1-2-keepalived工作原理"><a href="#1-2-keepalived工作原理" class="headerlink" title="1.2 keepalived工作原理"></a>1.2 keepalived工作原理</h3><p>Keepalived 的核心功能是通过 VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）来实现主备切换和健康检查。以下是 Keepalived 的主要工作原理和流程：</p><ol><li><strong><code>VRRP 协议</code></strong></li></ol><ul><li><strong>VRRP (Virtual Router Redundancy Protocol)</strong> 是一种网络协议，及<strong>虚拟路由冗余协议</strong>。主要用于在多个路由器之间提供冗余。当一台设备出现故障时，其他设备能够迅速接管其工作。</li><li>在 Keepalived 中，VRRP 被用来在多台服务器之间共享一个虚拟 IP 地址（VIP）。这个 VIP 是对外提供服务的地址，客户端会通过这个地址访问服务。</li></ul><ol start="2"><li><strong>主/备角色</strong></li></ol><ul><li><strong>主服务器 (Master)</strong>：在 Keepalived 配置中，通常会有一个主服务器负责持有 VIP。所有的客户端请求都会发送到这个 VIP 上，主服务器处理这些请求。</li><li><strong>备服务器 (Backup)</strong>：备服务器是处于备用状态的服务器，它也在监听 VIP 的状态。如果主服务器出现故障（例如网络断开、服务停止等），备服务器将接管 VIP 并成为新的主服务器。</li></ul><ol start="3"><li><strong>健康检查</strong></li></ol><ul><li>Keepalived 会定期对后端的真实服务器（Real Server）进行健康检查，检查内容可以包括 TCP 连接状态、HTTP 状态码等。</li><li>如果检测到某个后端服务器不可用，Keepalived 会从负载均衡池中移除该服务器，防止继续向其发送请求。当该服务器恢复正常后，Keepalived 会自动将其重新加入负载均衡池。</li></ul><ol start="4"><li><strong>优先级与抢占</strong></li></ol><ul><li>每个参与 VRRP 的服务器都有一个优先级，优先级最高的服务器会成为主服务器。</li><li>如果当前的主服务器出现故障或优先级降低，优先级最高的备服务器将抢占成为新的主服务器，并接管 VIP。</li><li>当原主服务器恢复且优先级高于当前主服务器时，可以重新抢占成为主服务器。</li></ul><ol start="5"><li><strong>VRRP 广播</strong></li></ol><ul><li>主服务器定期向网络中的备服务器发送 VRRP 广播包，告知自己仍然是主服务器。</li><li>如果备服务器在一定时间内没有收到主服务器的广播包，就会认为主服务器故障，并发起选举，确定新的主服务器。</li></ul><h3 id="1-3-VRRP协议"><a href="#1-3-VRRP协议" class="headerlink" title="1.3 VRRP协议"></a>1.3 VRRP协议</h3><p><strong>VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）</strong> 是一种网络协议，用于提高网络的可靠性和可用性。它通过在多台路由器之间共享一个虚拟 IP 地址，实现网关冗余，从而确保当主路由器故障时，备份路由器能够迅速接管，继续为网络设备提供服务。</p><h3 id="1-4-keepalived-的常用模块"><a href="#1-4-keepalived-的常用模块" class="headerlink" title="1.4 keepalived 的常用模块"></a>1.4 keepalived 的常用模块</h3><ol><li><strong>Core模块</strong>：这是Keepalived的核心模块，负责主进程的启动和维护，以及全局配置文件的加载和解析。它是Keepalived工作的基础，确保其他模块能够正常运行。</li><li><strong>Check模块</strong>：这个模块负责健康检查，包括多种检查方式，如Layer3、Layer4和Layer7的检测，分别工作在IP/TCP协议栈的IP层、TCP层和应用层。通过这些层次的检查，Keepalived能够全面监控服务器的运行状态，并在检测到故障时进行隔离。</li><li><strong>VRRP模块</strong>：实现主备路由器之间的冗余。通过 VRRP，Keepalived 可以在多个服务器之间共享一个虚拟 IP 地址（VIP），从而在主服务器故障时自动切换到备份服务器，确保高可用性。</li></ol><h3 id="1-5-脑裂介绍"><a href="#1-5-脑裂介绍" class="headerlink" title="1.5 脑裂介绍"></a>1.5 脑裂介绍</h3><p>​    “脑裂”是一个网络术语，指的是在高可用性集群中，由于网络通信故障或配置不当，导致两个节点同时认为自己是主节点的情况。这种情况会引起服务的中断或不稳定。Keepalived的BACKUP主机在收不到MASTER主机报文后就会切换成为master，如果是它们之间的通信线路出现问题，无法接收到彼此的组播通知，但是两个节点实际都处于正常工作状态，这时两个节点均为master强行绑定虚拟IP，就是脑裂。</p><h3 id="1-6-脑裂的解决方法"><a href="#1-6-脑裂的解决方法" class="headerlink" title="1.6 脑裂的解决方法"></a>1.6 脑裂的解决方法</h3><ol><li>添加更多的检测手段，比如冗余的心跳线（两块网卡做健康监测），ping对方等等。尽量减少”裂脑”发生机会。(治标不治本，只是提高了检测到的概率)；</li><li>做好对裂脑的监控报警（如邮件及手机短信等或值班）.在问题发生时人为第一时间介入仲裁，降低损失；</li><li>爆头，将master停掉。然后检查机器之间的防火墙。网络之间的通信；</li><li>引入仲裁机制：如果集群中存在多个主备节点，可以引入仲裁机制来解决脑裂问题。仲裁机制可以由一个独立的节点或服务来判断哪个节点是主节点，从而避免两个节点同时认为自己是主节点的情况。</li></ol><h3 id="1-7-Keepalived工作流程"><a href="#1-7-Keepalived工作流程" class="headerlink" title="1.7 Keepalived工作流程"></a>1.7 Keepalived工作流程</h3><ol><li><p><strong>启动时</strong>：所有参与 Keepalived 的服务器启动时，都会发送 VRRP 广播包。优先级最高的服务器被选为主服务器，并接管 VIP。</p></li><li><p><strong>正常运行时</strong>：主服务器会持续发送 VRRP 广播包，通知备服务器自己处于正常工作状态。备服务器则处于监听状态，等待主服务器故障。</p></li><li><p><strong>故障切换</strong>：如果主服务器故障，备服务器检测到 VRRP 广播包丢失，将发起新的主服务器选举。优先级最高的备服务器会接管 VIP，成为新的主服务器。</p></li><li><p><strong>恢复抢占</strong>：当原主服务器恢复且优先级高于当前主服务器时，会重新抢占 VIP，恢复为主服务器。</p></li></ol><h2 id="2、Nginx-keepalived实现七层的负载均衡-同类服务"><a href="#2、Nginx-keepalived实现七层的负载均衡-同类服务" class="headerlink" title="2、Nginx+keepalived实现七层的负载均衡(同类服务)"></a>2、Nginx+keepalived实现七层的负载均衡(同类服务)</h2><ol><li><strong>环境准备</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.38ha-server</span><br><span class="line">192.168.174.39ha-backup</span><br><span class="line">192.168.174.40real-server01</span><br><span class="line">192.168.174.41real-server02</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>real serve配置</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 两台 real server主机关闭防火墙和selinux</span></span><br><span class="line">[root@real-server ~]# systemctl disable --now firewalld</span><br><span class="line">[root@real-server ~]# setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 两台 real server 安装web服务，模拟真实提供服务主机</span></span><br><span class="line">[root@real-server ~]# yum install nginx -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; real server01 网站界面配置</span></span><br><span class="line">[root@real-server01 ~]# echo "read server01"  &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动nginx</span></span><br><span class="line">[root@real-server01 ~]# systemctl enable --now nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 测试是否正常访问</span></span><br><span class="line">[root@real-server01 ~]# curl 192.168.174.20</span><br><span class="line">real server01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; real server02 网站界面配置</span></span><br><span class="line">[root@real-server02 ~]# echo "read server02"  &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动nginx</span></span><br><span class="line">[root@real-server02 ~]# systemctl enable --now nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 测试是否正常访问</span></span><br><span class="line">[root@real-server02 ~]# curl 192.168.174.21</span><br><span class="line">real server02</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">  拓扑结构</span><br><span class="line"></span><br><span class="line">[vip: 20.20.20.20]</span><br><span class="line"></span><br><span class="line">[LB1 Nginx][LB2 Nginx]</span><br><span class="line">192.168.1.2192.168.1.3</span><br><span class="line"></span><br><span class="line">[index][milis] [videos]   [images]    [news]</span><br><span class="line"> 1.11 1.21   1.31  1.41   1.51</span><br><span class="line"> 1.12 1.22   1.32  1.42   1.52</span><br><span class="line"> 1.13 1.23   1.33  1.43   1.53</span><br><span class="line"> ... ...    ...  ...    ...</span><br><span class="line"> /web     /web/milis    /web/videos     /web/images   /web/news</span><br><span class="line">   index.html  index.html     index.html      index.html   index.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 两台负载均衡设备关闭防火墙selinux</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">disable</span> --now firewalld &amp;&amp; setenforce 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 两台负载均衡设备安装nginx作为负载均衡均衡器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; ha-master配置</span></span><br><span class="line">[root@ha-master ~]# cd /etc/nginx/conf.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 备份原有的nginx配置文件</span></span><br><span class="line">[root@ha-master conf.d]# mv default.conf default.conf.bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; master和backup配置负载均衡</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim upstream.conf</span></span><br><span class="line">upstream index &#123;</span><br><span class="line">        server 192.168.174.40:80;</span><br><span class="line">        server 192.168.174.41:80;</span><br><span class="line">&#125; </span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">         proxy_pass http://index;</span><br><span class="line">         proxy_redirect default;</span><br><span class="line">         proxy_set_header Host $http_host;</span><br><span class="line">         proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 两台负载均衡主机测试nginx配置语法是否有问题</span></span><br><span class="line">[root@ha conf.d]# nginx -t</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 两台负载均衡主机启动nginx负载均衡服务</span></span><br><span class="line">[root@ha conf.d]#  systemctl enable --now nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 两台负载均衡主机测试用户请求是否正常转发</span></span><br><span class="line">略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`二、Keepalived实现调度器HA`</span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 主/备调度器安装高可用软件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y keepalived</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; ha-master节点keepalived配置</span></span><br><span class="line">[root@ha-master ~]# mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak</span><br><span class="line">[root@ha-master ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id directory1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 80</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.174.101/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; ha-backup配置</span></span><br><span class="line">[root@nginx-porxy-slave ~]# mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak</span><br><span class="line">[root@nginx-proxy-slave ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id directory2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    nopreempt        # 设置到back上面，不抢占资源(VIP)</span><br><span class="line">    virtual_router_id 80</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.174.101/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动KeepAlived（主备均启动）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> --now keepalived</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>global_defs</strong>：定义全局模块</p><ul><li><strong>router_id directory1</strong>：用于唯一标识一个路由器或设备实例。区分多个设备或实例，特别是在涉及主备（Master/Backup）配置的场景中。但Master和Backup需设置不同。</li></ul></li><li><p><strong>vrrp_instance VI_1</strong>：定义VRRP 实例，名称为 <code>VI_1</code>。名字可以自定义，但需要确保主节点和备份节点的名称一致。</p></li><li><p><strong>VRRP Instance State (实例状态)</strong></p><ul><li><strong>state MASTER</strong>：定义当前节点的状态为 <code>MASTER</code>，表示主节点。备份节点设置为 <code>BACKUP</code>。</li></ul></li><li><p><strong>Network Interface (网络接口)</strong></p><ul><li><strong>interface ens33</strong>：指定绑定 VIP 的网络接口。VIP 绑定在 <code>ens33</code> 接口上。主备服务器上都存在的物理网卡或虚拟网卡。</li></ul></li><li><p><strong>Virtual Router ID (虚拟路由器 ID)</strong></p><ul><li><strong>virtual_router_id 80</strong>：设置 VRRP 虚拟路由器的 ID，范围是 0-255。主节点和备份节点的 <code>virtual_router_id</code> 必须一致，确保它们在同一个 VRRP 组中。</li></ul></li><li><p><strong>Priority (优先级)</strong></p><ul><li><strong>priority 100</strong>：设置节点的优先级，范围是<code>0-255</code>。数值越高，优先级越高。主节点的优先级较高，备份节点的优先级较低，通常设置为 <code>50</code> 或其他值。优先级决定了当主节点故障时，哪个备份节点会接管 VIP。</li></ul></li><li><p><strong>Advertisement Interval (广播间隔)</strong></p><ul><li><strong>advert_int 1</strong>：定义 VRRP 广播包的时间间隔，以秒为单位。这里设置为 <code>1</code> 秒，表示主节点每秒发送一次心跳信号，通知备份节点主节点在线。</li></ul></li><li><p><strong>Authentication (认证)</strong></p><ul><li>authentication：定义 VRRP 实例的认证方式。<ul><li><strong>auth_type PASS</strong>：指定认证类型为 <code>PASS</code>，密码认证。</li><li><strong>auth_pass 1111</strong>：设置认证密码为 <code>1111</code>。主节点和备份节点的认证密码必须一致。</li></ul></li></ul></li><li><p><strong>Virtual IP Address (虚拟 IP 地址)</strong></p><ul><li><strong>virtual_ipaddress</strong>：定义虚拟 IP 地址（VIP）。 VIP 是整个集群对外暴露的 IP 地址。<ul><li><strong>192.168.174.101/24</strong>：VIP 地址是 <code>192.168.174.101</code>，子网掩码为 <code>/24</code>。这个 VIP 将被绑定到主节点上，当主节点故障时，备份节点会接管该 IP。</li></ul></li></ul></li></ul><ol start="5"><li><p><strong>健康检查机制</strong></p><p>让 Keepalived 以一定时间间隔执行一个外部脚本，脚本的功能是当Nginx失败，则关闭本机的Keepalived，实现VIP漂移。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 配置检测nginx健康检查脚本</span></span><br><span class="line">[root@ha ~]<span class="comment"># vim /etc/keepalived/check_nginx_status.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash        </span></span><br><span class="line">/usr/bin/curl -I http://localhost &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span>    </span><br><span class="line">systemctl stop keepalived</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 脚本添加执行权限</span></span><br><span class="line">[root@ha ~]<span class="comment"># chmod a+x /etc/keepalived/check_nginx_status.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 两台 keepalived 实例添加配置</span></span><br><span class="line">[root@ha ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id directory1</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">   script <span class="string">"/etc/keepalived/check_nginx_status.sh"</span>  </span><br><span class="line">   interval 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 80</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.174.100/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`注：必须先启动Nginx，再启动keepalived`</span><br><span class="line"></span><br><span class="line">测试访问：  </span><br><span class="line">将keepalived集群的主节点的Nginx服务关闭，查看vip是否漂移，如果漂移，即成功</span><br></pre></td></tr></table></figure><blockquote><ul><li><pre><code class="shell">vrrp_script check_nginx {   # 健康检查配置   script "/etc/keepalived/check_nginx_status.sh"  # 脚本绝对路径   interval 5        # 执行脚本间隔}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;shell</span><br><span class="line">  track_script &#123;   # 定义要跟踪的脚本或检查命令。当 Keepalived 检测到这些脚本的返回状态为非零时，会根据 VRRP 实例的配置执行相应的操作，切换到备份节点。</span><br><span class="line">      check_nginx  # 自定义脚本或命令的名称。check_nginx 检查 Nginx 服务是否正在运行。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></blockquote><h2 id="3、LVS-Director-Keepalived"><a href="#3、LVS-Director-Keepalived" class="headerlink" title="3、LVS_Director + Keepalived"></a>3、LVS_Director + Keepalived</h2><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1568643540153.png" alt="1568643540153"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">LVS_Director + KeepAlived</span><br><span class="line"></span><br><span class="line">KeepAlived在该项目中的功能：</span><br><span class="line">1. 管理IPVS的路由表（包括对RealServer做健康检查）</span><br><span class="line">2. 实现调度器的HA(高可用)</span><br><span class="line">http://www.keepalived.org</span><br><span class="line"></span><br><span class="line">Keepalived所执行的外部脚本命令建议使用绝对路径</span><br><span class="line">=================================================================================</span><br><span class="line">实施步骤：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主/备调度器安装软件</span></span><br><span class="line">[root@lvs-keepalived-master ~]# yum -y install ipvsadm keepalived </span><br><span class="line">[root@lvs-keepalived-backup ~]# yum -y install ipvsadm keepalived</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> lvs-Keepalived-master节点配置</span></span><br><span class="line">[root@lvs-keepalived-master ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id lvs-keepalived-master    #辅助改为lvs-backup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33                #VIP绑定接口</span><br><span class="line">    virtual_router_id 80         #VRID 同一组集群，主备一致          </span><br><span class="line">    priority 100            #本节点优先级，辅助改为50</span><br><span class="line">    advert_int 1            #检查间隔，默认为1s</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.174.101/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.174.101 80 &#123;    #LVS配置</span><br><span class="line">delay_loop 3  #启动3个进程</span><br><span class="line">lb_algo rr     #LVS调度算法</span><br><span class="line">lb_kind DR     #LVS集群模式（路由模式）</span><br><span class="line">nat_mask 255.255.255.0</span><br><span class="line">protocol TCP      #健康检查使用的协议</span><br><span class="line">real_server 192.168.174.40 80 &#123;</span><br><span class="line">weight 1</span><br><span class="line">inhibit_on_failure   #当该节点失败时，把权重设置为0，而不是从IPVS中删除</span><br><span class="line">TCP_CHECK &#123;          #健康检查</span><br><span class="line">connect_port 80   #检查的端口</span><br><span class="line">connect_timeout 3  #连接超时的时间</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.174.41 80 &#123;</span><br><span class="line">weight 1</span><br><span class="line">inhibit_on_failure</span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">connect_port 80</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> lvs-keepalived-backup节点配置</span></span><br><span class="line">[root@lvs-keepalived-backup ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id lvs-keepalived-slave</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    nopreempt                    #不抢占VIP</span><br><span class="line">    virtual_router_id 80</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.174.101/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 192.168.174.101 80 &#123;</span><br><span class="line">delay_loop 3</span><br><span class="line">lb_algo rr</span><br><span class="line">lb_kind DR</span><br><span class="line">nat_mask 255.255.255.0</span><br><span class="line">protocol TCP</span><br><span class="line">real_server 192.168.174.40 80 &#123;</span><br><span class="line">weight 1</span><br><span class="line">inhibit_on_failure</span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_port 80</span><br><span class="line">connect_timeout 3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.174.41 80 &#123;</span><br><span class="line">weight 1</span><br><span class="line">inhibit_on_failure</span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">connect_port 80</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动Keepalived（主备均启动）</span></span><br><span class="line">[root@lvs-keepalived-master ~]# systemctl enable  --now keepalived</span><br><span class="line">[root@lvs-keepalived-backup ~]# systemctl enable  --now keepalived</span><br><span class="line"></span><br><span class="line">[root@lvs-keepalived-master ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  192.168.174.101:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.174.39:80            Route   1      1          8         </span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.174.40:80            Route   1      0          9 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有RS配置(nginx1,nginx2)，配置好网站服务器，测试所有RS</span></span><br><span class="line">[root@real-server01 ~]# yum install -y nginx</span><br><span class="line">[root@real-server02 ~]# yum install -y nginx</span><br><span class="line"></span><br><span class="line">[root@real-server01 ~]# ip addr add dev lo 192.168.246.101/32</span><br><span class="line">[root@real-server02 ~]# ip addr add dev lo 192.168.246.101/32</span><br><span class="line"></span><br><span class="line">[root@real-server01 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore #忽略arp广播</span><br><span class="line">[root@real-server01 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce #匹配精确ip地址回包</span><br><span class="line"></span><br><span class="line">[root@real-server02 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore #忽略arp广播</span><br><span class="line">[root@real-server02 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce #匹配精确ip地址回包</span><br><span class="line"></span><br><span class="line">[root@real-server01 ~]# echo "web1..." &gt;&gt; /usr/share/nginx/html/index.html</span><br><span class="line">[root@real-server02 ~]# echo "web2..." &gt;&gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有real-server节点启动nginx</span></span><br><span class="line">[root@real-server ~]# systemctl enable --now nginx</span><br><span class="line"></span><br><span class="line">LB集群测试</span><br><span class="line">所有分发器和Real Server都正常</span><br><span class="line"></span><br><span class="line">主分发器故障及恢复</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 80       </span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.174.101/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.174.101 80 &#123;</span><br><span class="line">delay_loop 3</span><br><span class="line">lb_algo rr</span><br><span class="line">lb_kind DR</span><br><span class="line">nat_mask 255.255.255.0</span><br><span class="line">protocol TCP</span><br><span class="line">real_server 192.168.174.40 80 &#123;</span><br><span class="line">weight 1</span><br><span class="line">inhibit_on_failure</span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_port 80</span><br><span class="line">connect_timeout 3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.174.41 80 &#123;</span><br><span class="line">weight 1</span><br><span class="line">inhibit_on_failure</span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">connect_port 80</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Haproxy-基础"><a href="#Haproxy-基础" class="headerlink" title="Haproxy 基础"></a>Haproxy 基础</h1><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1562943827261.png" alt=" "></p><h2 id="1、Haproxy介绍"><a href="#1、Haproxy介绍" class="headerlink" title="1、Haproxy介绍"></a>1、Haproxy介绍</h2><p>​    HAProxy是一个高性能的开源负载均衡器和代理服务器，使用C语言编写，提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。其特别适用于负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy可以运行在当前的硬件上，支持数以万计的并发连接，并且能够很简单安全地整合进用户当前的架构中，同时保护web服务器不被暴露到网络上。</p><p>HAProxy的工作原理是，当客户端发起连接请求时，它将连接到HAProxy提供的IP地址和端口。HAProxy能够将传入的请求分发到多个后端服务器，并提供各种负载均衡算法，如轮询、加权轮询、最少连接等。同时，HAProxy具有高度可配置性和可定制性，适用于Web应用、数据库负载均衡、应用程序代理等场景，提供高可用性和可伸缩性。</p><p>特点：</p><ul><li>支持tcp/http两种协议层的负载均衡，使得其负载均衡功能非常丰富。</li><li>支持8种左右的负载均衡算法，尤其是在http模式时，有许多非常实在的负载均衡算法，适用各种需求。</li><li>性能非常优秀，基于单进程处理模式（和Nginx类似）让其性能卓越。</li><li>拥有一个功能出色的监控页面，实时了解系统的当前状况。</li><li>功能强大的ACL支持，给用户极大的方便。</li></ul><h2 id="2、Haproxy-实现七层负载实验"><a href="#2、Haproxy-实现七层负载实验" class="headerlink" title="2、Haproxy 实现七层负载实验"></a><strong>2、Haproxy 实现七层负载实验</strong></h2><p><strong><code>流程图：</code></strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408131109708.png" alt="image-20240813110902650"></p><p><strong>实验操作流程：</strong></p><ol><li><strong>主机划分</strong></li></ol><ul><li><pre><code class="ini"><span class="section">[root@haproxy-master ~]</span><span class="comment"># cat /etc/hosts</span>192.168.174.38    haproxy-master192.168.174.39    haproxy-backup192.168.174.40    real-server01 192.168.174.41    real-server02<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **两台real-server配置**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;shell</span><br><span class="line">  #&gt;&gt;&gt; 关闭防火墙及selinux</span><br><span class="line">  $ systemctl disable --now firewalld &amp;&amp; setenforce 0</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 安装nginx</span><br><span class="line">  $ yum install -y nginx</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 准备测试文件</span><br><span class="line">  [root@real-server01 ~]# echo nginx01  &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </span><br><span class="line">  </span><br><span class="line">  [root@real-server02 ~]# echo nginx02 &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 修改配置文件keepalive_timeout时长</span><br><span class="line">  $ vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">  ···</span><br><span class="line">  keepalive_timeout  0;</span><br><span class="line">  ···</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 两台real-server启动nginx</span><br><span class="line">  $ systemctl enable --now nginx</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 测试访问</span><br><span class="line">  略</span><br></pre></td></tr></table></figure></code></pre></li></ul><ol start="3"><li><strong>两台负载均衡服务器配置</strong></li></ol><ul><li><pre><code class="shell"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装haproxy</span><span class="meta">$</span><span class="bash"> yum install -y haproxy</span><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改Haproxy配置文件</span><span class="meta">$</span><span class="bash"> vim  /etc/haproxy/haproxy.cfg</span>global    log         127.0.0.1 local2 info    pidfile     /var/run/haproxy.pid    maxconn     4000    user        haproxy    group       haproxy    daemon    nbproc 1defaults    mode                    http    log                     global    retries                 3    option                  redispatch    maxconn                 4000    contimeout                5000    clitimeout                50000    srvtimeout                50000listen stats    bind            *:81    stats                       enable    stats uri                  /haproxy    stats auth               qianfeng:123frontend  web    mode                       http      bind                            *:80    option                  httplog    acl html url_reg  -i  \.html$    use_backend httpservers if  html    default_backend    httpserversbackend httpservers    balance     roundrobin    server  http1 192.168.174.40:80 maxconn 2000 weight 1  check inter 1s rise 2 fall 2    server  http2 192.168.174.41:80 maxconn 2000 weight 1  check inter 1s rise 2 fall 2<span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动haproxy</span><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> --now haproxy</span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**配置文件详细：**</span><br><span class="line"></span><br><span class="line">1. **全局配置**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;ini</span><br><span class="line">global</span><br><span class="line">    log         127.0.0.1 local2 info</span><br><span class="line">    pidfile     &#x2F;var&#x2F;run&#x2F;haproxy.pid</span><br><span class="line">    maxconn     4000</span><br><span class="line">    user        haproxy</span><br><span class="line">    group       haproxy</span><br><span class="line">    daemon</span><br><span class="line">    nbproc 1</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><strong><code>log 127.0.0.1 local2 info</code></strong>:</p><ul><li>日志记录配置。<code>127.0.0.1</code>表示日志发送到本地的Syslog服务器，<code>local2</code>是Syslog的设施（facility），<code>info</code>是日志级别。</li></ul><p><strong><code>pidfile /var/run/haproxy.pid</code></strong>:</p><ul><li>指定HAProxy进程ID的文件位置。</li></ul><p><strong><code>maxconn 4000</code></strong>:</p><ul><li>设置HAProxy允许的最大并发连接数为4000。超出这个限制的连接将被队列或拒绝。</li></ul><p><strong><code>user haproxy</code> 和 <code>group haproxy</code></strong>:</p><ul><li>指定HAProxy以哪个用户和用户组身份运行，以提高安全性。</li></ul><p><strong><code>daemon</code></strong>:</p><ul><li>使HAProxy以后台守护进程的方式运行，不阻塞终端。</li></ul><p><strong><code>nbproc 1</code></strong>:</p><ul><li>指定HAProxy运行的进程数量。<code>1</code>表示单进程模式。通常情况下，设置为服务器的CPU核心数，以充分利用多核CPU的性能。</li></ul><p>==========================================================================================================================================================================</p><ol start="2"><li><strong>默认配置</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    log                     global</span><br><span class="line">    retries                 3</span><br><span class="line">    option                  redispatch</span><br><span class="line">    maxconn                 4000</span><br><span class="line">    contimeout            5000</span><br><span class="line">    clitimeout            50000</span><br><span class="line">    srvtimeout            50000</span><br></pre></td></tr></table></figure><p><strong><code>mode http</code></strong>:</p><ul><li>设置HAProxy的工作模式为HTTP（7层），可以处理应用层的内容，如URL、头信息等。如果设置为TCP（4层），则只能处理传输层数据。</li></ul><p><strong><code>log global</code></strong>:</p><ul><li>继承全局配置中的日志设置。</li></ul><p><strong><code>retries 3</code></strong>:</p><ul><li>如果连接后端服务器失败，HAProxy会尝试重新连接3次。如果仍然失败，认为该服务器不可用。</li></ul><p><strong><code>option redispatch</code></strong>:</p><ul><li>如果某个服务器不可用，HAProxy会重新分配请求到其他健康的服务器，确保服务的可用性。</li></ul><p><strong><code>maxconn 4000</code></strong>:</p><ul><li>设置每个连接的最大并发数为4000，与全局配置中相同。</li></ul><p><strong><code>contimeout 5000</code></strong>:</p><ul><li>设置HAProxy与后端服务器建立连接的超时时间为5000毫秒（5秒）。</li></ul><p><strong><code>clitimeout 50000</code></strong>:</p><ul><li>设置客户端与HAProxy之间连接的超时时间为50000毫秒（50秒）。</li></ul><p><strong><code>srvtimeout 50000</code></strong>:</p><ul><li>设置后端服务器处理请求的超时时间为50000毫秒（50秒）。</li></ul><p>==========================================================================================================================================================================</p><ol start="3"><li><strong>统计页面配置</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen stats</span><br><span class="line">    bind*:81</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri              /haproxy</span><br><span class="line">    stats auth           qianfeng:123</span><br></pre></td></tr></table></figure><p><strong><code>bind *:81</code></strong>:</p><ul><li>监听所有IP地址的81端口，用于访问HAProxy的统计页面。</li></ul><p><strong><code>stats enable</code></strong>:</p><ul><li>启用统计页面。</li></ul><p><strong><code>stats uri /haproxy</code></strong>:</p><ul><li>指定访问统计页面的URI路径，即<code>http://&lt;HAProxy-IP&gt;:81/haproxy</code>。</li></ul><p><strong><code>stats auth qianfeng:123</code></strong>:</p><ul><li>启用用户认证，用户名为<code>qianfeng</code>，密码为<code>123</code>。访问统计页面时需要输入此用户名和密码。</li></ul><p>==========================================================================================================================================================================</p><ol start="4"><li><strong>前端配置</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frontend web</span><br><span class="line">    mode                   http  </span><br><span class="line">    bind                   *:80  </span><br><span class="line">    option                 httplog</span><br><span class="line">    acl html url_reg  -i  \.html$</span><br><span class="line">    use_backend httpservers if  html </span><br><span class="line">    default_backend    httpservers</span><br></pre></td></tr></table></figure><p><strong><code>frontend web</code></strong>:</p><ul><li>定义前端，名字为<code>web</code>。前端是客户端请求的入口。</li></ul><p><strong><code>mode http</code></strong>:</p><ul><li>设定前端的为HTTP。</li></ul><p><strong><code>bind *:80</code></strong>:</p><ul><li>监听所有IP地址的80端口，所有通过80端口的HTTP请求都会被接收。</li></ul><p><strong><code>option httplog</code></strong>:</p><ul><li>启用HTTP日志格式，记录HTTP相关的详细日志。</li></ul><p><strong><code>acl html url_reg -i \.html$</code></strong>:</p><ul><li>定义一个访问控制列表（ACL），名称为<code>html</code>。规则是匹配以<code>.html</code>结尾的URL（不区分大小写）。</li></ul><p><strong><code>use_backend httpservers if html</code></strong>:</p><ul><li>如果请求的URL匹配<code>html</code> ACL规则，则将请求转发到后端服务器组<code>httpservers</code>。</li></ul><p><strong><code>default_backend httpservers</code></strong>:</p><ul><li>如果请求不匹配任何ACL规则，则使用默认的后端服务器组<code>httpservers</code>。</li></ul><p>==========================================================================================================================================================================</p><ol start="5"><li><strong>后端配置</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">backend httpservers</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    server  http1 192.168.246.162:80 maxconn 2000 weight 1  check inter 1s rise 2 fall 2</span><br><span class="line">    server  http2 192.168.246.163:80 maxconn 2000 weight 1  check inter 1s rise 2 fall 2</span><br></pre></td></tr></table></figure><p><strong><code>backend httpservers</code></strong>:</p><ul><li>定义后端服务器组，名称为<code>httpservers</code>。后端服务器组是用于处理实际请求的服务器。</li></ul><p><strong><code>balance roundrobin</code></strong>:</p><ul><li>负载均衡策略为轮询（Roundrobin），请求会依次分配到每个服务器。</li></ul><p><strong><code>server http1 192.168.246.162:80 maxconn 2000 weight 1 check inter 1s rise 2 fall 2</code></strong>:</p><ul><li>定义一台后端服务器<code>http1</code>：<ul><li><code>192.168.246.162:80</code>: 服务器的IP地址和端口号。</li><li><code>maxconn 2000</code>: 这台服务器允许的最大连接数为2000。</li><li><code>weight 1</code>: 权重为1，影响负载均衡的分配比例，默认情况下权重越高，分配的请求越多。</li><li><code>check</code>: 启用健康检查，定期检查该服务器的状态。</li><li><code>inter 1s</code>: 每1秒进行一次健康检查。</li><li><code>rise 2</code>: 连续2次检查通过后认为服务器健康。</li><li><code>fall 2</code>: 连续2次检查失败后认为服务器不健康。</li></ul></li></ul><p>==========================================================================================================================================================================</p><p><strong>测试主/备(浏览器访问）</strong></p><p><a href="http://192.168.174.38:81/haproxy" target="_blank" rel="noopener">http://192.168.174.38:81/haproxy</a></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1569121374136.png" alt="1569121374136"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">页面主要参数解释</span><br><span class="line">Queue</span><br><span class="line">Cur: current queued requests //当前的队列请求数量</span><br><span class="line">Max：max queued requests     //最大的队列请求数量</span><br><span class="line">Limit：           //队列限制数量</span><br><span class="line"></span><br><span class="line">Errors</span><br><span class="line">Req：request errors             //错误请求</span><br><span class="line">Conn：connection errors          //错误的连接</span><br><span class="line"></span><br><span class="line">Server列表：</span><br><span class="line">Status:状态，包括up(后端机活动)和down(后端机挂掉)两种状态</span><br><span class="line">LastChk:    持续检查后端服务器的时间</span><br><span class="line">Wght: (weight) : 权重</span><br><span class="line">========================================================</span><br><span class="line">2.测试访问</span><br><span class="line">通过访问haparoxy的ip地址访问到后端服务器</span><br><span class="line"><span class="meta">#</span><span class="bash"> curl http://192.168.246.169</span></span><br><span class="line"></span><br><span class="line">如果出现bind失败的报错，执行下列命令</span><br><span class="line">set sebool -P haproxy_connect_any=1</span><br></pre></td></tr></table></figure><h2 id="3、Haprxoy-Keepalived实现高可用"><a href="#3、Haprxoy-Keepalived实现高可用" class="headerlink" title="3、Haprxoy+Keepalived实现高可用"></a>3、Haprxoy+Keepalived实现高可用</h2><ol><li><strong>两台负载均衡服务器安装Keepalived</strong></li></ol><ul><li><pre><code class="bash"><span class="comment">#&gt;&gt;&gt; 安装Keepalived</span>$ yum install -y keepalived<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **&#96;haproxy-master&#96;节点配置**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;bash</span><br><span class="line">  #&gt;&gt;&gt; 编写外部检查Haprxoy健康状态脚本</span><br><span class="line">  [root@haproxy-master ~]# vim &#x2F;etc&#x2F;keepalived&#x2F;check_haproxy_status.sh </span><br><span class="line">  #!&#x2F;bin&#x2F;bash</span><br><span class="line">  &#x2F;usr&#x2F;bin&#x2F;curl -I http:&#x2F;&#x2F;localhost &amp;&gt;&#x2F;dev&#x2F;null   </span><br><span class="line">  if [ $? -ne 0 ];then                                                   </span><br><span class="line">          systemctl stop keepalived</span><br><span class="line">  fi</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 脚本添加执行权限</span><br><span class="line">  [root@haproxy-master ~]# chmod +x &#x2F;etc&#x2F;keepalived&#x2F;check_haproxy_status.sh</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 将检查脚本scp至haproxy-backup节点</span><br><span class="line">  [root@haproxy-master ~]# scp check_haproxy_status.sh  192.168.174.39:&#x2F;etc&#x2F;keepalived&#x2F;</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 编写Keepalived配置文件</span><br><span class="line">  [root@haproxy-master ~]# vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</span><br><span class="line">  ! Configuration File for keepalived</span><br><span class="line">  </span><br><span class="line">  global_defs &#123;</span><br><span class="line">     router_id director1</span><br><span class="line">  &#125;</span><br><span class="line">  vrrp_script check_haproxy &#123;</span><br><span class="line">     script &quot;&#x2F;etc&#x2F;keepalived&#x2F;check_haproxy_status.sh&quot; # 脚本绝对路径</span><br><span class="line">     interval 5  # 执行脚本间隔时间</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vrrp_instance VI_1 &#123;</span><br><span class="line">      state MASTER</span><br><span class="line">      interface ens33</span><br><span class="line">      virtual_router_id 80</span><br><span class="line">      priority 100</span><br><span class="line">      advert_int 1</span><br><span class="line">      authentication &#123;</span><br><span class="line">          auth_type PASS</span><br><span class="line">          auth_pass 1111</span><br><span class="line">      &#125;</span><br><span class="line">      virtual_ipaddress &#123;</span><br><span class="line">          192.168.174.105&#x2F;24   # VIP地址</span><br><span class="line">      &#125;</span><br><span class="line">      track_script &#123;</span><br><span class="line">          check_haproxy</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><ol start="3"><li><strong><code>Haproxy-backup</code>节点配置</strong></li></ol><ul><li><pre><code class="shell"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 脚本添加执行权限</span>[root@haproxy-master ~]# chmod +x /etc/keepalived/check_haproxy_status.sh<span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编写Keepalived配置文件</span>[root@haproxy-backup ~]# vim /etc/keepalived/keepalived.conf ! Configuration File for keepalivedglobal_defs {   router_id directory2}vrrp_script check_haproxy {   script "/etc/keepalived/check_haproxy_status.sh"   interval 5}vrrp_instance VI_1 {    state BACKUP    interface ens33    nopreempt    virtual_router_id 80    priority 50    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    virtual_ipaddress {        192.168.174.105/24    }    track_script {        check_haproxy    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. **两台负载均衡器配置**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;shell</span><br><span class="line">  #&gt;&gt;&gt; 重启Keepalived和Haproxy</span><br><span class="line">  $ systemctl restart keepalived haproxy</span><br><span class="line">  </span><br><span class="line">  #&gt;&gt;&gt; 加入开机自启</span><br><span class="line">  $ systemctl enable  keepalived haproxy</span><br></pre></td></tr></table></figure></code></pre></li></ul><ol start="5"><li><strong>查看<code>haproxy-master</code>节点网卡</strong></li></ol><ul><li><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408131137222.png" alt="image-20240813113730090"></li></ul><blockquote><p>提示：</p><p>​    为了保证实验的完整性，需要把<code>haproxy-master</code>节点中的<code>haproxy</code>服务停止，以实现VIP漂移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-master ~]# systemctl stop haproxy</span><br></pre></td></tr></table></figure><p>检查<code>haproxy-backup</code>节点网卡：</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408131140536.png" alt="image-20240813114045428"></p></blockquote><h2 id="4、Haproxy日志开启"><a href="#4、Haproxy日志开启" class="headerlink" title="4、Haproxy日志开启"></a>4、Haproxy日志开启</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编辑rsyslog配置文件</span></span><br><span class="line">[root@ha-proxy-master ~]# vim /etc/rsyslog.conf </span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides UDP syslog reception  <span class="comment">#由于haproxy的日志是用udp传输的,所以要启用rsyslog的udp监听</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ModLoad imudp</span></span><br><span class="line"><span class="meta">$</span><span class="bash">UDPServerRun 514</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到  <span class="comment">#### RULES ####   下面添加</span></span></span><br><span class="line">local2.*                       /var/log/haproxy.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$ModLoad</span> imudp：ModLoad加载指定模块。imudp：模块名称，用于从 UDP 网络连接中接收日志消息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local2 日志消息的一个分类标识符。在此配置中，local2可能与HAProxy的日志配置相关联。* 是优先级选择器，表示所有优先级的日志消息（从最紧急的emerg到最不重要的debug）都要被记录。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 重启服务</span></span><br><span class="line">[root@ha-proxy-master ~]# systemctl restart rsyslog haproxy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看日志</span></span><br><span class="line">[root@ha-proxy-master ~]# tail -f /var/log/haproxy.log</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408131056007.png" alt="image-20240813105637812"></p><h2 id="5、Haproxy-实现四层负载均衡-了解"><a href="#5、Haproxy-实现四层负载均衡-了解" class="headerlink" title="5、Haproxy 实现四层负载均衡(了解)"></a><strong>5、Haproxy 实现四层负载均衡(了解)</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 两台real server安转mariadb  mariadb-server</span></span><br><span class="line">[root@real-server ~]# yum install -y mariadb-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动mariadb</span></span><br><span class="line">[root@real-server ~]# systemctl enable --now mariadb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 连接数据库</span></span><br><span class="line">[root@real-server ~]# mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改root用户密码和主机地址</span></span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on *.* to root@'%' identified by '123456';</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 刷新权限</span></span><br><span class="line">MariaDB [(none)]&gt; flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 退出DB</span></span><br><span class="line">MariaDB [(none)]&gt; exit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改两台haproxy服务配置文件</span></span><br><span class="line">[root@ha-proxy-master ~]# cat /etc/haproxy/haproxy.cfg</span><br><span class="line">Haproxy L4</span><br><span class="line">========================================================================</span><br><span class="line">global</span><br><span class="line">    log         127.0.0.1 local2</span><br><span class="line">    pidfile     /var/run/haproxy.pid</span><br><span class="line">    maxconn     4000</span><br><span class="line">    user        haproxy</span><br><span class="line">    group       haproxy</span><br><span class="line">    daemon</span><br><span class="line">    nbproc      1</span><br><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    log                     global</span><br><span class="line">    option                  redispatch</span><br><span class="line">    retries                 3</span><br><span class="line">    maxconn                 4000</span><br><span class="line">    contimeout            5000</span><br><span class="line">    clitimeout            50000</span><br><span class="line">srvtimeout            50000</span><br><span class="line">listen stats</span><br><span class="line">    bind*:81</span><br><span class="line">    stats                   enable</span><br><span class="line">    stats uri              /haproxy</span><br><span class="line">    stats auth           qianfeng:123</span><br><span class="line">frontend  web</span><br><span class="line">    mode                   http</span><br><span class="line">    bind                        *:80</span><br><span class="line">    option                  httplog</span><br><span class="line">    default_backend    httpservers</span><br><span class="line">backend httpservers</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    server  http1 192.168.246.162:80 maxconn 2000 weight 1  check inter 1s rise 2 fall 2</span><br><span class="line">    server  http2 192.168.246.163:80 maxconn 2000 weight 1  check inter 1s rise 2 fall 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加已下字段    </span></span><br><span class="line">listen mysql</span><br><span class="line">    bind *:3306</span><br><span class="line">    mode tcp</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server mysql1 192.168.246.163:3306 weight 1  check inter 1s rise 2 fall 2</span><br><span class="line">    server mysql2 192.168.246.162:3306 weight 1  check inter 1s rise 2 fall 2</span><br></pre></td></tr></table></figure><p>最后可以在<a href="http://192.168.174.38:81/haproxy上看到下面会多出一行是MySQL的。" target="_blank" rel="noopener">http://192.168.174.38:81/haproxy上看到下面会多出一行是MySQL的。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Keepalived" scheme="https://l66stbz.github.io/tags/Keepalived/"/>
    
      <category term="LVS" scheme="https://l66stbz.github.io/tags/LVS/"/>
    
      <category term="Haproxy" scheme="https://l66stbz.github.io/tags/Haproxy/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡-LVS</title>
    <link href="https://l66stbz.github.io/2024/08/11/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/"/>
    <id>https://l66stbz.github.io/2024/08/11/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/</id>
    <published>2024-08-11T13:50:00.000Z</published>
    <updated>2024-08-17T07:14:40.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="负载均衡集群"><a href="#负载均衡集群" class="headerlink" title="负载均衡集群"></a>负载均衡集群</h3><p>[TOC]</p><h3 id="1、集群是什么？"><a href="#1、集群是什么？" class="headerlink" title="1、集群是什么？"></a>1、集群是什么？</h3><ul><li>集群（cluster）技术可以在付出<code>较低成本</code>的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其任务调度则是集群系统中的核心技术。</li><li>集群组成后，可以利用多个计算机和组合进行海量请求处理（<strong>负载均衡</strong>），从而获得很高的处理效率，也可以用多个计算机做备份（高可用<code>HA</code>），使得任何一个机器坏了整个系统还是能正常运行。</li></ul><h3 id="2、负载均衡集群技术"><a href="#2、负载均衡集群技术" class="headerlink" title="2、负载均衡集群技术"></a>2、负载均衡集群技术</h3><ul><li>负载均衡（Load Balance）：负载均衡集群为企业需求提供了可解决容量问题的有效方案。负载均衡集群使负载可以在计算机集群中<code>尽可能</code>平均地分摊处理。</li><li>负载通常包括应用程序<code>处理负载</code>和<code>网络流量负载</code>,每个节点都可以承担一定的处理负载，并且可以实现处理负载在节点之间的动态分配，以实现负载均衡。</li></ul><h3 id="3、负载均衡集群技术的实现"><a href="#3、负载均衡集群技术的实现" class="headerlink" title="3、负载均衡集群技术的实现"></a>3、负载均衡集群技术的实现</h3><p>负载均衡（Load Balance）</p><p>负载均衡技术类型：基于 4 层负载均衡技术和基于 7 层负载均衡技术</p><p>负载均衡实现方式：硬件负载均衡设备或者软件负载均衡</p><p>硬件负载均衡产品：<code>F5</code></p><p>软件负载均衡产品： <strong>LVS</strong>（Linux Virtual Server）、 Haproxy、Nginx</p><h3 id="4、实现效果如图"><a href="#4、实现效果如图" class="headerlink" title="4、实现效果如图"></a>4、实现效果如图</h3><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1562677488047.png" alt="1562677488047"></p><h3 id="5、负载均衡分类"><a href="#5、负载均衡分类" class="headerlink" title="5、负载均衡分类"></a>5、负载均衡分类</h3><p>负载均衡根据所采用的设备对象（<strong>软/硬件负载均衡</strong>），应用的OSI网络层次（<strong>网络层次上的负载均衡</strong>），及应用的地理结构（<strong>本地/全局负载均衡</strong>）等来分类。下面着重介绍的是根据应用的 OSI 网络层次来分类的负载均衡类型。</p><h3 id="6、四层负载均衡（基于IP-端口的负载均衡）"><a href="#6、四层负载均衡（基于IP-端口的负载均衡）" class="headerlink" title="6、四层负载均衡（基于IP+端口的负载均衡）"></a>6、四层负载均衡（基于IP+端口的负载均衡）</h3><p>四层负载均衡（Layer 4 Load Balancing）是指在网络通信中，负载均衡设备在网络传输的第四层（传输层，即TCP/UDP层）对数据流进行负载均衡操作。它主要通过分析传输层的源IP地址、目标IP地址、源端口、目标端口等信息来实现负载均衡，从而将网络请求分发到多台服务器上。</p><p><strong>四层负载均衡的特点如下：</strong></p><ol><li>基于IP+端口：四层负载均衡是基于IP地址和端口号的负载均衡，通过发布三层的IP地址（虚拟IP）再加上四层的端口号来实现。</li><li>处理TCP/UDP协议：四层负载均衡通常用于分发TCP和UDP协议的数据流。</li><li>高效转发：由于四层负载均衡工作在传输层，它可以更高效地处理网络流量，减少了应用层（七层）的复杂性。</li></ol><p>四层负载均衡的应用场景包括：</p><ol><li>TCP/UDP协议的负载均衡：对于基于TCP或UDP协议的请求，可以使用四层负载均衡来分发流量。</li><li>端口映射和转发：四层负载均衡可以实现端口映射和端口转发，将外部请求转发到内部服务器的指定端口。</li></ol><p>实现四层负载均衡的有：</p><ul><li>F5：硬件负载均衡器，功能很好，但是成本很高；</li><li>LVS：重量级的四层负载均衡软件；</li><li>haproxy、Nginx：模拟四层、七层转发，较灵活；</li></ul><h3 id="7、七层的负载均衡（基于虚拟的URL或主机IP的负载均衡"><a href="#7、七层的负载均衡（基于虚拟的URL或主机IP的负载均衡" class="headerlink" title="7、七层的负载均衡（基于虚拟的URL或主机IP的负载均衡)"></a>7、七层的负载均衡（基于虚拟的URL或主机IP的负载均衡)</h3><ol><li><p>所谓七层负载均衡，也称为“内容交换”，</p><ol><li><p><strong>七层负载均衡是指在网络通信中，负载均衡设备在网络传输的应用层（OSI模型的第七层）对数据流进行负载均衡操作</strong>。它通过对网络流量进行分析和处理，将请求分发到不同的服务器上，以实现负载均衡。</p><p>七层负载均衡主要基于应用层协议（如HTTP、HTTPS、SMTP等）进行智能的流量分发，从而提高服务器的性能和可靠性。它可以根据应用层协议的内容（如URL、请求头、请求体等）进行更精细的流量分发，确保将请求分发到最适合处理该请求的服务器上。</p><p>七层负载均衡的应用场景包括但不限于Web服务器集群、应用服务器集群。</p></li><li><p>实现七层负载均衡的软件有：</p><ul><li><p>haproxy：天生负载均衡技能，全面支持四层，七层代理，会话保持，标记，路径转移；</p></li><li><p>nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多；</p></li></ul></li></ol></li></ol><h3 id="8、四层负载与七层负载的区别（面试题）"><a href="#8、四层负载与七层负载的区别（面试题）" class="headerlink" title="8、四层负载与七层负载的区别（面试题）"></a>8、四层负载与七层负载的区别（面试题）</h3><p>四层负载均衡和七层负载均衡的主要区别体现在它们工作的网络层次、处理的数据内容以及应用场景上。</p><ol><li>工作的网络层次：四层负载均衡工作在OSI模型的传输层，即TCP/UDP层，主要基于IP地址和端口号进行负载均衡。而七层负载均衡则工作在OSI模型的应用层，即HTTP、HTTPS、SMTP等应用层协议层，能够基于应用层协议的内容进行更精细的流量分发。</li><li>处理的数据内容：四层负载均衡主要处理的是网络传输的IP地址和端口号信息，它可以通过这些信息来决定将请求转发到哪个后端服务器。而七层负载均衡则能够处理应用层协议的内容，如URL、请求头、请求体等，从而根据这些内容进行更精细的流量分发。</li><li>应用场景：四层负载均衡通常用于处理基于TCP或UDP协议的请求，而七层负载均衡则更适用于Web服务器集群、应用服务器集群等场景，它能够根据应用层协议的内容进行智能的流量分发，提高服务器的性能和可靠性。</li></ol><p>此外，两者在以下方面也存在一些差异：</p><ol><li>转发效率：四层负载均衡的转发效率通常比七层负载均衡高，因为它只需要处理IP地址和端口号信息，不需要解析应用层协议的内容。但是，四层负载均衡在处理复杂应用层协议时可能不如七层负载均衡灵活。</li><li>可扩展性：七层负载均衡由于能够处理应用层协议的内容，因此可以更容易地实现一些高级功能，如会话保持、缓存、压缩等。这使得七层负载均衡在构建大规模集群架构时具有更好的可扩展性。</li><li>安全性：七层负载均衡可以基于应用层协议的内容进行安全过滤和防护，如https协议等。而四层负载均衡则通常只提供基本的网络安全功能。</li></ol><h3 id="9、LVS-实现四层负载均衡项目实战"><a href="#9、LVS-实现四层负载均衡项目实战" class="headerlink" title="9、LVS 实现四层负载均衡项目实战"></a>9、LVS 实现四层负载均衡项目实战</h3><h4 id="1、LVS-介绍"><a href="#1、LVS-介绍" class="headerlink" title="1、LVS 介绍"></a>1、LVS 介绍</h4><p>​    官网：<a href="http://www.linuxvirtualserver.org" target="_blank" rel="noopener">www.linuxvirtualserver.org</a></p><p>LVS（Linux Virtual Server）是一个开源的负载均衡器，用于实现网络服务的负载均衡和高可用性。它运行在 Linux 操作系统上，并利用操作系统的网络功能和内核支持来实现负载均衡。LVS 提供了一种低成本、高性能的负载均衡解决方案。</p><p>以下是 LVS 的一些关键特点和优势：</p><ol><li><strong>高可用性</strong>：LVS 可以实现网络服务的高可用性，通过将负载分配到多个后端服务器上，并且提供故障转移和冗余机制，以防止单点故障，并确保服务的连续性。工作在网络4层之上仅作分发之用，这个特点也决定了它在负载均衡软件里的性能最强，稳定性最好，对内存和cpu资源消耗极低。</li><li><strong>灵活的负载均衡算法</strong>：LVS 支持多种负载均衡算法，包括轮询、加权轮询、最少连接、加权最少连接等。管理员可以根据实际需求选择合适的负载均衡算法，以实现最佳的负载均衡效果。</li><li><strong>水平扩展性</strong>：LVS 具有良好的水平扩展性，可以通过添加更多的后端服务器来扩展系统的容量和性能，以应对不断增长的流量和请求。</li><li><strong>高性能</strong>：LVS 的设计注重性能，能够处理大规模的并发连接和高负载，保证了服务的响应速度和吞吐量。单台LVS负载均衡器，可支持上万并发连接。</li></ol><h4 id="2、LVS-不足之处"><a href="#2、LVS-不足之处" class="headerlink" title="2、LVS 不足之处"></a>2、LVS 不足之处</h4><p>​        工作在4层，不支持7层规则修改。</p><h4 id="3、LVS-核心组件和专业术语"><a href="#3、LVS-核心组件和专业术语" class="headerlink" title="3、LVS 核心组件和专业术语"></a>3、LVS 核心组件和专业术语</h4><h5 id="1、核心组件"><a href="#1、核心组件" class="headerlink" title="1、核心组件"></a>1、核心组件</h5><p><strong>IPVSadm</strong>：是用于管理和配置 IPVS 的命令行工具。通过 IPVSadm，管理员可以添加、删除、修改虚拟服务器、后端服务器池和负载均衡规则等配置</p><p><strong>IPVS</strong> 负责实现基于 IP 的负载均衡功能。IPVS 通过拦截和转发网络数据包来实现负载均衡，根据预定义的负载均衡策略将数据包分发到后端的真实服务器上。IPVS 支持多种负载均衡调度算法，包括轮询、加权轮询、最少连接、加权最少连接等。</p><p><strong>LVS模块</strong>：该模块位于Director Server（负载调度器）上，LVS模块的工作类似于一个路由器，它包含完成LVS功能所设定的路由表，通过这些路由表把用户的请求分发给后端的应用服务器（Real Server）。</p><p><strong>Ldirectord监控模块</strong>：该模块也安装在负载调度器上，用于监测各个Real Server服务的健康状况。在Real Server不可用时，Ldirectord会将其从LVS路由表中剔除，待Real Server恢复后再重新加入。</p><h5 id="2、专业术语"><a href="#2、专业术语" class="headerlink" title="2、专业术语"></a>2、专业术语</h5><ul><li><p><strong>VS</strong>：Virtual Server </p><p> 虚拟服务器，是LVS的<code>核心概念</code>之一，代表一个虚拟的网络服务。客户端将请求发送到虚拟服务器的IP地址上，然后LVS根据配置将请求转发到后端的真实服务器。</p></li></ul><ul><li><p><strong>Director, Balancer</strong>   </p><ul><li><p><strong>Director</strong>:</p><ul><li>Director 是 LVS 架构中的中心节点，也称为负载均衡器（Load Balancer）。</li></ul></li><li><p><strong>Balancer</strong> </p><ul><li>Director 扮演了负载均衡器的角色，因此可以将其称为 Balancer。</li></ul></li></ul></li></ul><ul><li><p><strong>RS</strong>：Real Server            </p><p>真实服务器，也称为后端服务器或节点，是实际处理客户端请求的服务器。LVS将请求从虚拟服务器转发到真实服务器上。</p></li></ul><ul><li><p><strong>CIP</strong>: Client IP<br>在 LVS（Linux Virtual Server）中，CIP 可能指的是 “Client IP”，即客户端 IP。</p><p>​                   </p></li><li><p><strong>VIP</strong>：Director Virtual IP<br>“VIP” 指的是 “Virtual IP”，即虚拟 IP。VIP 是 LVS 架构中的一个重要概念，代表了一个虚拟的网络地址，客户端将请求发送到该地址上，然后 LVS 负责将请求转发到后端的真实服务器上。</p></li></ul><ul><li><p><strong>DIP</strong>：Director IP </p><p>DIP 是指 LVS 集群中的负载均衡器（Director）的真实 IP 地址，</p></li></ul><ul><li><strong>RIP</strong>：Real Server IP<br>在 LVS（Linux Virtual Server）中，”RIP” 通常指的是 “Real Server IP”，即真实服务器的 IP 地址。</li></ul><h5 id="3、具体图解"><a href="#3、具体图解" class="headerlink" title="3、具体图解"></a>3、具体图解</h5><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1562677582545.png" alt="1562677582545"></p><h4 id="5、LVS负载均衡四种工作模式"><a href="#5、LVS负载均衡四种工作模式" class="headerlink" title="5、LVS负载均衡四种工作模式"></a>5、<strong>LVS负载均衡四种工作模式</strong></h4><p>1、<strong>NAT模式</strong>（LVS-NAT）</p><p>LVS（Linux Virtual Server）的 NAT模式是一种负载均衡模式，用于在传入的请求和传出的响应之间进行地址转换，从而实现负载均衡和透明的服务访问。</p><p>NAT 模式（即：网络地址映射）其工作原理是：客户端访问LVS时，LVS通过<strong>重写请求报文的目标地址</strong>，且根据预设的调度算法，将请求分派给后端真实服务器，真实服务器接收到请求处理后，发出响应报文也需要通过LVS返回，返回时需要<strong>修改报文的源地址</strong>，然后返回给客户，完成整个负载调度过程</p><ul><li>DNAT：目标地址转换，改变的是目标地址</li><li>SNAT：源地址转换，改变的是源地址</li></ul><p>NAT 模式就是使用 SNAT 和 DNAT 技术完成报的转发，NAT 方式可支持任何的操作系统，以及私有网络，并且只需一个 Internet IP 地址，非常节省成本，但是整个系统的性能受到限制。因为执行 NAT 每次需要重写数据包，有一定的延迟，另外，大部分应用有 80%的数据是从服务器流向客户机，也就是用户的请求非常短，而服务器的回应非常大，对LVS形成很大压力，容易成为瓶颈。</p><ul><li>在NAT模式下，当客户端发送请求到虚拟IP地址（VIP）时，LVS调度器会接收这些请求，并根据配置的调度算法选择一个后端真实服务器（RS）。然后，LVS会修改请求数据包的目的IP地址为选定RS的IP地址，并将数据包转发给该RS。响应数据包在返回给客户端之前，也会经过LVS，LVS将其源IP地址修改为VIP后，再发回给客户端。</li><li><strong>优点</strong>：NAT模式的配置相对简单，不需要VIP和真实服务器处于同一网段内，因此在某些网络环境下更为灵活。此外，由于所有数据包都经过LVS，可以实现更高层次的流量监控和管理。</li></ul><p>缺点：</p><ol><li><strong>性能瓶颈</strong>： NAT 模式需要在负载均衡器上执行地址转换，可能会增加负载均衡器的处理负担，导致性能瓶颈。</li></ol><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564358958845.png" alt="1564358958845"></p><blockquote><ol><li>数据包CIP-&gt;VIP，如果直接将数据包塞给RS，RS会丢弃，因此LVS修改目标地址VIP为RIP（D-NAT），此时数据包变成CIP-&gt;RIP发给RS</li><li>RS处理完成后发送数据包RIP-&gt;CIP，这个数据包直接塞给客户端，客户端是不会收的，因为客户端是发给VIP的，但是回来就变成RIP给客户端的了，客户端也会丢弃，因此LVS修改源地址为VIP（S-NAT），此时数据包变成VIP-&gt;CIP发给客户端</li></ol><p>注意事项：RS应该使用私有地址，DIP和RIP必须在同一个网段内，<strong>RS的网关必须指向DIP</strong>（因为最终给CIP的数据包要扔回给LVS）</p></blockquote><p> 2、<strong>直接路由(Direct Routing)模式（LVS-DR）</strong><br>    LVS（Linux Virtual Server）的 DR（Direct Routing）模式是一种负载均衡模式，它允许负载均衡器将传入的请求直接转发给后端真实服务器，而无需负载均衡器直接参与数据包的转发。</p><p><strong>工作原理</strong>：</p><ol><li>在DR模式下，LVS和RS都配置有VIP，但是RS的VIP配置在lo（回环）接口上，并且禁止ARP（地址解析协议）响应。</li><li>当客户端的请求报文到达LVS后，LVS会修改请求报文的MAC地址为目标RS的MAC地址，并将报文发送给RS。</li><li>RS收到请求报文后，会识别出报文中的VIP地址是自己的，于是处理报文， 报文直接返回给客户端，而不是返回给LVS。</li><li><strong>主要特点</strong>：<ul><li><strong>高性能</strong>：因为RS可以直接响应客户端，不需要经过LVS调度器中转，所以减少了延迟，提高了性能；DR模式无需进行复杂的地址转换配置；</li><li><strong>适用范围</strong>：适用于调度器和后端服务器在同一局域网内的场景，这样能够确保MAC地址的修改有效并且后端服务器能正确接收和处理请求。</li></ul></li></ol><p><strong>缺点</strong>：</p><ol><li><p><strong>不适用于非直连网络</strong>：</p><p>LVS DR模式的工作原理通过改写请求报文的目标MAC地址，将请求直接发送给真实的服务器（Real Server），而真实服务器响应后的处理结果也直接返回给客户端用户。在这种模式下，负载均衡器（Director）和真实服务器必须位于同一个物理网络中，并且要求负载均衡器与真实服务器都有一块网卡连接到同一物理网段上。</p><p>而非直连网络是指两个或多个网络通过路由器或其他网络设备连接，它们之间并不直接相连。在非直连网络中，数据包需要通过路由器进行转发才能到达目标网络。由于LVS DR模式要求负载均衡器和真实服务器在同一物理网络中，因此它无法直接适用于非直连网络。</p></li></ol><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564358987844.png" alt="1564358987844"></p><p>  3、<strong>IP隧道(Tunnel)模式（LVS-TUN）</strong>  </p><p>​    原理：LVS-TUN模式是Linux Virtual Server（LVS）负载均衡技术中的一种工作模式，也被称为IP隧道模式。在这种模式下，LVS调度器（Director）将接收到的客户端请求数据包封装在一个新的IP数据包中，然后转发给后端的应用服务器（Real Server）。Real Server在处理完请求后，直接将响应数据包发送回客户端，无需再次经过LVS调度器。</p><p>LVS-TUN模式的工作原理是在原有的IP报文外再次封装一层IP首部，内部IP首部（源地址为CIP，目标IP为VIP），外层IP首部（源地址为DIP，目标IP为RIP）。这样，通过IP隧道技术，可以将目标为一个IP地址的数据报文封装和转发到另一个IP地址，实现跨网段的负载均衡。</p><p>​    优点：负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户，减少了负载均衡器的大量数据流动。<br>​    缺点：隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议。</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1564359021882.png" alt="1564359021882"></p><p> 4、FULL-NAT模式（双向转换模式）</p><p>原理：LVS（Linux Virtual Server）的双向转换模式通常指的是LVS-FullNAT模式。在这种模式下，LVS（负载均衡器）对进站和出站的数据流量都进行地址转换。具体来说，当客户端发送请求时，LVS会修改请求报文的源地址为目标RS（真实服务器）的IP地址（RIP），并将目标地址修改为LVS的虚拟IP地址（VIP）。当RS处理完请求并返回响应时，LVS会再次修改响应报文的源地址为VIP，目标地址为客户端的IP地址（CIP），然后将响应报文发送给客户端。</p><p>通过请求报文的源地址为DIP，目标为RIP来实现转发：对于响应报文而言，修改源地址为VIP，目标地址为CIP来实现转发：</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/image-20220210140940567.png" alt="image-20220210140940567"></p><h5 id="5、四者的区别"><a href="#5、四者的区别" class="headerlink" title="5、四者的区别"></a><strong>5、四者的区别</strong></h5><p>lvs-nat与lvs-fullnat：请求和响应报文都经由Director</p><p>   　　lvs-nat：RIP的网关要指向DIP</p><p>  　　 lvs-fullnat：双向转换</p><p>lvs-dr与lvs-tun：请求报文要经由Director，但响应报文由RS直接发往Client</p><p>  　　 lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发</p><p>  　　 lvs-tun：通过在原IP报文外封装新IP头实现转发，支持远距离通信</p><h4 id="6、LVS-ipvsadm-命令的使用"><a href="#6、LVS-ipvsadm-命令的使用" class="headerlink" title="6、LVS ipvsadm 命令的使用"></a>6、LVS ipvsadm 命令的使用</h4><h5 id="1、LVS-server安装lvs管理软件"><a href="#1、LVS-server安装lvs管理软件" class="headerlink" title="1、LVS-server安装lvs管理软件"></a>1、LVS-server安装lvs管理软件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ipvsadm</span><br></pre></td></tr></table></figure><p>程序包：ipvsadm（LVS管理工具）</p><p>主程序：/usr/sbin/ipvsadm</p><p>规则保存工具：/usr/sbin/ipvsadm-save  &gt; /path/to/file</p><p>配置文件：/etc/sysconfig/ipvsadm-config</p><h5 id="2、命令选项"><a href="#2、命令选项" class="headerlink" title="2、命令选项"></a>2、命令选项</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-A --add-service #在服务器列表中新添加一条新的虚拟服务器记录</span><br><span class="line">-t #表示为tcp服务</span><br><span class="line">-u #表示为udp服务</span><br><span class="line">-s --scheduler #使用的调度算法， rr | wrr | lc | wlc | lblb | lblcr | dh | sh | sed | nq 默认调度算法是 wlc</span><br><span class="line">例：ipvsadm -A -t 192.168.1.2:80 -s wrr</span><br><span class="line"></span><br><span class="line">-a --add-server  #在服务器表中添加一条新的真实主机记录</span><br><span class="line">-t --tcp-service #说明虚拟服务器提供tcp服务</span><br><span class="line">-u --udp-service #说明虚拟服务器提供udp服务</span><br><span class="line">-r --real-server #真实服务器地址</span><br><span class="line">-m --masquerading #指定LVS工作模式为NAT模式</span><br><span class="line">-w --weight #真实服务器的权值</span><br><span class="line">-g --gatewaying #指定LVS工作模式为直接路由器模式（也是LVS默认的模式）</span><br><span class="line">-i --ip #指定LVS的工作模式为隧道模式</span><br><span class="line">-p #会话保持时间，定义流量呗转到同一个realserver的会话存留时间</span><br><span class="line">例：ipvsadm -a -t 192.168.1.2:80 -r 192.168.2.10:80 -m -w 1</span><br><span class="line"></span><br><span class="line">-E -edit-service #编辑内核虚拟服务器表中的一条虚拟服务器记录。</span><br><span class="line">-D -delete-service #删除内核虚拟服务器表中的一条虚拟服务器记录。</span><br><span class="line">-C -clear #清除内核虚拟服务器表中的所有记录。</span><br><span class="line">-R -restore #恢复虚拟服务器规则</span><br><span class="line">-S -save #保存虚拟服务器规则到标准输出，输出为-R 选项可读的格式</span><br><span class="line">-e -edit-server #编辑一条虚拟服务器记录中的某条真实服务器记录</span><br><span class="line">-d -delete-server #删除一条虚拟服务器记录中的某条真实服务器记录</span><br><span class="line">-L|-l –list #显示内核虚拟服务器表</span><br><span class="line"></span><br><span class="line">--numeric, -n：#以数字形式输出地址和端口号</span><br><span class="line">--exact： #扩展信息，精确值 </span><br><span class="line">--connection，-c： #当前IPVS连接输出</span><br><span class="line">--stats： #统计信息</span><br><span class="line">--rate ： #输出速率信息</span><br><span class="line"></span><br><span class="line">参数也可以从/proc/net/ip_vs*映射文件中查看</span><br><span class="line">-Z –zero #虚拟服务表计数器清零（清空当前的连接数量等）</span><br></pre></td></tr></table></figure><h4 id="7、LVS-负载均衡集群企业级应用实战"><a href="#7、LVS-负载均衡集群企业级应用实战" class="headerlink" title="7、LVS 负载均衡集群企业级应用实战"></a>7、LVS 负载均衡集群企业级应用实战</h4><h6 id="1、准备虚拟机"><a href="#1、准备虚拟机" class="headerlink" title="1、准备虚拟机"></a>1、准备虚拟机</h6><p> 准备 3 台纯净的虚拟机，两台 web 服务器</p><h6 id="2、LVS-server-安装lvs管理软件"><a href="#2、LVS-server-安装lvs管理软件" class="headerlink" title="2、LVS-server 安装lvs管理软件"></a>2、LVS-server 安装lvs管理软件</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-server ~]# yum -y install ipvsadm</span><br></pre></td></tr></table></figure><p>程序包：ipvsadm（LVS管理工具）</p><p>主程序：/usr/sbin/ipvsadm</p><p>规则保存工具：/usr/sbin/ipvsadm-save &gt; /path/to/file</p><p>配置文件：/etc/sysconfig/ipvsadm-config</p><h5 id="3、LVS-DR-模式"><a href="#3、LVS-DR-模式" class="headerlink" title="3、LVS/DR 模式"></a>3、LVS/DR 模式</h5><p>实验说明：<br>1.虚拟机网络使用NAT模式<br>2.DR模式要求Director DIP 和 所有RealServer RIP必须在同一个网段及广播域<br>3.所有节点网关均指定真实网关</p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1568546953134.png" alt="1568546953134">    上图所示：CIP为客户端IP，VIP为负载均衡器虚拟IP，需要和后端提供服务的主机IP地址为一个网段，DIP为负载均衡器的真实主机IP地址。RIP为后端提供服务的主机IP地址。但是在LVS DR模式下，后端主机还需要配置一个VIP，并且绑定在该主机的回环网卡(lo)上，掩码位为32位，用于收到客户端请求后。将数锯直接返回给客户端，无需在经过负载均衡器。</p><p><strong>思考：为什么LVS DR模式需要关闭arp广播？</strong></p><p>为了避免ARP广播导致的冲突，确保流量能够正确地通过LVS进行负载均衡。</p><p><code>ARP</code>广播会产生的问题 当客户端发起访问<code>VIP</code>对应的域名的请求（curl 10.0.0.32）时，根据网络通信原理会产生<code>ARP</code>广播，因为负载均衡器和真实的服务器<code>rs</code>在同一网络并且<code>VIP</code>设置在集群中的每个节点上，此时集群内的真实服务器会尝试回答来自客户端计算机的查找<code>VIP</code>的<code>ARP</code>广播，这就会产生问题，大家都说我是”VIP”。）为了达到负载均衡的目的，在所有<code>real server</code>上要关闭所有<code>arp</code>请求，导致不能响应<code>client</code>发出的<code>arp</code>请求（相当于哑巴），只有<code>lvs</code>可以响应，这样请求就会传到<code>lvs</code>的<code>vip</code>中，这就是为什么要禁止<code>real server</code>的<code>arp</code>请求和响应。因此必须想法办让真实服务器忽略来自客户端计算机的<code>ARP</code>广播请求。</p><p><strong>思考：为什么LVS DR模式下需要开启精准IP地址回包</strong></p><p>当客户端发送请求到VIP时，调度器会根据负载均衡算法选择一台真实服务器，并将请求转发给该服务器。此时，真实服务器需要能够直接响应客户端的请求，而不需要再次通过调度器进行转发。</p><p>为了实现这一点，真实服务器需要开启精准IP地址回包功能。具体来说，当真实服务器处理完客户端的请求后，它会将响应数据包的源IP地址设置为VIP，目标IP地址设置为客户端的IP地址。这样，当数据包返回给客户端时，客户端会认为是直接从VIP接收到的响应，而不是经过某个中间设备（如调度器）转发的。</p><p>如果没有开启精准IP地址回包功能，真实服务器可能会将响应数据包的源IP地址设置为自己的真实IP地址，而不是VIP。这样，当数据包返回给客户端时，客户端会认为响应来自一个不同的IP地址，而不是它最初请求的VIP。这可能导致客户端与服务器之间的通信出现问题，例如连接中断或响应错误。</p><h6 id="2、LVS-DR模式实施-部署"><a href="#2、LVS-DR模式实施-部署" class="headerlink" title="2、LVS/DR模式实施(部署)"></a>2、LVS/DR模式实施(部署)</h6><p>1、准备工作（集群中所有主机）关闭防火墙和selinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">disable</span> --now firewalld</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setenforce 0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/selinux/config</span></span><br></pre></td></tr></table></figure><p>2、Director分发器配置</p><p>配置VIP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-server ~]# ip addr add dev ens33 192.168.174.101/32 #设置VIP</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">ip addr: 这是用于管理网络接口的命令，用于查看和修改网络接口的配置。</span><br><span class="line">add: 这是ip addr命令的一个子命令，用于添加一个新的IP地址到指定的网络接口上。</span><br><span class="line">dev ens33: 这是指定要操作的网络接口的名称。在这个例子中，网络接口的名称是ens33。</span><br><span class="line">192.168.246.101/32: 这是要添加到网络接口上的IP地址和子网掩码。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装ipvsadm</span></span><br><span class="line">[root@lvs-server ~]# yum install -y ipvsadm   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">[root@lvs-server ~]# systemctl enable --now ipvsadm  </span><br><span class="line">注意:启动如果报错: /bin/bash: /etc/sysconfig/ipvsadm: 没有那个文件或目录</span><br><span class="line">需要手动生成文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存 IPVS 的当前配置</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm --save &gt; /etc/sysconfig/ipvsadm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明：</span></span><br><span class="line">--save: 这是ipvsadm的一个选项，用于将当前的ipvsadm配置保存到一个文件中。这个选项会将当前配置的所有规则和设置写入指定的文件。</span><br><span class="line"></span><br><span class="line">/etc/sysconfig/ipvsadm: 这是保存ipvsadm配置的文件路径。/etc/sysconfig目录通常用于存储系统配置文件，而ipvsadm文件则包含了ipvsadm的配置信息。</span><br></pre></td></tr></table></figure><p>定义LVS分发策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-A：添加VIP</span><br><span class="line">-t：用的是tcp协议</span><br><span class="line">-a：添加的是lo的vip地址</span><br><span class="line">-r：转发到realserverip</span><br><span class="line">-s：算法</span><br><span class="line">-L|-l –list #显示内核虚拟服务器表</span><br><span class="line">--numeric, -n：#以数字形式输出地址和端口号</span><br><span class="line">-g --gatewaying #指定LVS工作模式为直接路由器模式DR（也是LVS默认的模式）</span><br><span class="line">-S -save #保存虚拟服务器规则到标准输出，输出为-R 选项可读的格式</span><br><span class="line">rr：轮循</span><br><span class="line">如果添加ip错了，删除命令如下:</span><br><span class="line"><span class="meta">#</span><span class="bash"> ip addr del 192.168.174.101 dev ens33</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清除内核虚拟服务器表中的所有记录。</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -C  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看目前主机存在的规则</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -ln</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -A -t 192.168.174.101:80 -s rr </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一台后端主机，如果用户的请求到VIP的端口上时，转发至后端提供服务的主机上，并且使用LVS的DR模式。</span></span><br><span class="line">[root-@lvs-server ~]# ipvsadm -a -t 192.168.174.101:80 -r 192.168.174.20 -g </span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">  -a:  "add" 的缩写，表示你想添加一个虚拟服务到 IPVS 表中。</span><br><span class="line">  </span><br><span class="line">  -t 192.168.174.101:80: 这部分指定了虚拟服务的 IP 地址和端口。在这种情况下，IP 地址是 192.168.174.101，端口是 80（HTTP 的默认端口）。这意味着所有发送到 192.168.174.101 的 80 端口的流量都将被 IPVS 截取并分发到一组真实服务器。</span><br><span class="line">  </span><br><span class="line">  -r 192.168.174.40: 这部分指定了一个真实服务器的 IP 地址。在这个例子中，真实服务器的 IP 地址是 192.168.174.20。</span><br><span class="line">  </span><br><span class="line">  -g：表示使用 "gatewaying"（或称为直接路由）方法，并且调度算法是默认的（通常是轮询，但具体取决于 IPVS 的配置）。使用直接路由时，LVS 负载均衡器只是将数据包的目标地址更改为真实服务器的地址，并将数据包直接发送到该服务器。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[root@lvs-server ~]# ipvsadm -a -t 192.168.174.101:80 -r 192.168.174.41 -g  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存方式，保存到一个文件中</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -S &gt; /etc/sysconfig/ipvsadm  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">-S：是 --save 的简写形式</span><br><span class="line"></span><br><span class="line">[root@lvs-server ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  192.168.174.101:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.174.40:80            Route   1      1          0         </span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.174.41:80            Route   1      2          0         </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释：</span></span><br><span class="line">TCP 192.168.174.101:80 rr：这是一个虚拟服务器的配置，使用TCP协议，本地地址为192.168.174.101，端口为80，使用轮询（round-robin）调度器</span><br><span class="line"></span><br><span class="line">192.168.174.40:80 Route 1 1 0：这是一个真实服务器的配置，使用路由（Route）转发方式，远程地址为192.168.174.40，端口为80，权重为1，活动连接数为1，非活动连接数为0</span><br><span class="line">    192.168.174.41:80 Route 1 2 0：这是另一个真实服务器的配置，与上一个配置类似，远程地址为192.168.174.41，端口为80，权重为1，活动连接数为2，非活动连接数为0。</span><br><span class="line">    </span><br><span class="line">[root@lvs-server ~]# ipvsadm -L -n   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示统计信息</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -L -n --stats    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">1. Conns    (connections scheduled)  已经转发过的连接数</span><br><span class="line">2. InPkts   (incoming packets)       包个数</span><br><span class="line">3. OutPkts  (outgoing packets)       出包个数</span><br><span class="line">4. InBytes  (incoming bytes)         入流量（字节）  </span><br><span class="line">5. OutBytes (outgoing bytes)         出流量（字节）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 看速率</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -L -n --rate</span><br><span class="line">1. CPS      (current connection rate)   每秒连接数</span><br><span class="line">2. InPPS    (current in packet rate)    每秒的入包个数</span><br><span class="line">3. OutPPS   (current out packet rate)   每秒的出包个数</span><br><span class="line">4. InBPS    (current in byte rate)      每秒入流量（字节）</span><br><span class="line">5. OutBPS   (current out byte rate)     每秒出流量（字节）</span><br></pre></td></tr></table></figure><p>3、所有RS配置</p><p>配置好网站服务器，测试所有RS    #为了测试效果，提供不同的页面（以下两台real-server都操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@real-server1 ~]# vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 两台机器都安装nginx作为后端服务，按顺序添加不同的主机名以示区分</span></span><br><span class="line">[root@real-server1 ~]# yum install -y nginx</span><br><span class="line">[root@real-server1 ~]# echo "real-server1" &gt;&gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">[root@real-server2 ~]# yum install -y nginx</span><br><span class="line">[root@real-server2 ~]# echo "real-server1" &gt;&gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在lo接口上绑定VIP</span></span><br><span class="line">[root@real-server1 ~]# ip addr add dev lo 192.168.174.101/32 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释</span></span><br><span class="line">addr: 这是 ip 命令的一个子命令，用于管理网络接口的地址。</span><br><span class="line"></span><br><span class="line">add: 这个参数告诉 ip addr 命令要添加一个地址到指定的网络接口。</span><br><span class="line"></span><br><span class="line">dev lo: 这部分指定了要操作的网络接口。在这个例子中，lo 是回环接口（loopback interface）的别名，它通常用于本地通信（例如，ping 127.0.0.1）。</span><br><span class="line"></span><br><span class="line">192.168.174.101/32: 这是要添加到 lo 接口的 IP 地址和子网掩码</span><br><span class="line"></span><br><span class="line">[root@real-server2 ~]# ip addr add dev lo 192.168.174.100/32</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> real-server1 忽略arp广播</span></span><br><span class="line">[root@real-server1 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore </span><br><span class="line"><span class="meta">#</span><span class="bash"> real-server1 匹配精确ip地址回包</span></span><br><span class="line">[root@real-server1 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> real-server2 忽略arp广播</span></span><br><span class="line">[root@real-server2 ~]# echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore  </span><br><span class="line"><span class="meta">#</span><span class="bash"> real-server2 匹配精确ip地址回包</span></span><br><span class="line">[root@real-server2 ~]# echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx实例</span></span><br><span class="line">[root@real-server1 ~]# systemctl enable --now nginx</span><br><span class="line">[root@real-server2 ~]# systemctl enable --now nginx</span><br></pre></td></tr></table></figure><blockquote><p> 测试：游览器清楚缓存，<a href="http://192.168.174.101（修改后端nginx服务器的长连接keep-alive）" target="_blank" rel="noopener">http://192.168.174.101（修改后端nginx服务器的长连接keep-alive）</a></p></blockquote><h4 id="8、LVS-NAT模式"><a href="#8、LVS-NAT模式" class="headerlink" title="8、LVS-NAT模式:"></a>8、LVS-NAT模式:</h4><p><strong>环境准备</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.39lvs-server</span><br><span class="line">192.168.174.40real-server01</span><br><span class="line">192.168.174.41real-server02</span><br></pre></td></tr></table></figure><blockquote><p>注意： 此处的环境需要的主机，以自己创建的主机地址为准</p></blockquote><p><strong>所有主机关闭防火墙和SELIUX</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">disable</span> --now firewalld</span><br><span class="line">$ setenforce 0</span><br><span class="line">$ sed -i <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p><strong>查看linux已加载的内核模块</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-server ~]# lsmod | grep ip_vs</span><br></pre></td></tr></table></figure><p>加载与卸载<code>ip_vs</code>内核模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 动态加载ip_vs 模块，这个命令只是临时生效，需要添加到开机启动文件里面</span></span><br><span class="line">[root@lvs-server ~]# modprobe ip_vs  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤模块是否加载成功</span></span><br><span class="line">[root@lvs-server ~]# lsmod | grep ip_vs  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 动态卸载ip_vs模块</span></span><br><span class="line">[root@lvs-server ~]# modprobe -r ip_vs</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动项</span></span><br><span class="line">[root@lvs-server ~]# echo "modprobe ip_vs" &gt;&gt; /etc/rc.local</span><br><span class="line"><span class="meta">#</span><span class="bash"> 自启脚本添加执行权限</span></span><br><span class="line">[root@lvs-server ~]# chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><blockquote><p>添加到开机启动项里面如果不需要这个模块的时候只需要将etc/rc.local里面对应的命令删除掉。但是这样需要重新启动服务器。 可以通过下面的命令立即生效。</p></blockquote><p><strong>LVS-NAT模式：</strong></p><p><img src="https://youngfitfei.oss-cn-beijing.aliyuncs.com/img/1568551568776.png" alt="1568551568776">                                </p><p>建议：先在Real Server安装如nginx（两台机器real-server)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 两台后端服务安装nginx服务</span></span><br><span class="line">[root@real-server1 ~]# vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓存元数据</span></span><br><span class="line">[root@real-server1 ~]# yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装nginx web服务</span></span><br><span class="line">[root@real-server1 ~]# yum install -y nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 准备网页文件</span></span><br><span class="line">[root@real-server01 ~]# echo "real-server1" &gt;&gt; /usr/share/nginx/html/index.html</span><br><span class="line">[root@real-server02 ~]# echo "real-server2" &gt;&gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 两台后端主机启动服务</span></span><br><span class="line">[root@real-server01 ~]# systemctl enable --now nginx</span><br><span class="line">[root@real-server02 ~]# systemctl enable --now nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试网站是否正常访问</span></span><br><span class="line">[root@real-server ~]# curl 主机IP</span><br></pre></td></tr></table></figure><h6 id="2、LVS-NAT模式配置"><a href="#2、LVS-NAT模式配置" class="headerlink" title="2、LVS/NAT模式配置"></a>2、LVS/NAT模式配置</h6><ol><li>RS配置</li></ol><p>设置real-server（提供服务主机）所有服务器的默认网关指向Directory的DIP（负载均衡器主机IP）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果系统没有route 命令请使用如下命令安装</span></span><br><span class="line">[root@real-server1 ~]# yum install -y net-tools</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redl-server01 配置</span></span><br><span class="line">[root@real-server1 ~]# route add default gw 192.168.100.39  dev ens33</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">default：表示这是一个默认路由，即当数据包的目的地不在本地路由表中时，数据包将发送到这个路由所指定的下一跳地址。</span><br><span class="line"></span><br><span class="line">gw 192.168.100.39：指定了网关的地址，也就是数据包的下一跳地址。</span><br><span class="line"></span><br><span class="line">dev ens33：指定了数据包应该通过哪个网络接口发送出去。在这个例子中，数据包将通过名为 ens33 的网络接口发送出去。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redl-server02 配置</span></span><br><span class="line">[root@real-server2 ~]# route add default gw 192.168.100.39  dev ens33</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否添加完成</span></span><br><span class="line">[root@real-server01 ~]# route  -n </span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.174.39  0.0.0.0         UG    0      0        0 ens33</span><br><span class="line">0.0.0.0         192.168.174.2   0.0.0.0         UG    100    0        0 ens33</span><br><span class="line">192.168.174.0   0.0.0.0         255.255.255.0   U     100    0        0 ens33</span><br></pre></td></tr></table></figure><blockquote><p>提示： 上述代码中的IP地址和网卡名称需要和自己的实际创建的一致，<code>注意修改</code>哟！</p></blockquote><ol start="2"><li>Director分发器配置</li></ol><p>先给LVS服务器新添加一块网卡网络模式设置为桥接模式。会自动生成一个ip，作为VIP。</p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240412140045570.png" alt="image-20240412140045570" style="zoom:67%;"><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240412140158353.png" alt="image-20240412140158353" style="zoom:67%;"><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240412140230022.png" alt="image-20240412140230022" style="zoom:67%;"><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240413142305761.png" alt="image-20240413142305761"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启路由转发</span></span><br><span class="line">[root@lvs-server ~]# vim /etc/sysctl.conf </span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启转发功能</span></span><br><span class="line">[root@lvs-server ~]# sysctl -p</span><br></pre></td></tr></table></figure><p>思考题：为什么LVS NAT模式下需要开始路由转发功能？</p><p>主要是因为NAT模式的工作原理决定了数据包需要在负载均衡器上进行地址转换。</p><p>在NAT模式下，当客户端发送一个请求到虚拟IP地址（VIP）时，这个请求首先到达LVS服务器。LVS服务器会修改数据包的目标IP地址，将其更改为后端真实服务器（RealServer）的IP地址，并将修改后的数据包转发给RealServer。这个过程涉及到了IP地址的转换，也就是NAT。</p><p>当RealServer处理完请求并返回响应时，它并不知道最初的请求是发送给VIP的，因此它会直接将响应发送回请求的源IP地址（即客户端的IP地址）。但是，由于RealServer的IP地址与VIP不同，因此这个响应数据包不能直接路由回客户端。此时，LVS服务器需要再次介入，将响应数据包的源IP地址更改为VIP，并将数据包转发给客户端。</p><p>为了实现这个过程，LVS服务器需要开启路由转发功能。这是因为默认情况下，Linux服务器不会转发来自非本地网络的数据包。开启路由转发功能后，LVS服务器就能够接收来自RealServer的响应数据包，并将其转发给客户端了。</p><ol start="3"><li>定义LVS的分发策略（<code>负载均衡器配置</code>）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装ipvsadm</span></span><br><span class="line">[root@lvs-server ~]# yum install -y ipvsadm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置ipvs 路由规则存放文件地址，默认无</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -S &gt; /etc/sysconfig/ipvsadm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动ipvs,并加入开机自启</span></span><br><span class="line">[root@lvs-server ~]# systemctl enable --now ipvsadm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在IPVS服务器中添加一个虚拟IP(VIP)，其IP地址为192.168.246.160，使用tcp协议，端口号为80，并使用轮询算法进行负载均衡。</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -A -t 192.168.43.202:80 -s rr </span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数解释：</span></span><br><span class="line">-A：添加一个新的虚拟服务。</span><br><span class="line"> 192.168.43.202:80：指定虚拟服务(VIP)的 IP 地址和端口号。</span><br><span class="line">-t：使用tcp协议。</span><br><span class="line">-s rr：指定调度算法为轮询（round-robin）。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一台后端主机，如果用户的请求到VIP的端口上时，转发至后端提供服务的主机上，并且使用LVS的NAT模式。</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -a -t 192.168.43.202:80 -r 192.168.174.40 -m  </span><br><span class="line">[root@lvs-server ~]# ipvsadm -a -t 192.168.43.202:80 -r 192.168.174.41 -m  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存配置</span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -S &gt; /etc/sysconfig/ipvsadm  </span><br><span class="line"></span><br><span class="line">[root@lvs-server ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  192.168.50.128:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.246.161:80           Masq    1      1          3         </span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 192.168.246.162:80           Masq    1      1          3         </span></span><br><span class="line">[root@lvs-server ~]# ipvsadm -L -n --stats      // 显示统计信息</span><br><span class="line">[root@lvs-server ~]# ipvsadm -L -n --rate//看速率</span><br></pre></td></tr></table></figure><ol start="4"><li>测试游览器访问：<a href="http://192.168.43.202" target="_blank" rel="noopener">http://192.168.43.202</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="LVS" scheme="https://l66stbz.github.io/tags/LVS/"/>
    
  </entry>
  
  <entry>
    <title>nginx详解+实操_04</title>
    <link href="https://l66stbz.github.io/2024/08/10/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_04/"/>
    <id>https://l66stbz.github.io/2024/08/10/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_04/</id>
    <published>2024-08-10T15:50:00.000Z</published>
    <updated>2024-08-10T10:29:40.342Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h3 id="HTTPS-介绍"><a href="#HTTPS-介绍" class="headerlink" title="HTTPS 介绍"></a>HTTPS 介绍</h3><p>HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近些年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。</p><p>HTTPS是基于HTTP的安全版。以下是HTTPS的一些关键特点：</p><ol><li><strong>保密性</strong>：通过<code>SSL/TLS</code>协议和<code>加密算法</code>，HTTPS保证了数据在传输过程中的<code>保密性</code>，防止数据<code>被窃听</code>。</li><li><strong>完整性</strong>：HTTPS确保数据在传输过程中不被篡改，保持数据的<code>完整性</code>。</li><li><strong>认证</strong>：通过数字证书，HTTPS能够验证通信双方的身份，防止<code>身份伪造</code>。</li><li><strong>加密算法</strong>：HTTPS使用了混合加密算法，即结合了对称加密和非对称加密的优势。。</li><li><strong>握手过程</strong>：在数据传输开始前，HTTPS会进行一个<code>SSL/TLS</code>握手过程，以确保通信双方协商一致的加密参数和密钥。</li><li><strong>性能影响</strong>：虽然HTTPS提供了更高的安全性，但它也可能会对性能产生一定影响，比如增加数据传输的开销。然而，随着技术的进步，这种影响正在逐渐减小。</li></ol><p>HTTPS是一个重要的网络安全措施，它通过<code>加密</code>和<code>身份验证机制</code>来保护数据的安全，防止数据泄露和中间人攻击。随着技术的发展和安全需求的增加，HTTPS已经成为互联网通信的标准做法。</p><h3 id="1、加密算法"><a href="#1、加密算法" class="headerlink" title="1、加密算法"></a>1、加密算法</h3><h4 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1 对称加密"></a>1.1 <code>对称加密</code></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A要给B发送数据---&gt;A做一个对称密钥---&gt;使用密钥给文件加密---&gt;发送加密以后的文件和钥匙---&gt;B拿钥匙解密---&gt;加密和解密都是使用的同一个密钥。</span><br></pre></td></tr></table></figure><p><strong>对称加密的过程涉及使用相同的密钥进行数据的加密和解密</strong>。</p><p>首先，对称加密也称为<code>私钥加密</code>，是一种加密方法，其中发送方和接收方使用同一个密钥来进行数据的加密和解密。这种方法的算法是公开的，而密钥则是保密的，需要通过安全的方式共享给通信的双方。其具有以下特点：</p><ul><li><strong>加密过程</strong>：在加密阶段，发送方会使用特定的加密算法和共享的密钥（私钥）将明文（原始数据）转换成密文（加密后的数据）。这个过程可以表示为：明文 + 加密算法 + 私钥 =&gt; 密文。</li><li><strong>解密过程</strong>：接收方在收到密文后，使用相同的解密算法和密钥将密文还原成明文。解密过程可以表示为：密文 + 解密算法 + 私钥 =&gt; 明文。</li></ul><p>此外，由于加密和解密使用的是<code>同一个密钥</code>，因此这种加密方式称为<code>对称加密</code>。这种方法的优点是<code>加密和解密</code>速度快，适合对大量数据进行加密。然而，它的缺点在于密钥的安全管理较为困难，因为如果密钥被泄露，那么加密的数据就可能被破解。</p><h4 id="1-2-非对称加密-—-公钥加密，私钥解密"><a href="#1-2-非对称加密-—-公钥加密，私钥解密" class="headerlink" title="1.2  非对称加密 —-  公钥加密，私钥解密"></a>1.2  非对称加密 —-  公钥加密，私钥解密</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A要给B发送数据---&gt;B做一对非对称的密钥（公钥、私钥）---&gt;发送公钥给A---&gt;A拿公钥对数据进行加密---&gt;发送加密后的数据给B---&gt;B拿私钥解密</span><br></pre></td></tr></table></figure><p>非对称加密的过程涉及使用一对密钥，即公钥和私钥，其中公钥用于<code>加密数据</code>，私钥用于<code>解密数据</code>。以下是非对称加密的主要步骤：</p><ol><li><strong>密钥生成</strong>：需要生成<code>一对密钥</code>，通常通过计算得到一个公钥和一个私钥。私钥必须<code>保密</code>，而公钥可以安全地公开分发给客户端。</li><li><strong>加密过程</strong>：当需要向某人发送加密信息时，<code>发送方</code>会使用<code>接收方</code>的公钥对信息进行加密。这意味着只有拥有对应私钥的接收方才能解密这些信息。</li><li><strong>解密过程</strong>：接收方收到加密信息后，将使用其<code>私钥</code>对其<code>进行解密</code>，从而获得原始信息。由于私钥是<code>保密</code>的，因此即使信息在传输过程中被拦截，没有私钥的人也无法读取内容。</li><li><strong>安全性</strong>：非对称加密的一个关键优势是解决了密钥配送问题，即不需要通过不安全的通道发送密钥给对方。这是因为即使公钥被泄露，没有对应的私钥也无法解密信息。</li><li><strong>性能考虑</strong>：非对称加密的处理速度通常远<code>低于</code>对称加密，因此它不适合用于加密大量数据。</li></ol><p>非对称加密提供了一种在<code>不安全的环境</code>中安全交换信息的方法，尽管它的性能不如对称加密，但其在保护数据传输的安全性方面发挥着至关重要的作用。</p><h4 id="1-3-哈希算法"><a href="#1-3-哈希算法" class="headerlink" title="1.3 哈希算法"></a>1.3 哈希算法</h4><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多。<strong>它将任意长度的输入数据映射为固定长度输出的数学计算机程序，具有不可逆性、<code>唯一性</code>和高效性等特点</strong>。</p><p>例如：<code>/etc/shadow文件中的用户密码</code></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405101851172.png" alt="image-20240510185105065"></p><ul><li><strong>随机性</strong>：看起来是随机的，以减少潜在的模式识别攻击。</li><li><strong>固定长度</strong>：无论输入数据的长度如何，输出的散列值长度总是固定的。</li></ul><p>例如：MD5 等</p><h4 id="1-4-数字签名"><a href="#1-4-数字签名" class="headerlink" title="1.4 数字签名"></a>1.4 数字签名</h4><p><strong>数字签名是一种电子签名技术，它利用<code>非对称加密</code>和数字摘要技术来验证信息的真实性和完整性</strong>。简单认为人民币上的一道防伪线。</p><p>数字签名的核心在于使用一对非对称密钥，即公钥和私钥。<code>私钥用于生成签名，而公钥用于验证签名</code>。这种机制确保了信息的发送者身份可以被验证，并且信息在传输过程中未被篡改。以下是数字签名的主要特点和功能：</p><p>首先，<strong>数字签名能够验证消息或信息确实来自于发送方</strong>。在HTTPS中，当客户端与服务器进行通信时，服务器会提供一个包含数字签名的证书。这个证书由受信任的第三方机构（如证书颁发机构）签发，并且包含了服务器的公钥和身份信息。客户端会使用证书颁发机构的公钥来验证服务器证书的数字签名，确保证书未被篡改，并且确实是由证书颁发机构授权的服务器所发出的。</p><p>其次，<strong>数字签名还用于确保数据在传输过程中的完整性</strong>。当数据在网络中传输时，可能会被第三方截获并篡改。通过使用<code>哈希函数</code>对数据生成<code>摘要</code>，并用私钥加密这个摘要，形成了数字签名。接收方在收到数据后，会用同样的哈希函数计算数据摘要，并用发送方的公钥解密数字签名得到原始摘要，通过比对这两个摘要，可以确认数据是否在传输过程中被篡改。</p><p>此外，数字签名的使用还有助于防止中间人攻击，即攻击者试图在客户端和服务器之间插入自己的通信，以截获或篡改信息。HTTPS协议通过结合数字签名和SSL/TLS协议，为客户端和服务器之间的通信提供了加密通道，确保了数据传输的安全性。</p><p>数字签名在HTTPS协议中扮演着至关重要的角色，它不仅帮助用户验证他们正在与正确的服务器通信，而且还确保了数据在传输过程中的安全和完整。这些机制共同作用，使得HTTPS成为一种安全可靠的通信协议。</p><hr><h3 id="2、HTTPS-协议介绍"><a href="#2、HTTPS-协议介绍" class="headerlink" title="2、HTTPS 协议介绍"></a>2、HTTPS 协议介绍</h3><p>HTTP 协议（Hyper Text Transfer Protocol，<code>超文本传输协议</code>）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。</p><ul><li>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为<code>HTTP+SSL/TLS</code>， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405101936792.png" alt="1562050089966"></p><ul><li><p>如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS</p><p><strong>SSL/TLS :SSL(Secure Sockets Layer <code>安全套接层</code>),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层为数据通讯进行加密提供安全支持。</strong>     </p><p><strong>SSL协议可分为两层：</strong></p></li><li><p><code>SSL握手协议</code>（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行<code>身份认证</code>、协商加密算法、<code>交换加密密钥</code>等。<strong>相当于连接</strong></p></li><li><p><code>SSL记录协议</code>（SSL Record Protocol）：它建立在可靠的<code>传输协议（如TCP）</code>之上，为高层协议提供<code>数据封装</code>、<code>压缩</code>、<code>加密</code>等基本功能的支持。 <strong>相当于通信</strong> </p></li></ul><p><strong>SSL协议的工作原理是：</strong></p><ul><li>在<code>传输层</code>对数据进行<code>加密</code>，以保护所有应用层协议的数据<code>传输安全</code>。</li><li>使用公开密钥和私有密钥两种加密方法，其中公钥用于加密数据，私钥用于解密数据。</li><li>在应用层协议通信之前完成加密算法、通信密钥的协商以及服务器认证工作，之后应用层协议所传送的数据都会被加密。</li></ul><p><strong>SSL协议提供的服务主要有：</strong> </p><ul><li>身份认证和数据加密。保证数据<code>完整性</code>；</li><li><code>认证用户</code>和服务器，确保数据发送到正确的客户机和服务器；</li><li>加密数据以防止数据中途被窃取后，数据泄露和篡改；</li><li>维护数据的完整性，确保数据在传输过程中不被改变。         </li></ul><h3 id="3、HTTPS-原理"><a href="#3、HTTPS-原理" class="headerlink" title="3、HTTPS 原理"></a>3、HTTPS 原理</h3><h4 id="3-1-HTTP-访问过程"><a href="#3-1-HTTP-访问过程" class="headerlink" title="3.1 HTTP 访问过程"></a>3.1 HTTP 访问过程</h4><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405101918348.png" alt="1562050123147"></p><p>如上图所示，HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“<code>裸奔</code>”在互联网上，所以很容易遭到黑客的攻击，如下：</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405101936630.png" alt="1562050246969"></p><p>可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉。</p><p><strong>所以 HTTP 传输面临的风险有：</strong></p><ul><li><code>窃听风险</code>：黑客可以获知通信内容。</li><li><code>篡改风险</code>：黑客可以修改通信内容。<code>冒充风险</code>：黑客可以冒充他人身份参与通信。</li></ul><h4 id="3-2-Https访问流程"><a href="#3-2-Https访问流程" class="headerlink" title="3.2 Https访问流程"></a>3.2 Https访问流程</h4><p>  <strong>客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：</strong></p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><p>  (8）client与web协商对称加密算法，client生成一个对称加密密钥并使用web公钥加密，发送给web服务器，web服务器使用web私钥解密</p><p>  (9)使用对称加密密钥传输数据，并校验数据的完整性</p><h4 id="3-3-HTTPS相比HTTP的优势"><a href="#3-3-HTTPS相比HTTP的优势" class="headerlink" title="3.3 HTTPS相比HTTP的优势"></a>3.3 HTTPS相比HTTP的优势</h4><p>相比HTTP，HTTPS 传输更加安全， 所有信息都是加密传播，黑客无法窃听。具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 </p><h4 id="3-4-HTTPS-总结"><a href="#3-4-HTTPS-总结" class="headerlink" title="3.4 HTTPS 总结"></a>3.4 HTTPS 总结</h4><p><strong>综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。</strong></p><h4 id="3-5-HTTPS-缺点"><a href="#3-5-HTTPS-缺点" class="headerlink" title="3.5 HTTPS 缺点"></a>3.5 <strong>HTTPS 缺点</strong></h4><ol><li>SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐</li><li>HTTPS 降低用户访问速度（多次握手）</li><li>网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）</li><li>HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密）</li></ol><h3 id="4、Nginx-性能优化"><a href="#4、Nginx-性能优化" class="headerlink" title="4、Nginx 性能优化"></a>4、Nginx 性能优化</h3><p>当我需要进行性能优化时，说明我们服务器无法满足日益增长的业务。性能优化是一个比较大的课题，需要从以下几个方面进行探讨</p><ul><li>当前系统结构瓶颈</li><li>了解业务模式</li><li>性能与安全</li></ul><h4 id="4-1-当前系统结构瓶颈"><a href="#4-1-当前系统结构瓶颈" class="headerlink" title="4.1 当前系统结构瓶颈"></a>4.1 当前系统结构瓶颈</h4><p>首先需要了解的是当前系统瓶颈，用的是什么，跑的是什么业务。里面的服务是什么样子，每个服务最大支持多少并发。比如针对Nginx而言，我们处理静态资源效率最高的瓶颈是多大？</p><p>可以通过查看当前<code>cpu负荷</code>，<code>内存使用率</code>，<code>进程使用率</code>来做简单判断。还可以通过操作系统的一些工具来判断当前系统性能瓶颈，如分析对应的<code>日志</code>，查看<code>请求数量</code>。也可以通过nginx http_stub_status_module模块来查看对应的<code>连接数</code>，<code>总握手次数</code>，<code>总请求数</code>。也可以对线上进行压力测试，来了解当前的系统的性能，并发数，做好性能评估。</p><h4 id="4-2-了解业务模式"><a href="#4-2-了解业务模式" class="headerlink" title="4.2 了解业务模式"></a>4.2 了解业务模式</h4><p>虽然我们是在做性能优化，但还是要熟悉业务，最终目的都是为业务服务的。我们要了解每一个接口业务类型是什么样的业务，比如电子商务抢购模式，这种情况平时流量会很小，但是到了抢购时间，流量一下子就会猛涨。也要了解系统层级结构，每一层在中间层做的是代理还是动静分离，还是后台进行直接服务。需要我们对业务接入层和系统层次要有一个梳理。</p><h4 id="4-3-性能与安全"><a href="#4-3-性能与安全" class="headerlink" title="4.3 性能与安全"></a>4.3 性能与安全</h4><p>性能与安全也是一个需要考虑的因素，往往大家注重性能忽略安全或注重安全又忽略性能。比如说我们在设计防火墙时，如果规则过于全面肯定会对性能方面有影响。如果对性能过于注重在安全方面肯定会留下很大隐患。所以大家要评估好两者的关系，把握好两者的孰重孰轻，以及整体的相关性。权衡好对应的点。</p><h4 id="4-4-系统与Nginx性能优化"><a href="#4-4-系统与Nginx性能优化" class="headerlink" title="4.4 系统与Nginx性能优化"></a>4.4 系统与Nginx性能优化</h4><p>大家对相关的系统瓶颈及现状有了一定的了解之后，就可以根据影响性能方面做一个全体的评估和优化。</p><ul><li>网络（网络流量、是否有丢包，网络的稳定性都会影响用户请求）</li><li>系统（系统负载、饱和、内存使用率、系统的稳定性、硬件磁盘是否有损坏）</li><li>服务（连接优化、内核性能优化、http服务请求优化都可以在nginx中根据业务来进行设置）</li><li>程序（接口性能、处理请求速度、每个程序的执行效率）</li><li>数据库、底层服务</li></ul><p>上面列举出来每一级都会有关联，也会影响整体性能，这里主要关注的是Nginx服务这一层。</p><h5 id="4-4-1-文件句柄"><a href="#4-4-1-文件句柄" class="headerlink" title="4.4.1 文件句柄"></a>4.4.1 文件句柄</h5><p>在linux/unix操作系统中一切皆文件，我们的设备是文件，文件是文件，文件夹也是文件。当我们用户每发起一次请求，就会产生一个文件句柄。文件句柄可以简单的理解为<code>文件句柄就是一个索引</code>。文件句柄就会随着请求量的增多,进程调用频繁增加，那么产生的文件句柄也就会越多。</p><p>系统默认对文件句柄是有限制的，不可能会让一个进程无限制的调用句柄。因为系统资源是有限的，所以我们需要限制每一个服务能够使用多大的文件句柄。操作系统默认使用的文件句柄是1024个句柄。</p><h5 id="4-4-2-设置方式"><a href="#4-4-2-设置方式" class="headerlink" title="4.4.2 设置方式"></a>4.4.2 设置方式</h5><ul><li>系统全局性修改</li><li>用户局部性修改</li><li>进程局部性修改</li></ul><h5 id="4-4-3-系统全局性修改和用户局部性修改"><a href="#4-4-3-系统全局性修改和用户局部性修改" class="headerlink" title="4.4.3 系统全局性修改和用户局部性修改"></a>4.4.3 系统全局性修改和用户局部性修改</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]# vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">*               soft    core            0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">*               hard    rss             10000</span></span><br><span class="line"><span class="meta">#</span><span class="bash">@student        hard    nproc           20</span></span><br><span class="line"><span class="meta">#</span><span class="bash">@faculty        soft    nproc           20</span></span><br><span class="line"><span class="meta">#</span><span class="bash">@faculty        hard    nproc           50</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ftp             hard    nproc           0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">@student        -       maxlogins       4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">root只是针对root这个用户来限制，soft只是发提醒，操作系统不会强制限制,一般的站点设置为一万左右就ok了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单个用户配置</span></span><br><span class="line">root soft nofile 65535</span><br><span class="line">root hard nofile 65535</span><br><span class="line">nginx soft nofile 65535</span><br><span class="line">nginx hard nofile 65535</span><br><span class="line"><span class="meta">#</span><span class="bash"> *代表通配符 所有的用户</span></span><br><span class="line">*    soft nofile 25535</span><br><span class="line">*    hard nofile 25535</span><br></pre></td></tr></table></figure><p>可以看到<code>root</code>和<code>*</code>，root代表是root用户，*代表的是所有用户，后面的数字就是文件句柄大小。大家可以根据个人业务来进行设置。</p><p><strong>4.4.4 进程局部性修改</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]# vim /etc/nginx/nginx.conf</span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1; aut</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile 65535; #进程限制</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; #最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  '$http_user_agent' '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for" '</span><br><span class="line">                      '"$args" "$request_uri"';</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on; </span><br><span class="line">    #tcp_nopush     on; </span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65; </span><br><span class="line"></span><br><span class="line">    #gzip  on; </span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>worker_rlimit_nofile</code> 是在进程上面进行限制。</p><p>是用来设置 NGINX 工作进程打开的文件描述符的限制。文件描述符是操作系统用来跟踪已打开文件的一种机制。这个设置用来确保 NGINX 工作进程能够处理足够数量的并发连接和文件操作。<br>要设置合适的 worker_rlimit_nofile，你可以参考以下步骤：<br>了解系统默认限制：首先，了解你的操作系统默认的文件描述符限制。你可以通过命令 <code>ulimit -n</code> 来查看。如果默认值已经足够高，你可能不需要进行额外的设置。<br>考虑 NGINX 的工作负载：根据你的 NGINX 应用程序的工作负载和预期的并发连接数，决定是否需要增加文件描述符的限制。如果你的 NGINX 应用程序会频繁地打开和关闭文件，或者处理大量的并发连接，可能需要增加限制。<br>设置合适的值：根据系统和应用程序的需求，设置一个合适的值。通常情况下，可以将 worker_rlimit_nofile 设置为操作系统默认限制的两倍或者更高，以确保 NGINX 能够处理预期的并发连接和文件操作。但是，不要将其设置得太高以至于超过操作系统的最大限制。<br>例如，如果你的操作系统默认限制是1024，而你的 NGINX 应用程序预期处理的并发连接数较高，你可以将 worker_rlimit_nofile 设置为 1048 或更高。</p></li><li><p><code>worker_connections</code>是 NGINX 用来限制单个工作进程所能处理的最大并发连接数。</p><p>这个设置应该根据你的服务器硬件配置、预期的并发连接数以及 NGINX 所处理的工作负载来进行调整。<br>一般来说，你可以通过以下步骤来设置合适的 worker_connections：<br>了解硬件配置和预期负载：首先要了解你的服务器硬件配置，包括 CPU、内存和网络带宽。另外，需要预估你的网站或应用程序的预期并发连接数。这可以通过历史数据、用户量估算或者负载测试来确定。<br>计算最大并发连接数：结合你的硬件配置和预期负载，可以计算出你的服务器可以支持的最大并发连接数。这个计算并不是精确的，但是可以给你一个大致的指导。<br>设置合适的 worker_connections：根据你的计算结果和 NGINX 的最佳实践，设置 worker_connections。通常来说，这个值应该略高于你预期的并发连接数，以留有一定的余地，但也不要设置得太高以至于超过服务器硬件的承载能力。<br>例如，如果你的服务器配置为4核8线程CPU，16GB内存，预期的并发连接数为1000个，你可以设置 worker_connections 为 1024 或者稍高一些，比如 2048。但是如果你的服务器硬件配置较低，比如双核CPU和较少内存，你可能需要将 worker_connections 设置得更低一些，以避免性能问题。</p></li></ul><h4 id="4-5-cpu的亲和配置"><a href="#4-5-cpu的亲和配置" class="headerlink" title="4.5 cpu的亲和配置"></a>4.5 cpu的亲和配置</h4><p>cpu的亲和能够使nginx对于不同的work工作进程绑定到不同的cpu上面去。就能够减少在work间不断切换cpu，把进程通常不会在处理器之间频繁迁移，进程迁移的频率小，来减少性能损耗。<a href="https://nginx.org/en/docs/ngx_core_module.html#worker_cpu_affinity" target="_blank" rel="noopener">nginx 亲和配置</a></p><p>查看cpu核心数 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]# cat /proc/cpuinfo|grep "cpu cores"|uniq</span><br></pre></td></tr></table></figure><p>查看cpu使用率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]#top  回车后按 1</span><br></pre></td></tr></table></figure><h5 id="4-5-1-配置worker-processes"><a href="#4-5-1-配置worker-processes" class="headerlink" title="4.5.1 配置worker_processes"></a><strong>4.5.1 配置worker_processes</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]# vim /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">将刚才查看到自己cpu * cpu核心就是worker_processes</span><br><span class="line">worker_processes 2; #根据自己cpu核心数配置/这里也可以设置为auto</span><br></pre></td></tr></table></figure><p>假设 配置是2cpu，每个cpu是8核，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 16;</span><br><span class="line">worker_cpu_affinity 1010101010101010 0101010101010101;</span><br></pre></td></tr></table></figure><p>在nginx 1.9版本之后，就帮我们自动绑定了cpu;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_cpu_affinity auto;</span><br></pre></td></tr></table></figure><h4 id="4-6-nginx通用配置优化"><a href="#4-6-nginx通用配置优化" class="headerlink" title="4.6 nginx通用配置优化"></a><strong>4.6 nginx通用配置优化</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将nginx进程设置为普通用户，为了安全考虑</span></span><br><span class="line">user nginx; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">当前启动的worker进程，官方建议是与系统核心数一致</span></span><br><span class="line">worker_processes 2;</span><br><span class="line"><span class="meta">#</span><span class="bash">方式一，就是自动分配绑定</span></span><br><span class="line">worker_cpu_affinity auto;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">日志配置成warn</span></span><br><span class="line">error_log /var/log/nginx/error.log warn; </span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">针对 nginx 句柄的文件限制</span></span><br><span class="line">worker_rlimit_nofile 35535; # 或者1024的倍数</span><br><span class="line"><span class="meta">#</span><span class="bash">事件模型</span></span><br><span class="line">events &#123;</span><br><span class="line">    #使用epoll内核模型</span><br><span class="line">    use epoll;</span><br><span class="line">    #每一个进程可以处理多少个连接，如果是多核可以将连接数调高 worker_processes * 1024</span><br><span class="line">    worker_connections 10240;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    charset utf-8;  #设置字符集</span><br><span class="line"></span><br><span class="line">    #设置日志输出格式，根据自己的情况设置</span><br><span class="line">    log_format  main  '$http_user_agent' '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for" '</span><br><span class="line">                      '"$args" "$request_uri"';</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;   #对静态资源的处理比较有效</span><br><span class="line">    #tcp_nopush     on;   #如果做静态资源服务器可以打开</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65; </span><br><span class="line"></span><br><span class="line">    ########</span><br><span class="line">    #Gzip module</span><br><span class="line">    gzip  on;    #文件压缩默认可以打开</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>tcp_nopush</code> 是一个 NGINX 配置指令，用于控制 TCP 连接的数据传输方式。当设置为 <code>on</code> 时，它告诉 NGINX 在发送 HTTP 响应时尽可能快地发送响应头部，并且在发送响应体时尽量避免发送小数据包，尽量等待更多的数据再发送。这样做可以减少数据包的数量，提高传输效率。</p></li><li><p><code>sendfile</code> 是一个 NGINX 配置指令，用于控制 NGINX 是否使用 sendfile 系统调用来发送文件。当设置为 <code>on</code> 时，它告诉 NGINX 使用 sendfile 系统调用来直接在内核空间和文件系统之间传输文件，而不需要将文件数据从内核复制到用户空间再发送，这样可以提高文件传输的效率。sendfile 是一种零拷贝（Zero-Copy）技术，它允许操作系统直接从磁盘读取文件并发送到网络，而无需将文件数据在内核空间和用户空间之间复制。这种方法可以减少 CPU 和内存的使用，提高文件传输的效率，并且减少了系统调用的次数。在高负载和高并发的情况下，使用 <code>sendfile on;</code> 可以显著提高 NGINX 的性能和吞吐量。但是，需要注意的是，sendfile 对于小文件的传输可能并不总是最有效的，因为它可能会导致内存碎片和额外的内核开销。总的来说，通常情况下将 <code>sendfile on;</code> 设置为 <code>on</code> 是推荐的做法，特别是在处理大文件和高并发的网络环境下可以提高性能。</p></li><li><p><code>keepalive_timeout</code> 是 NGINX 的一个配置指令，用于设置 HTTP Keep-Alive 连接的超时时间。HTTP Keep-Alive 是一种机制，它允许客户端和服务器之间的 TCP 连接在处理完一个请求后保持打开状态一段时间，以便在该时间段内发送更多的请求。</p><p>当设置 <code>keepalive_timeout</code> 时，你指定了 NGINX 在收到一个 HTTP 请求后，等待客户端发出下一个请求的最长时间。如果在指定的时间内没有收到新的请求，则 NGINX 将关闭该连接。</p><p>在高并发的网络环境中，使用 HTTP Keep-Alive 可以减少 TCP 连接的建立和关闭次数，从而降低服务器的负载，并提高客户端和服务器之间的响应速度。</p><p>通常来说，将 <code>keepalive_timeout</code> 设置为一个合理的值可以有效地平衡服务器资源和客户端响应时间之间的关系。如果设置得太短，可能会导致客户端频繁地重新建立连接，增加了服务器的负载；而设置得太长，则可能会占用服务器资源，导致服务器无法及时释放不再使用的连接。</p><p>根据实际情况，你可以根据以下几点来决定 <code>keepalive_timeout</code> 的值：</p><ol><li><strong>网站或应用程序的性能需求</strong>：根据你的网站或应用程序的性能需求来调整超时时间。如果你的网站需要快速响应客户端请求，你可能需要将超时时间设置得较短；如果你的网站或应用程序是一个长期交互的应用，你可以将超时时间设置得更长一些。</li><li><strong>客户端和网络条件</strong>：考虑客户端和网络条件。如果你的用户处于高延迟或不稳定的网络环境中，你可能需要将超时时间设置得更长，以确保他们有足够的时间发出下一个请求。</li><li><strong>服务器资源</strong>：考虑你的服务器资源情况。如果你的服务器资源有限，你可能需要将超时时间设置得较短，以释放不再使用的连接并释放资源。</li></ol></li><li><p><code>gzip on;</code> 是 NGINX 的一个配置指令，用于启用 HTTP 响应内容的压缩功能。当设置为 <code>on</code> 时，NGINX 将会对 HTTP 响应的内容进行压缩，以减小传输过程中的数据量，提高网站的加载速度，并降低网络带宽的使用。</p><p>启用 gzip 压缩功能可以带来以下好处：</p><ol><li><strong>减小文件大小</strong>：通过压缩 HTTP 响应的内容，可以显著减小传输过程中的数据量，尤其对于文本文件（如 HTML、CSS、JavaScript）效果更为明显。</li><li><strong>提高网站加载速度</strong>：减小文件大小意味着客户端需要下载的数据量更少，从而可以加快网站的加载速度，改善用户体验。</li><li><strong>降低网络带宽的使用</strong>：通过减小传输的数据量，可以降低服务器和网络带宽的使用，节省服务器资源和网络成本。</li></ol><p>虽然启用 gzip 压缩功能可以提高网站的性能和用户体验，但也需要注意以下几点：</p><ul><li><strong>CPU 资源消耗</strong>：对内容进行压缩需要消耗一定的 CPU 资源，特别是在高流量的网络环境中，可能会对服务器的 CPU 负载产生一定影响。因此，在启用 gzip 压缩功能时，需要根据服务器的 CPU 资源和实际负载来进行评估和调整。</li><li><strong>压缩级别</strong>：NGINX 默认使用适中的压缩级别来平衡压缩比和 CPU 消耗。</li></ul></li></ul><h3 id="5、ab接口压力测试工具-扩展"><a href="#5、ab接口压力测试工具-扩展" class="headerlink" title="5、ab接口压力测试工具(扩展)"></a>5、ab接口压力测试工具(扩展)</h3><p>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]# yum install httpd-tools -y</span><br><span class="line">[root@nginx-server ~]# ab -n 2000 -c 2 http://127.0.0.1/</span><br><span class="line">-n 总的请求数</span><br><span class="line">-c 并发数</span><br></pre></td></tr></table></figure><p><strong>1、参数选项</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-n：即requests，用于指定压力测试总共的执行次数</span><br><span class="line">-c：即concurrency，用于指定的并发数</span><br><span class="line">-t：即timelimit，等待响应的最大时间(单位：秒)</span><br><span class="line">-b：即windowsize，TCP发送/接收的缓冲大小(单位：字节)</span><br><span class="line">-p：即postfile，发送POST请求时需要上传的文件，此外还必须设置-T参数</span><br><span class="line">-u：即putfile，发送PUT请求时需要上传的文件，此外还必须设置-T参数</span><br><span class="line">-T：即content-type，用于设置Content-Type请求头信息，例如：application/x-www-form-urlencoded，默认值为text/plain</span><br><span class="line">-v：即verbosity，指定打印帮助信息的冗余级别</span><br><span class="line">-w：以HTML表格形式打印结果</span><br><span class="line">-i：使用HEAD请求代替GET请求</span><br><span class="line">-x：插入字符串作为table标签的属性</span><br><span class="line">-y：插入字符串作为tr标签的属性</span><br><span class="line">-z：插入字符串作为td标签的属性</span><br><span class="line">-C：添加cookie信息，例如："Apache=1234"(可以重复该参数选项以添加多个)</span><br><span class="line">-H：添加任意的请求头，例如："Accept-Encoding: gzip"，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)</span><br><span class="line">-A：添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开</span><br><span class="line">-P：添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开</span><br><span class="line">-X：指定使用的和端口号，例如:"126.10.10.3:88"</span><br><span class="line">-V：打印版本号并退出</span><br><span class="line">-k：使用HTTP的KeepAlive特性</span><br><span class="line">-d：不显示百分比</span><br><span class="line">-S：不显示预估和警告信息</span><br><span class="line">-g：输出结果信息到gnuplot格式的文件中</span><br><span class="line">-e：输出结果信息到CSV格式的文件中</span><br><span class="line">-r：指定接收到错误信息时不退出程序</span><br><span class="line">-H：显示用法信息，其实就是ab -help</span><br></pre></td></tr></table></figure><p><strong>2、内容解释</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Server Software:        nginx/1.10.2 (服务器软件名称及版本信息)</span><br><span class="line">Server Hostname:        192.168.1.106(服务器主机名)</span><br><span class="line">Server Port:            80 (服务器端口)</span><br><span class="line"></span><br><span class="line">Document Path:          /index1.html. (供测试的URL路径)</span><br><span class="line">Document Length:        3721 bytes (供测试的URL返回的文档大小)</span><br><span class="line"></span><br><span class="line">Concurrency Level:      1000 (并发数)</span><br><span class="line">Time taken for tests:   2.327 seconds (压力测试消耗的总时间)</span><br><span class="line">Complete requests:      5000 (的总次数)</span><br><span class="line">Failed requests:        688 (失败的请求数)</span><br><span class="line">Write errors:           0 (网络连接写入错误数)</span><br><span class="line">Total transferred:      17402975 bytes (传输的总数据量)</span><br><span class="line">HTML transferred:       16275725 bytes (HTML文档的总数据量)</span><br><span class="line">Requests per second:    2148.98 [#/sec] (mean) (平均每秒的请求数) 这个是非常重要的参数数值，服务器的吞吐量 </span><br><span class="line">Time per request:       465.338 [ms] (mean) (所有并发用户(这里是1000)都请求一次的平均时间)</span><br><span class="line">Time  request:       0.247 [ms] (mean, across all concurrent requests) (单个用户请求一次的平均时间)</span><br><span class="line">Transfer rate:          7304.41 [Kbytes/sec] received 每秒获取的数据长度 (传输速率，单位：KB/s)</span><br><span class="line">...</span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line"><span class="meta">  50%</span><span class="bash">    347  <span class="comment">## 50%的请求在347ms内返回 </span></span></span><br><span class="line"><span class="meta">  66%</span><span class="bash">    401  <span class="comment">## 60%的请求在401ms内返回 </span></span></span><br><span class="line"><span class="meta">  75%</span><span class="bash">    431</span></span><br><span class="line"><span class="meta">  80%</span><span class="bash">    516</span></span><br><span class="line"><span class="meta">  90%</span><span class="bash">    600</span></span><br><span class="line"><span class="meta">  95%</span><span class="bash">    846</span></span><br><span class="line"><span class="meta">  98%</span><span class="bash">   1571</span></span><br><span class="line"><span class="meta">  99%</span><span class="bash">   1593</span></span><br><span class="line"><span class="meta">  100%</span><span class="bash">   1619 (longest request)</span></span><br></pre></td></tr></table></figure><p><strong>3、示例演示</strong></p><p>注意事项</p><p>● 测试机与被测试机要分开</p><p>● 不要对线上的服务器做压力测试</p><p>● 观察测试工具ab所在机器，以及被测试的机器的CPU、内存、网络等都不超过最高限度的75%</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]# ab -n 50 -c 2 http://www.testpm.cn/</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking www.testpm.cn (be patient).....done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        nginx/1.16.0</span><br><span class="line">Server Hostname:        www.testpm.cn</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        612 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      2</span><br><span class="line">Time taken for tests:   2.724 seconds</span><br><span class="line">Complete requests:      50</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      42250 bytes</span><br><span class="line">HTML transferred:       30600 bytes</span><br><span class="line">Requests per second:    18.35 [#/sec] (mean)</span><br><span class="line">Time per request:       108.968 [ms] (mean)</span><br><span class="line">Time per request:       54.484 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          15.15 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:       42   52  17.3     46     137</span><br><span class="line">Processing:    43   54  20.8     47     170</span><br><span class="line">Waiting:       42   53  20.7     47     170</span><br><span class="line">Total:         84  106  28.9     93     219</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line"><span class="meta">  50%</span><span class="bash">     93</span></span><br><span class="line"><span class="meta">  66%</span><span class="bash">     96</span></span><br><span class="line"><span class="meta">  75%</span><span class="bash">    101</span></span><br><span class="line"><span class="meta">  80%</span><span class="bash">    130</span></span><br><span class="line"><span class="meta">  90%</span><span class="bash">    153</span></span><br><span class="line"><span class="meta">  95%</span><span class="bash">    161</span></span><br><span class="line"><span class="meta">  98%</span><span class="bash">    219</span></span><br><span class="line"><span class="meta">  99%</span><span class="bash">    219</span></span><br><span class="line"><span class="meta"> 100%</span><span class="bash">    219 (longest request)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://l66stbz.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx详解+实操_03</title>
    <link href="https://l66stbz.github.io/2024/08/10/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_03/"/>
    <id>https://l66stbz.github.io/2024/08/10/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_03/</id>
    <published>2024-08-10T13:50:00.000Z</published>
    <updated>2024-08-10T10:29:35.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h2 id="1、Nginx-变量"><a href="#1、Nginx-变量" class="headerlink" title="1、Nginx 变量"></a>1、Nginx 变量</h2><p>Nginx 同 Apache 等其他 Web 服务器的配置记法不太相同，Nginx的配置文件使用语法的就是一门微型的编程语言。可以类似写程序一般编写配置文件，可操作性很大。既然是编程语言，一般也就少不了“变量”这种概念。</p><h3 id="1-1-Nginx变量简介"><a href="#1-1-Nginx变量简介" class="headerlink" title="1.1 Nginx变量简介"></a>1.1 Nginx变量简介</h3><ul><li><p>所有的 Nginx变量在 Nginx 配置文件中引用时都须带上<code>$</code>前缀；</p></li><li><p>在 Nginx 配置中，变量只能存放一种类型的值，有且也只存在一种类型，那就是字符串类型；</p></li><li><p>nginx可以使用变量简化配置与提高配置的灵活性，所有的变量值都可以通过这种方式：</p><ul><li><pre><code class="bash">$变量名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1.2 Nginx 变量的定义和使用</span><br><span class="line"></span><br><span class="line">nginx中的变量分为两种，&#96;自定义变量&#96;与&#96;内置预定义变量&#96;</span><br><span class="line"></span><br><span class="line">#### 1.2.1自定义变量</span><br><span class="line"></span><br><span class="line">**声明变量**</span><br><span class="line">可以在&#96;sever&#96;,&#96;http&#96;,&#96;location&#96;等标签中使用set命令（非唯一）声明变量，语法如下：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">set $变量名 变量值</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>注意:</strong></p><ul><li>nginx 中的变量必须都以$开头</li><li>nginx 的配置文件中所有使用的变量都必须是声明过的，否则 nginx 会无法启动并打印相关异常日志。</li></ul><p><strong>变量的可见性</strong></p><p>在不同层级的标签中声明的变量性的可见性规则如下:</p><ul><li>当前location标签中声明的变量中只对当前location块可以引用；</li><li>当前server标签中声明的变量对当前server块以及当前server块中的所有子块可引用；</li><li>http标签中声明的变量对http块以及http块中的所有子块可见</li></ul><p><strong>nginx安装echo模块</strong></p><p>如果没有安装nginx的话就可以直接按照下列步骤一步步进行，如果已经编译安装过nginx的话，可以对nginx进行平滑升级从而在编译时添加上我们echo模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已经安装的nginx的版本</span></span><br><span class="line">[root@localhost ~]# nginx -V </span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载<span class="built_in">echo</span>模块的安装包</span></span><br><span class="line">[root@localhost ~]# wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压到相同路径下:</span></span><br><span class="line">[root@localhost ~]# tar xf nginx-1.24.0.tar.gz  -C /usr/local/</span><br><span class="line">[root@localhost ~]# tar xf v0.61.tar.gz  -C /usr/local/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装编译工具</span></span><br><span class="line">[root@localhost ~]# cd  /usr/local/</span><br><span class="line">[root@localhost local]# yum -y install pcre pcre-devel openssl openssl-devel gcc gcc-c++   zlib zlib-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加模块：</span></span><br><span class="line">[root@localhost local]# cd nginx-1.24.0/</span><br><span class="line">添加上原来已经有的参数和新添加的模块:</span><br><span class="line">[root@localhost nginx-1.24.0]#  ./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie' --add-module=/usr/local/echo-nginx-module-0.61</span><br><span class="line">[root@localhost nginx-1.24.0]# make &amp;&amp; make install </span><br><span class="line"></span><br><span class="line">[root@localhost nginx-1.24.0]# nginx -V  查看模块是否添加成功</span><br><span class="line">nginx version: nginx/1.24.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) </span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie' --add-module=/usr/local/echo-nginx-module-0.61</span><br><span class="line"></span><br><span class="line">[root@localhost nginx-1.24.0]# useradd nginx# 创建启动用户</span><br><span class="line"></span><br><span class="line">[root@localhost nginx-1.24.0]# mkdir /var/cache/nginx/# 创建缓存目录</span><br><span class="line"></span><br><span class="line">[root@localhost nginx-1.24.0]# nginx# 启动nginx</span><br></pre></td></tr></table></figure><p><strong>配置 $foo=hello</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  cd /etc/nginx/conf.d/</span><br><span class="line">[root@localhost conf.d]# vim echo.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location /test &#123;</span><br><span class="line">                set $foo hello;</span><br><span class="line">                echo "foo: $foo";</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nginx -s reload</span><br><span class="line">[root@localhost ~]# curl localhost/test</span><br><span class="line">foo: hello</span><br></pre></td></tr></table></figure><p><strong>使用大括号插值</strong></p><p>在“变量插值”的上下文中，还有一种特殊情况，即当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location /test-brace &#123;</span><br><span class="line">                set $first "hello ";</span><br><span class="line">                echo "$&#123;first&#125;world";</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location /test-brace &#123;</span><br><span class="line">                set $first "hello";</span><br><span class="line">                echo "$first world";</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nginx -s reload </span><br><span class="line">[root@localhost ~]# curl localhost/test-brace</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>这里，我们在 echo 配置指令的参数值中引用变量 first 的时候，后面紧跟着 world 这个单词，所以如果直接写作 “firstworld” 则 Nginx “变量插值”计算引擎会将之识别为引用了变量 firstworld. 为了解决这个难题，Nginx 的字符串记法支持使用花括号在  之后把变量名围起来，比如这里的 ${first}。</p><p><strong>变量作用域</strong></p><p>set 指令不仅有赋值的功能，它还有创建 Nginx 变量的作用，即当作为赋值对象的变量尚不存在时，它会自动创建该变量。如果我们不创建就直接使用它的值，则会报错。<br> 例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location /bad &#123;</span><br><span class="line">        echo $foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 Nginx 服务器会拒绝加载配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nginx -s reload </span><br><span class="line">nginx: [emerg] unknown "foo" variable</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test failed</span><br></pre></td></tr></table></figure><p>Nginx 变量的创建和赋值操作发生在全然不同的时间阶段，Nginx 变量的创建只能发生在 Nginx 配置加载的时候，或者说 Nginx 启动的时候，而赋值操作则只会发生在请求实际处理的时候。<br> 这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 Nginx 变量。</p><p>Nginx 变量一旦创建，其变量名的可见范围就是整个 Nginx 配置，甚至可以跨越不同虚拟主机的 server 配置块。我们来看一个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location /foo &#123;</span><br><span class="line">                echo "foo = [$foo]";</span><br><span class="line">        &#125;</span><br><span class="line">        location /bar &#123;</span><br><span class="line">                set $foo 32;</span><br><span class="line">                echo "foo = [$foo]";</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# curl 'http://localhost/foo'</span><br><span class="line">foo = []</span><br><span class="line">[root@localhost ~]# curl 'http://localhost/bar'</span><br><span class="line">foo = [32]</span><br></pre></td></tr></table></figure><p>这里我们在 location /bar 中用 set 指令创建了变量 foo，于是在整个配置文件中这个变量都是可见的，因此我们可以在 location /foo 中直接引用这个变量而不用担心 Nginx 会报错。<br> 从这个例子我们可以看到，set 指令因为是在 location /bar 中使用的，所以赋值操作只会在访问 /bar 的请求中执行。而请求 /foo 接口时，我们总是得到空的 foo值，因为用户变量未赋值就输出的话，得到的便是空字符串。</p><p>从这个例子我们可以窥见的另一个重要特性是，Nginx 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰。比如前面我们请求了 /bar 接口后，foo 变量被赋予了值 32，但它丝毫不会影响后续对 /foo 接口的请求所对应的 foo 值（它仍然是空的！），因为各个请求都有自己独立的 $foo 变量的副本。</p><h4 id="1-2-1内置预定义变量"><a href="#1-2-1内置预定义变量" class="headerlink" title="1.2.1内置预定义变量"></a>1.2.1内置预定义变量</h4><p>内置预定义变量即无需声明就可以使用的变量，通常包括一个http请求或响应中一部分内容的值，以下为一些常用的内置预定义变量</p><table><thead><tr><th align="left"><strong>变量名</strong></th><th><strong>定义</strong></th></tr></thead><tbody><tr><td align="left"><code>$arg_PARAMETER</code></td><td>GET请求中变量名PARAMETER参数的值。</td></tr><tr><td align="left"><code>$args</code></td><td>这个变量等于GET请求中的参数。例如，foo=123&amp;bar=blahblah;这个变量只可以被修改</td></tr><tr><td align="left"><code>$binary_remote_addr</code></td><td>二进制码形式的客户端地址。</td></tr><tr><td align="left"><code>$body_bytes_sent</code></td><td>传送页面的字节数</td></tr><tr><td align="left"><code>$content_length</code></td><td>请求头中的Content-length字段。</td></tr><tr><td align="left"><code>$content_type</code></td><td>请求头中的Content-Type字段。</td></tr><tr><td align="left"><code>$cookie_COOKIE</code></td><td>cookie COOKIE的值。</td></tr><tr><td align="left"><code>$document_root</code></td><td>当前请求在root指令中指定的值。</td></tr><tr><td align="left"><code>$document_uri</code></td><td>与$uri相同。</td></tr><tr><td align="left"><code>$host</code></td><td>请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的server名称(处理请求的server的server_name指令的值)。值为小写，不包含端口。</td></tr><tr><td align="left"><code>$hostname</code></td><td>机器名使用 gethostname系统调用的值</td></tr><tr><td align="left"><code>$http_HEADER</code></td><td>HTTP请求头中的内容，HEADER为HTTP请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent的值);</td></tr><tr><td align="left"><code>$sent_http_HEADER</code></td><td>HTTP响应头中的内容，HEADER为HTTP响应中的内容转为小写，-变为_(破折号变为下划线)，例如： <code>$sent_http_cache_control, $sent_http_content_type…;</code></td></tr><tr><td align="left"><code>$is_args</code></td><td>如果$args设置，值为”?”，否则为””。</td></tr><tr><td align="left"><code>$limit_rate</code></td><td>这个变量可以限制连接速率。</td></tr><tr><td align="left"><code>$nginx_version</code></td><td>当前运行的nginx版本号。</td></tr><tr><td align="left"><code>$query_string</code></td><td>与$args相同</td></tr><tr><td align="left"><code>$remote_addr</code></td><td>客户端的IP地址。</td></tr><tr><td align="left"><code>$remote_port</code></td><td>客户端的端口。</td></tr><tr><td align="left"><code>$remote_user</code></td><td>已经经过Auth Basic Module验证的用户名。</td></tr><tr><td align="left"><code>$request_filename</code></td><td>当前连接请求的文件路径，由root或alias指令与URI请求生成。</td></tr><tr><td align="left"><code>$request_body</code></td><td>这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义。</td></tr><tr><td align="left"><code>$request_body_file</code></td><td>客户端请求主体信息的临时文件名。</td></tr><tr><td align="left"><code>$request_completion</code></td><td>如果请求成功，设为”OK”；如果请求未完成或者不是一系列请求中最后一部分则设为空。</td></tr><tr><td align="left"><code>$request_method</code></td><td>这个变量是客户端请求的动作，通常为GET或POST。包括0.8.20及之前的版本中，这个变量总为main request中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作。</td></tr><tr><td align="left"><code>$request_uri</code></td><td>这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI。</td></tr><tr><td align="left"><code>$scheme</code></td><td>所用的协议，比如http或者是https，比如rewrite ^(.+)$ $scheme://example.com$1 redirect;</td></tr><tr><td align="left"><code>$server_addr</code></td><td>服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数。</td></tr><tr><td align="left"><code>$server_name</code></td><td>服务器名称。</td></tr><tr><td align="left"><code>$server_port</code></td><td>请求到达服务器的端口号。</td></tr><tr><td align="left"><code>$server_protocol</code></td><td>请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</td></tr><tr><td align="left"><code>$uri</code></td><td>请求中的当前URI(不带请求参数，参数位于args，不同于浏览器传递的args)，不同于浏览器传递的request_uri的值，它可以通过内部重定向，或者使用index指令进行修改。不包括协议和主机名，例如/foo/bar.html</td></tr></tbody></table><p>Nginx 内置变量最常见的用途就是获取关于请求或响应的各种信息。</p><p><strong>uri  vs request_uri</strong></p><p>由 <code>ngx_http_core</code> 模块提供的内建变量 uri，可以用来获取当前请求的 URI（不含请求参数），<br>而 request_uri 则用来获取请求最原始的 URI（包含请求参数）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location /test-uri &#123;</span><br><span class="line">                echo "uri = $uri";</span><br><span class="line">                echo "request_uri = $request_uri";</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nginx -s reload </span><br><span class="line">[root@localhost ~]# curl localhost/test-uri</span><br><span class="line">uri = /test-uri</span><br><span class="line">request_uri = /test-uri</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# curl "localhost/test-uri?a=3&amp;b=4"</span><br><span class="line">uri = /test-uri</span><br><span class="line">request_uri = /test-uri?a=3&amp;b=4</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# curl "localhost/test-uri/hello%20world?a=3&amp;b=4"</span><br><span class="line">uri = /test-uri/hello world</span><br><span class="line">request_uri = /test-uri/hello%20world?a=3&amp;b=4</span><br></pre></td></tr></table></figure><p><strong>$arg_XXX</strong></p><p>另一个特别常用的内建变量其实并不是单独一个变量，而是有无限多变种的一群变量，即名字以 arg_ 开头的所有变量，我们估且称之为 arg_XXX 变量群。<br> 一个例子是 arg_name，这个变量的值是当前请求中名为 name 的参数的值，而且还是未解码的原始形式的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/echo.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location /test-arg &#123;</span><br><span class="line">        echo "name: $arg_name";</span><br><span class="line">        echo "class: $arg_class";</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nginx -s reload</span><br><span class="line">[root@localhost ~]# curl localhost/test-arg</span><br><span class="line">name: </span><br><span class="line">class: </span><br><span class="line"></span><br><span class="line">[root@localhost ~]# curl "localhost/test-arg?name=Tom&amp;class=3"</span><br><span class="line">name: Tom</span><br><span class="line">class: 3</span><br><span class="line"> </span><br><span class="line">[root@localhost ~]# curl "localhost/test-arg?name=hello%20world&amp;class=9"</span><br><span class="line">name: hello%20world</span><br><span class="line">class: 9</span><br></pre></td></tr></table></figure><p><strong>3、$arg_XXX 不区分大小写</strong></p><p>其实 $arg_name 不仅可以匹配 name 参数，也可以匹配 NAME 参数，抑或是 Name，Nginx 会在匹配参数名之前，自动把原始请求中的参数名调整为全部小写的形式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# curl "localhost/test-arg?NAME=Marry"</span><br><span class="line">name: Marry</span><br><span class="line">class: </span><br><span class="line">[root@localhost ~]# curl "localhost/test-arg?Name=Jimmy&amp;class=DSfef"</span><br><span class="line">name: Jimmy</span><br><span class="line">class: DSfef</span><br></pre></td></tr></table></figure><h2 id="2、Nginx-监控"><a href="#2、Nginx-监控" class="headerlink" title="2、Nginx 监控"></a>2、Nginx 监控</h2><h3 id="2-1-Nginx的基础监控"><a href="#2-1-Nginx的基础监控" class="headerlink" title="2.1 Nginx的基础监控"></a>2.1 Nginx的基础监控</h3><ul><li>进程监控：确保Nginx进程正常运行，没有异常退出或阻塞。</li><li>端口监控：监控Nginx监听的端口状态，确保端口没有被意外占用或关闭。</li></ul><p><strong>注意： 这两个是必须要加在zabbix监控，加触发器有问题及时告警。</strong></p><p>web 服务器 nginx 以其高性能与抗并发能力越来越多的被用户使用</p><p>Nginx 提供了 <code>ngx_http_stub_status_module</code>，<code>ngx_http_reqstat_module</code>模块，这个模块提供了基本的监控功能</p><h3 id="2-2-监控的主要指标"><a href="#2-2-监控的主要指标" class="headerlink" title="2.2 监控的主要指标"></a>2.2 监控的主要指标</h3><p>我们需要对以下主要的指标进行监控：</p><p><strong>基本活跃指标</strong></p><p>Accepts（接受）、Handled（已处理）、Requests（请求数）是一直在增加的计数器。Active（活跃）</p><table><thead><tr><th>名称</th><th>描述</th><th>指标类型</th></tr></thead><tbody><tr><td>Accepts（接受）</td><td>NGINX 所接受的客户端连接数</td><td>资源: 功能</td></tr><tr><td>Handled（已处理）</td><td>成功的客户端连接数</td><td>资源: 功能</td></tr><tr><td>Dropped（已丢弃，计算得出）</td><td>丢弃的连接数（接受 - 已处理）</td><td>工作：错误*</td></tr><tr><td>Requests（请求数）</td><td>客户端请求数</td><td>工作：吞吐量</td></tr></tbody></table><p><strong>每秒请求数 – QPS</strong></p><p>​    监控每秒的请求数量，有助于评估服务器的负载情况，以及及时发现潜在的恶意攻击或服务可用性问题。通过持续的 QPS 监控，可以立刻发现是否被恶意攻击或对服务的可用性进行评估。虽然当问题发生时，通过 QPS 不能定位到确切问题的位置，但是他却可以在第一时间提醒你环境可能出问题了</p><p><strong>服务器错误率</strong></p><p>通过监控固定时间间隔内的错误代码（<code>4XX</code>代码表示客户端错误，<code>5XX</code>代码表示服务器端错误），可以了解到客户端收到的结果是否是正确的错误率突然的飙升很可能是你的网站漏洞发出的信号</p><p> 如果你希望通过 access log 分析错误率，那么你需要配置 nginx 的日志模块，让 nginx 将响应码写入访问日志</p><h3 id="2-3-指标的收集"><a href="#2-3-指标的收集" class="headerlink" title="2.3 指标的收集"></a>2.3 指标的收集</h3><p>通过在编译时加入 <code>nginx</code> 的 <code>ngx_http_stub_status_module</code> 模块我们可以实时监控以下基本的指标：</p><h4 id="2-3-1-nginx-Stub-Status-监控模块"><a href="#2-3-1-nginx-Stub-Status-监控模块" class="headerlink" title="2.3.1 nginx Stub Status 监控模块"></a>2.3.1 nginx Stub Status 监控模块</h4><p>　先使用命令查看是否已经安装这个模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -V大写会显示版本号和模块等信息、v小写仅显示版本信息(yum方式安装的默认好像已经安装此模块，具体以nginx -V查看的为准)</span></span><br><span class="line">[root@localhost ~]# nginx -V</span><br></pre></td></tr></table></figure><p>如果没有此模块，需要重新安装，编译命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure –with-http_stub_status_module</span><br></pre></td></tr></table></figure><p>具体的使用方法是在执行 ./configure 时，指定 –with-http_stub_status_module，然后通过配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location /nginx-status &#123;</span><br><span class="line">                stub_status     on;</span><br><span class="line">                access_log      on;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Nginx 状态查看</strong></p><p>配置完成后在浏览器中输入<a href="http://10.0.105.207/nginx-status" target="_blank" rel="noopener">http://10.0.105.207/nginx-status</a> 查看</p><p>（或者用 <code>curl localhost/nginx-status</code>），显示信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 26 26 48 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1</span><br></pre></td></tr></table></figure><p><strong>Stub Status 参数说明</strong></p><p>　　正常情况下waiting数量是比较多的，并不能说明性能差。如果reading+writing数量比较多说明服务并发有问题。</p><p><img src="/2024/08/10/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_03/1562035977477.png" alt="1562035977477"></p><p>  Active connections:2    #当前nginx处理请求的数目(活跃的连接数)</p><p>server   accepts    handled     requests<br>                 26             26                 48 </p><p> nginx总共处理了26个连接，成功创建26次握手，也就是成功的连接数connection.  总共处理了48个请求 </p><p>   失败连接＝（总连接数－成功连接数）(相等表示中间没有失败的),</p><h3 id="2-4-补充-扩展-："><a href="#2-4-补充-扩展-：" class="headerlink" title="2.4 补充(扩展)："></a>2.4 补充(扩展)：</h3><h5 id="nginx-access-log-分析"><a href="#nginx-access-log-分析" class="headerlink" title="nginx access log 分析"></a>nginx access log 分析</h5><p>nginx 的 access log 中可以记录很多有价值的信息，通过分析 access log，可以收集到很多指标</p><p>1.制作nginx的日志切割，每天凌晨切割并压缩。</p><p>PV：PV(<a href="https://www.baidu.com/s?wd=%E8%AE%BF%E9%97%AE%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">访问量</a>)： 即Page View, 即页面浏览量或<a href="https://www.baidu.com/s?wd=%E7%82%B9%E5%87%BB%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">点击量</a>，用户每次刷新即被计算一次。</p><p>UV：UV(独立访客)：即Unique Visitor,访问您网站的一台<a href="https://www.baidu.com/s?wd=%E7%94%B5%E8%84%91%E5%AE%A2%E6%88%B7%E7%AB%AF&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">电脑客户端</a>为一个访客。00:00-24:00内相同的客户端只被计算一次。</p><p><strong>工作常用(面试题笔试):</strong></p><p>1.根据访问IP统计UV</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;'  access.log|sort | uniq -c |wc -l</span><br></pre></td></tr></table></figure><p>2.统计访问URL统计PV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $7&#125;&#39; access.log|wc -l</span><br></pre></td></tr></table></figure><p>3.查询访问最频繁的URL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $7&#125;&#39; access.log|sort | uniq -c |sort -n -k 1 -r|more</span><br></pre></td></tr></table></figure><p>4.查询访问最频繁的IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $1&#125;&#39; access.log|sort | uniq -c |sort -n -k 1 -r|more</span><br></pre></td></tr></table></figure><p>5.查询访问最频繁的前10的IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;' access.log|sort | uniq -c |sort -n -k 1 -r|head -n 10</span><br></pre></td></tr></table></figure><p>一些常见常用的切割和监控的相关指标和命令的范例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1. 统计2017年9月5日 PV量</span><br><span class="line">   grep '05/Sep/2017' cd.mobiletrain.org.log |wc -l</span><br><span class="line"></span><br><span class="line">2. 8点-9点间</span><br><span class="line">   awk '$4&gt;="[05/Sep/2017:08:00:00" &amp;&amp; $4&lt;="[05/Sep/2017:09:00:00" &#123;print $0&#125;'  sz.mobiletrain.org.log | wc -l</span><br><span class="line"></span><br><span class="line">3. 统计2017年9月5日 一天内访问最多的10个IP（ip top10）</span><br><span class="line">   grep '05/Sep/2017' cd.mobiletrain.org.log | awk '&#123; ips[$1]++ &#125; END&#123;for(i in ips)&#123;print i,ips[i]&#125; &#125; '| sort -k2 -rn | head -n10</span><br><span class="line"></span><br><span class="line">4. 统计2017年9月5日 访问大于100次的IP</span><br><span class="line">   grep '05/Sep/2017' cd.mobiletrain.org.log | awk '&#123; ips[$1]++ &#125; END&#123;for(i in ips)&#123; if(ips[i]&gt;100)  &#123;print i,ips[i]&#125;&#125; &#125; '| sort -k2 -rn | head -n10</span><br><span class="line"></span><br><span class="line">5. 统计2017年9月5日 访问最多的10个页面（$request top 10）</span><br><span class="line">   grep '05/Sep/2017' cd.mobiletrain.org.log |awk '&#123;urls[$7]++&#125; END&#123;for(i in urls)&#123;print urls[i],i&#125;&#125;' |sort -k1 -rn |head -n10</span><br><span class="line"></span><br><span class="line">6. 统计2017年9月5日 每个URL访问内容总大小（$body_bytes_sent）</span><br><span class="line">   grep '05/Sep/2017' sz.mobiletrain.org.log |</span><br><span class="line">   awk '&#123; urls[$7]++; size[$7]+=$10&#125;</span><br><span class="line">   END&#123;for(i in urls)&#123;print urls[i],size[i],i&#125;&#125;'|</span><br><span class="line">   sort -k1 -rn | head -n10</span><br><span class="line"></span><br><span class="line">7. 统计2017年9月5日 每个IP访问状态码数量（$status）</span><br><span class="line">   grep '05/Sep/2017' cd.mobiletrain.org.log | </span><br><span class="line">   awk '&#123; ip_code[$1" "$9]++&#125;</span><br><span class="line">   END&#123; for(i in ip_code)&#123;print i,ip_code[i]&#125; &#125;' | </span><br><span class="line">   sort -k1 -rn | head -n10</span><br><span class="line"></span><br><span class="line">8. 统计2017年9月5日 每个IP访问状态码为404及出现次数（$status）</span><br><span class="line">   grep '05/Sep/2017' cd.mobiletrain.org.log |</span><br><span class="line">    awk '$9=="404"&#123;ccc[$1" "$9]++&#125;</span><br><span class="line">   END&#123;for(i in ccc)&#123;print i,ccc[i]&#125;&#125;'  | </span><br><span class="line">   sort -k3 -rn</span><br><span class="line"></span><br><span class="line">9. 统计前一分钟的PV量</span><br><span class="line"></span><br><span class="line"> date=$(date -d '-1 minute' +%Y:%H:%M);  awk -v date=$date '$0 ~ date&#123;i++&#125;END&#123;print i&#125;' /var/log/nginx/xuleilinux.access.log </span><br><span class="line"></span><br><span class="line">9. 统计2017年9月5日 8:30－9:00，每个IP，出现404状态码的数量</span><br><span class="line">   awk '$4&gt;="[05/Sep/2017:08:30:00" &amp;&amp; </span><br><span class="line"><span class="meta">   $</span><span class="bash">4&lt;=<span class="string">"[05/Sep/2017:09:00:00"</span> </span></span><br><span class="line">   &#123;if($9=="404")&#123;ip_code[$1" "$9]++&#125;&#125;</span><br><span class="line">   END&#123;for(i in ip_code)&#123;print i,ip_code[i]&#125;&#125;' </span><br><span class="line">   sz.mobiletrain.org.log </span><br><span class="line"></span><br><span class="line">10. 统计2017年9月5日 各种状态码数量</span><br><span class="line">    grep '05/Sep/2017' sz.mobiletrain.org.log  | </span><br><span class="line">    awk '&#123;code[$9]++&#125; END&#123;for(i in code)&#123;print i,code[i]&#125;&#125;'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://l66stbz.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx详解+实操_02</title>
    <link href="https://l66stbz.github.io/2024/08/09/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_02/"/>
    <id>https://l66stbz.github.io/2024/08/09/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_02/</id>
    <published>2024-08-09T14:50:00.000Z</published>
    <updated>2024-08-10T10:29:46.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h2 id="1、Nginx-日志配置"><a href="#1、Nginx-日志配置" class="headerlink" title="1、Nginx 日志配置"></a>1、Nginx 日志配置</h2><h3 id="1-1-Nginx-日志介绍"><a href="#1-1-Nginx-日志介绍" class="headerlink" title="1.1 Nginx 日志介绍"></a>1.1 Nginx 日志介绍</h3><p><code>Nginx</code> 有一个非常灵活的日志记录模式,每个级别的配置可以有各自独立的访问日志, 所需日志模块 <code>ngx_http_log_module</code> 的支持，日志格式通过 <code>log_format</code> 命令来定义日志格式，日志对于统计和排错是非常有利的，下面总结了 <code>nginx</code> 日志相关的配置 包括 <code>access_log</code>、<code>rewrite_log</code>、<code>error_log</code>。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062132846.png" alt="image-20240806213223772"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置访问日志，默认存在nginx主配置文件中。</span></span><br><span class="line">access_log path 样式;</span><br></pre></td></tr></table></figure><h3 id="1-2-作用域"><a href="#1-2-作用域" class="headerlink" title="1.2 作用域"></a><strong>1.2 作用域</strong></h3><p>可以应用<code>access_log</code>指令的作用域分别有<code>http</code>，<code>server</code>，<code>location</code>。也就是说，在这几个作用域外使用该指令，Nginx会报错。</p><p>该例子指定日志的写入路径为<code>/var/logs/nginx-access.log</code>，日志格式使用默认的<code>main</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log /var/logs/nginx-access.log main;</span><br></pre></td></tr></table></figure><p>该例子指定日志的写入路径为<code>/var/logs/nginx-access.log</code>，日志格式使用默认的<code>main</code></p><h3 id="1-3-log-format-指令"><a href="#1-3-log-format-指令" class="headerlink" title="1.3 log_format 指令"></a>1.3 log_format 指令</h3><p>Nginx 预定义了名为 <code>main</code> 日志格式，如果没有明确指定日志格式默认使用该格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format main '$remote_addr - $remote_user [$time_local] '</span><br><span class="line">                    '"$request" $status $body_bytes_sent '</span><br><span class="line">                    '"$http_referer" "$http_user_agent"';</span><br></pre></td></tr></table></figure><p>如果不想使用Nginx预定义的格式，可以通过<code>log_format</code>指令来自定义。</p><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_format name [escape=default|json] string ...;</span><br></pre></td></tr></table></figure><ul><li><p><strong>name</strong> 格式名称。在 access_log 指令中引用。</p></li><li><p><strong>escape</strong> 设置变量中的字符编码方式是<code>json</code>还是<code>default</code>，默认是<code>default</code>。</p></li><li><p><strong>string</strong> 要定义的日志格式内容。该参数可以有多个。参数中可以使用Nginx变量。</p></li></ul><p><code>log_format</code> 指令中常用的一些变量：</p><p><img src="/2024/08/09/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_02/C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240807002232734.png" alt="image-20240807002232734"></p><h3 id="1-4-自定义日志格式"><a href="#1-4-自定义日志格式" class="headerlink" title="1.4 自定义日志格式"></a>1.4 自定义日志格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line">                  </span><br><span class="line">access_log /var/logs/nginx-access.log main;</span><br><span class="line">server &#123;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>log_format</code>指令定义了一个<code>main</code>的格式，并在<code>access_log</code>指令中引用了它。假如客户端有发起请求：<code>http://qf.com/</code>，我们看一下我截取的一个请求的日志记录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.0.105.207 - - [01/Jul/2019:10:44:36 +0800] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36" "-"</span><br></pre></td></tr></table></figure><p>我们看到最终的日志记录中<code>$remote_user</code>、<code>$http_referer</code>、<code>$http_x_forwarded_for</code>都对应了一个<code>-</code>，这是因为这几个变量值为空。</p><p>   <strong>面试时：注意日志里面的ip地址一定要在第一列。</strong>    </p><p><strong>自定义nginx访问日志JSON格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 修改nginx主配置文件访问日志格式</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/nginx.conf </span></span><br><span class="line">...</span><br><span class="line">http &#123; </span><br><span class="line"> log_format  test_nginx_json <span class="string">'&#123;"@timestamp":"$time_iso8601",'</span></span><br><span class="line">                                <span class="string">'"host":"$server_addr",'</span></span><br><span class="line">                                <span class="string">'"clientip":"$remote_addr",'</span></span><br><span class="line">                                <span class="string">'"SendBytes":$body_bytes_sent,'</span></span><br><span class="line">                                <span class="string">'"responsetime":$request_time,'</span></span><br><span class="line">                                <span class="string">'"upstreamtime":"$upstream_response_time",'</span></span><br><span class="line">                                <span class="string">'"upstreamhost":"$upstream_addr",'</span></span><br><span class="line">                                <span class="string">'"http_host":"$host",'</span></span><br><span class="line">                                <span class="string">'"uri":"$uri",'</span></span><br><span class="line">                                <span class="string">'"domain":"$host",'</span></span><br><span class="line">                                <span class="string">'"xff":"$http_x_forwarded_for",'</span></span><br><span class="line">                                <span class="string">'"referer":"$http_referer",'</span></span><br><span class="line">                                <span class="string">'"tcp_xff":"$proxy_protocol_addr",'</span></span><br><span class="line">                                <span class="string">'"http_user_agent":"$http_user_agent",'</span></span><br><span class="line">                                <span class="string">'"status":"$status"&#125;'</span>;</span><br><span class="line">access_log  /var/<span class="built_in">log</span>/nginx/access.log  test_nginx_json;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 准备测试主机</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/location.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">  listen   80;</span><br><span class="line">  server_name  tanke.tanke.love;</span><br><span class="line">  access_log /var/<span class="built_in">log</span>/nginx-access.log test_nginx_json;</span><br><span class="line">  location / &#123;</span><br><span class="line">       root /var/www/image/img;</span><br><span class="line">       index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl  reload nginx</span></span><br></pre></td></tr></table></figure><p><strong><code>&quot;@timestamp&quot;:&quot;$time_iso8601&quot;</code></strong></p><ul><li><strong><code>$time_iso8601</code></strong>：以 ISO 8601 格式记录日志的时间戳，例如：<code>2024-08-01T12:34:56+00:00</code>。</li></ul><p><strong><code>&quot;host&quot;:&quot;$server_addr&quot;</code></strong></p><ul><li><strong><code>$server_addr</code></strong>：处理请求的服务器的 IP 地址。</li></ul><p><strong>“<code>clientip&quot;:&quot;$remote_addr&quot;</code></strong></p><ul><li><strong><code>$remote_addr</code></strong>：客户端的 IP 地址。</li></ul><p><strong><code>&quot;SendBytes&quot;:$body_bytes_sent</code></strong></p><ul><li><strong><code>$body_bytes_sent</code></strong>：发送给客户端的响应体的字节数。</li></ul><p><strong><code>&quot;responsetime&quot;:$request_time</code></strong></p><ul><li><strong><code>$request_time</code></strong>：处理请求的总时间（秒）。</li></ul><p><strong><code>&quot;upstreamtime&quot;:&quot;$upstream_response_time&quot;</code></strong></p><ul><li><strong><code>$upstream_response_time</code></strong>：从上游服务器接收响应所花的时间（秒）。如果没有上游请求，则为空。</li></ul><p><strong><code>&quot;upstreamhost&quot;:&quot;$upstream_addr&quot;</code></strong></p><ul><li><strong><code>$upstream_addr</code></strong>：处理请求的上游服务器的 IP 地址。如果没有上游请求，则为空。</li></ul><p><strong><code>&quot;http_host&quot;:&quot;$host&quot;</code></strong></p><ul><li><strong><code>$host</code></strong>：请求的主机名。</li></ul><p><strong><code>&quot;uri&quot;:&quot;$uri&quot;</code></strong></p><ul><li><strong><code>$uri</code></strong>：请求的 URI（不包含请求参数）。</li></ul><p><strong><code>&quot;domain&quot;:&quot;$host&quot;</code></strong></p><ul><li><strong><code>$host</code></strong>：重复字段，与 <code>http_host</code> 相同，表示请求的主机名。可以根据需要去掉一个。</li></ul><p><strong><code>&quot;xff&quot;:&quot;$http_x_forwarded_for&quot;</code></strong></p><ul><li><strong><code>$http_x_forwarded_for</code></strong>：包含客户端 IP 地址的 X-Forwarded-For 头字段。用于代理服务器传递客户端的真实 IP 地址。</li></ul><p><strong><code>&quot;referer&quot;:&quot;$http_referer&quot;</code></strong></p><ul><li><strong><code>$http_referer</code></strong>：包含请求来源的 Referer 头字段。</li></ul><p><strong><code>&quot;tcp_xff&quot;:&quot;$proxy_protocol_addr&quot;</code></strong></p><ul><li><strong><code>$proxy_protocol_addr</code></strong>：当使用代理协议时，客户端的真实 IP 地址。</li></ul><p><strong><code>&quot;http_user_agent&quot;:&quot;$http_user_agent&quot;</code></strong></p><ul><li><strong><code>$http_user_agent</code></strong>：客户端的 User-Agent 头字段，表示客户端的软件信息。</li></ul><p><strong><code>&quot;status&quot;:&quot;$status&quot;</code></strong></p><ul><li><strong><code>$status</code></strong>：响应的 HTTP 状态码。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062210634.png" alt="image-20240806221058582"></p><h3 id="1-5-error-log-指令"><a href="#1-5-error-log-指令" class="headerlink" title="1.5 error_log 指令"></a>1.5 error_log 指令</h3><p>错误日志在Nginx中是通过<code>error_log</code>指令实现的。该指令记录服务器和请求处理过程中的错误信息。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062134943.png" alt="image-20240806213410889"></p><p><strong>语法</strong></p><p>配置错误日志文件的路径和日志级别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error_log file [level];</span><br><span class="line">Default:</span><br><span class="line">error_log logs/error.log warn;</span><br><span class="line"></span><br><span class="line"><span class="comment"># file 参数指定日志的写入位置。</span></span><br><span class="line"><span class="comment"># level 参数指定日志的级别。</span></span><br></pre></td></tr></table></figure><p>level可以是<code>debug</code>, <code>info</code>, <code>notice</code>, <code>warn</code>, <code>error</code>, <code>crit</code>, <code>alert</code>,<code>emerg</code>中的任意值。可以看到其取值范围是按紧急程度从低到高排列的。只有日志的错误级别等于或高于level指定的值才会写入错误日志中。</p><p>Nginx 的错误日志级别有以下几种，并按记录信息量从多到少排列：</p><ol><li><strong>debug</strong>：最详细的日志级别，会记录大量的调试信息，通常用于开发和测试环境，以便开发者能够追踪代码的执行情况。</li><li><strong>info</strong>：此级别记录的信息比 debug 少，但仍然包含了一些有用的状态信息，例如 Nginx 启动或重载配置时的信息。</li><li><strong>notice</strong>：记录的信息更为精简，通常包含一些重要的事件通知，比如完成某个操作或达到某个条件。</li><li><strong>warn</strong>：这个级别记录的是警告信息，表明可能存在的问题，但不是严重错误，例如配置中的语法问题或不建议的做法。</li><li><strong>error</strong>：默认的日志级别，记录错误信息，这些通常是需要管理员注意。</li></ol><p><strong>基本用法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log /var/logs/nginx/nginx-error.log;</span><br></pre></td></tr></table></figure><p>配置段：<code>http</code>,  <code>mail</code>,  <code>stream</code>,  <code>server</code>, <code>location</code>作用域。</p><p>例子中指定了错误日志的路径为：<code>/var/logs/nginx/nginx-error.log</code>，日志级别使用默认的 <code>error</code>。</p><h3 id="1-6-rewrite-log-指令，了解"><a href="#1-6-rewrite-log-指令，了解" class="headerlink" title="1.6 rewrite_log 指令，了解"></a>1.6 rewrite_log 指令，了解</h3><p>由<code>ngx_http_rewrite_module</code>模块提供的。用来记录重写日志的。启用时将在<code>error log</code>中记录重写日志。<br><strong>基本语法:</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rewrite_log on | off;</span><br><span class="line"></span><br><span class="line">默认值: </span><br><span class="line">rewrite_log off;</span><br></pre></td></tr></table></figure><p>配置段:  <code>http</code>,  <code>server</code>, <code>location</code>,  <code>if</code>作用域。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062157279.png" alt="image-20240806215746234"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 配置文件准备</span></span><br><span class="line">rewrite_log on;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">        location /a &#123;</span><br><span class="line">        root /html;</span><br><span class="line">        index   index.html index.htm;</span><br><span class="line">        rewrite .* /b/index.html permanent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /b &#123;</span><br><span class="line">        root    /html;</span><br><span class="line">        index   index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建网站资源路径</span></span><br><span class="line">[root@localhost ~]# mkdir -p /html/&#123;a,b&#125;</span><br><span class="line">[root@localhost ~]# echo "a" &gt; /html/a/index.html</span><br><span class="line">[root@localhost ~]# echo "b" &gt; /html/b/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 检查配置文件语法是否错误,热加载nginx</span></span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 游览器访问http://rewrite.tanke.love/a</span></span><br></pre></td></tr></table></figure><p><strong>查看日志：</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062158375.png" alt="image-20240806215820332"></p><h3 id="1-7-Nginx-日志配置总结"><a href="#1-7-Nginx-日志配置总结" class="headerlink" title="1.7 Nginx 日志配置总结"></a>1.7 Nginx 日志配置总结</h3><p>Nginx中通过<code>access_log</code>和<code>error_log</code>指令配置访问日志和错误日志，通过<code>log_format</code>我们可以自定义日志格式。</p><p>详细的日志配置信息可以参考<a href="https://link.juejin.im/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdocs%2Fvarindex.html">Nginx官方文档</a></p><h3 id="1-8-Nginx的日志"><a href="#1-8-Nginx的日志" class="headerlink" title="1.8 Nginx的日志"></a><strong>1.8 Nginx的日志</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]# rpm -ql nginx |grep log</span><br><span class="line">/etc/logrotate.d/nginx</span><br><span class="line">/var/log/nginx</span><br><span class="line">[root@192 ~]# vim /etc/logrotate.d/nginx</span><br><span class="line">/var/log/nginx/*.log &#123;           #指定需要轮转处理的日志文件</span><br><span class="line">        daily     #日志文件轮转周期，可用值为: daily/weekly/yearly</span><br><span class="line">        missingok               # 忽略错误信息</span><br><span class="line">        rotate 7               # 轮转次数，即最多存储7个归档日志，会删除最久的归档日志</span><br><span class="line">        minsize 5M       #限制条件，大于5M的日志文件才进行分割，否则不操作</span><br><span class="line">        dateext             # 以当前日期作为命名格式</span><br><span class="line">        compress         # 轮循结束后，已归档日志使用gzip进行压缩</span><br><span class="line">        delaycompress    # 与compress共用，最近的一次归档不要压缩</span><br><span class="line">        notifempty         # 日志文件为空，轮循不会继续执行</span><br><span class="line">        create 640 nginx nginx     #新日志文件的权限</span><br><span class="line">        sharedscripts     #有多个日志需要轮询时，只执行一次脚本</span><br><span class="line">        postrotate    # 将日志文件转储后执行的命令。以endscript结尾，命令需要单独成行</span><br><span class="line">                if [ -f /var/run/nginx.pid ]; then    #判断nginx的PID。# 默认logrotate会以root身份运行</span><br><span class="line">                        kill -USR1 `cat /var/run/nginx.pid`</span><br><span class="line">                fi</span><br><span class="line">        endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行命令:</span><br><span class="line">[root@192 nginx]# /usr/sbin/logrotate -f /etc/logrotate.conf</span><br><span class="line">创建计划任务:</span><br><span class="line">[root@192 nginx]# crontab -e</span><br><span class="line">59 23 * * * /usr/sbin/logrotate -f /etc/logrotate.conf</span><br></pre></td></tr></table></figure><h2 id="2、Nginx-的平滑升级"><a href="#2、Nginx-的平滑升级" class="headerlink" title="2、Nginx 的平滑升级"></a>2、Nginx 的平滑升级</h2><h3 id="2-1-为什么要对-nginx-平滑升级"><a href="#2-1-为什么要对-nginx-平滑升级" class="headerlink" title="2.1 为什么要对 nginx 平滑升级"></a>2.1 为什么要对 nginx 平滑升级</h3><p>随着 <code>nginx</code> 越来越流行，并且 <code>nginx</code> 的优势也越来越明显，<code>nginx</code> 的版本迭代也来时加速模式，1.9.0版本的nginx更新了许多新功能，伴随着 <code>nginx</code> 的广泛应用，版本升级必然越来越快，线上业务不能停，此时 <code>nginx</code> 的升级就需要平滑升级。</p><p>nginx 方便地帮助我们实现了平滑升级。其原理简单概括，就是：<br>（1）在不停掉老进程的情况下，启动新进程。<br>（2）老进程负责处理仍然没有处理完的请求，但不再接受处理请求。<br>（3）新进程接受新请求。<br>（4）老进程处理完所有请求，关闭所有连接后，停止。<br>这样就很方便地实现了平滑升级。一般有两种情况下需要升级 nginx，一种是确实要升级 nginx 的版本，另一种是要为 nginx 添加新的模块。</p><h3 id="2-2-Nginx-平滑升级描述"><a href="#2-2-Nginx-平滑升级描述" class="headerlink" title="2.2 Nginx 平滑升级描述"></a>2.2 Nginx 平滑升级描述</h3><h4 id="2-2-1-多进程模式下的请求分配方式"><a href="#2-2-1-多进程模式下的请求分配方式" class="headerlink" title="2.2.1 多进程模式下的请求分配方式"></a><strong>2.2.1 多进程模式下的请求分配方式</strong></h4><p>nginx 默认工作在多进程模式下，即主进程（master process）启动后完成配置加载和端口绑定等动作，<code>fork</code>出指定数量的工作进程（worker process），这些子进程会持有监听端口的文件描述符（fd），并通过在该描述符上添加监听事件来接受连接。</p><h4 id="2-2-2-信号的接收和处理"><a href="#2-2-2-信号的接收和处理" class="headerlink" title="2.2.2 信号的接收和处理"></a><strong>2.2.2 信号的接收和处理</strong></h4><p>nginx 主进程在启动完成后会进入等待状态，负责响应各类系统消息，如SIGCHLD、SIGHUP、SIGUSR2等。</p><h5 id="1-Nginx信号简介"><a href="#1-Nginx信号简介" class="headerlink" title="1. Nginx信号简介"></a><strong>1. Nginx信号简介</strong></h5><p><strong>主进程支持的信号</strong></p><ul><li><code>TERM</code>, <code>INT</code>: 立刻退出</li><li><code>QUIT</code>: 等待工作进程结束后再退出</li><li><code>KILL</code>: 强制终止进程</li><li><code>HUP</code>: 重新加载配置文件，使用新的配置启动工作进程，并逐步关闭旧进程。</li><li><code>USR1</code>: 重新打开日志文件</li><li><code>USR2</code>: 启动新的主进程，实现热升级</li><li><code>WINCH</code>: 逐步关闭工作进程</li></ul><p><strong>工作进程支持的信号</strong></p><ul><li><code>TERM</code>, <code>INT</code>: 立刻退出</li><li><code>QUIT</code>: 等待请求处理结束后再退出</li><li><code>USR1</code>: 重新打开日志文件</li></ul><h3 id="2-3-Nginx-平滑升级实战"><a href="#2-3-Nginx-平滑升级实战" class="headerlink" title="2.3 Nginx 平滑升级实战"></a>2.3 Nginx 平滑升级实战</h3><ol><li><strong>查看现有的 nginx 编译参数</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -V</span><br><span class="line">nginx version: nginx/1.24.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) </span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/local/nginx --group=nginx --user=nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>上传新版本的源码包，解压到/usr/local/</strong></li></ol><p>按照原来的编译参数安装 nginx 的方法进行安装，<strong>只需要到 make，千万不要 make install</strong> 。如果make install 会将原来的配置文件覆盖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar xf nginx-1.25.4.tar.gz  -C /usr/local/</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cd /usr/local/nginx-1.25.4/</span><br><span class="line"></span><br><span class="line">[root@localhost nginx-1.25.4]# ./configure --prefix=/usr/local/nginx --group=nginx --user=nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream</span><br><span class="line"></span><br><span class="line">[root@localhost nginx-1.25.4]# make</span><br></pre></td></tr></table></figure><blockquote><p><strong>==千万不要make install==</strong></p></blockquote><ol start="3"><li><strong>备份原 nginx 二进制文件</strong></li></ol><p>备份老版本nginx二进制启动文件和 nginx 的配置文件（期间nginx不会停止服务）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]# mv /usr/local/nginx/sbin/nginx&#123;,_old&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>b[root@localhost nginx-1.25.4]# cp /usr/local/nginx-1.25.4/objs/nginx /usr/local/nginx/sbin/</p></li><li><p><strong>测试新版本的nginx是否正常</strong></p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]# /usr/local/nginx/sbin/nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>给nginx发送平滑迁移信号（若不清楚pid路径，请查看nginx配置文件）</strong></li></ol><p>USR2: 启动新的主进程，实现热升级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]# kill -USR2 `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>查看nginx pid，会出现一个nginx.pid.oldbin</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]# ll /var/run/nginx.pid*</span><br><span class="line">-rw-r--r--. 1 root root 6 3月  31 21:39 /var/run/nginx.pid</span><br><span class="line">-rw-r--r--. 1 root root 5 3月  31 20:51 /var/run/nginx.pid.oldbin</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>从容关闭旧的Nginx进程(WINCH: 逐步关闭工作work进程)</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]# kill -WINCH `cat /var/run/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure><ol start="9"><li><strong>HUP: 重新加载配置文件，使用新的配置启动工作进程，并逐步关闭旧进程。</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]# kill -HUP `cat /var/run/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure><ol start="10"><li><strong>结束工作进程，完成此次升级</strong></li></ol><p>QUIT: 等待请求处理结束后再退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]#  kill -QUIT `cat /var/run/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure><ol start="11"><li>验证Nginx是否升级成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]# /usr/local/nginx/sbin/nginx -V</span><br><span class="line">nginx version: nginx/1.25.4</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) </span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/local/nginx --group=nginx --user=nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream</span><br></pre></td></tr></table></figure><ol start="12"><li>杀死旧版本的worker 进程 (<code>生产环境勿用</code>)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.25.4]<span class="comment"># ps -ef |grep nginx</span></span><br><span class="line">root      19525      1  0 21:39 ?        00:00:00 nginx: master process ./nginx</span><br><span class="line">nginx     19526  19525  0 21:39 ?        00:00:00 nginx: worker process</span><br><span class="line">nginx     19532      1  0 21:40 ?        00:00:00 nginx: worker process</span><br><span class="line">[root@localhost nginx-1.25.4]<span class="comment"># kill -9 19532</span></span><br></pre></td></tr></table></figure><ol start="12"><li>访问验证</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@web01 objs]# curl  -I localhost</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.25.4</span><br><span class="line">Date: Tue, 06 Aug 2024 15:10:46 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 615</span><br><span class="line">Last-Modified: Fri, 02 Aug 2024 03:32:22 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: "66ac5346-267"</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><h2 id="3、Nginx-错误页面配置"><a href="#3、Nginx-错误页面配置" class="headerlink" title="3、Nginx 错误页面配置"></a>3、Nginx 错误页面配置</h2><p>nginx错误页面包括404 403 500 502 503 504等页面，只需要在server中增加以下配置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen   80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page  404  /404.html;</span><br><span class="line">  location = /404.html &#123;</span><br><span class="line">     root /usr/share/nginx/html;</span><br><span class="line">     index 404.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>/usr/local/nginx/html/ 路径下必须有404.html这个文件！！！代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]# vim 404.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh-CN"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">    &lt;title&gt;404 - 页面未找到&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">            font-family: Arial, sans-serif;</span><br><span class="line">            background-color: #f0f0f0;</span><br><span class="line">            text-align: center;</span><br><span class="line">            padding: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">        h1 &#123;</span><br><span class="line">            font-size: 48px;</span><br><span class="line">            color: #333;</span><br><span class="line">        &#125;</span><br><span class="line">        p &#123;</span><br><span class="line">            font-size: 24px;</span><br><span class="line">            color: #666;</span><br><span class="line">        &#125;</span><br><span class="line">        a &#123;</span><br><span class="line">            color: #0077cc;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">        &#125;</span><br><span class="line">        a:hover &#123;</span><br><span class="line">            text-decoration: underline;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;404&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;抱歉，您访问的页面不存在。&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;a href="/"&gt;返回首页&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果：</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062321416.png" alt="image-20240806232002237"></p><h2 id="4、Nginx-流量控制"><a href="#4、Nginx-流量控制" class="headerlink" title="4、Nginx 流量控制"></a>4、Nginx 流量控制</h2><p><strong>Nginx 的流量控制主要包括连接数限制、请求速率限制和带宽限制，这些机制有助于保护服务器免受过多请求的影响，防止系统因过载而性能下降或崩溃</strong>。</p><p>以下是 Nginx 流量控制的几种方式：</p><ul><li><strong>连接数限制</strong>：通过 <code>limit_conn_zone</code> 模块，可以限制同一 IP 地址的并发连接数。这可以防止单个用户占用过多服务器资源，从而影响其他用户的正常使用。</li><li><strong>请求速率限制</strong>：使用 <code>limit_req</code> 模块，可以限制同一 IP 在特定时间内的请求次数。这种限制可以帮助减缓对服务器的压力，特别是在高流量场景下。</li><li><strong>带宽限制</strong>：通过 <code>limit_rate</code> 指令，可以限制来自同一 IP 地址的数据下载或上传速度。这有助于平衡服务器带宽的使用，确保所有用户都能获得合理的网络速度。</li></ul><p>此外，在配置 Nginx 流量控制时，可以通过编辑配置文件来实现所需的限制规则。例如，可以设置每个 IP 地址每秒只能建立一定数量的新连接，或者每分钟只能发出一定数量的请求。还可以自定义在达到限制条件时的返回错误代码，以便客户端能够理解请求被拒绝的原因。</p><h3 id="4-1-流量限制"><a href="#4-1-流量限制" class="headerlink" title="4.1 流量限制"></a>4.1 流量限制</h3><p>​        <strong>流量限制</strong> (rate-limiting)，用来限制用户在给定时间内HTTP请求的数量。</p><h4 id="4-1-1-Nginx如何限流"><a href="#4-1-1-Nginx如何限流" class="headerlink" title="4.1.1 Nginx如何限流"></a>4.1.1 Nginx如何限流</h4><p>Nginx的”流量限制”使用漏桶算法(leaky bucket algorithm)，用以处理带宽有限时的突发情况。就好比，一个桶口在倒水，桶底在漏水的水桶。如果桶口倒水的速率大于桶底的漏水速率，桶里面的水将会溢出；同样，在请求处理方面，水代表来自客户端的请求，水桶代表根据”先进先出调度算法”等待被处理的请求队列，桶底漏出的水代表离开缓冲区被服务器处理的请求，桶口溢出的水代表被丢弃和不被处理的请求。</p><h4 id="4-1-2-基本限流配置"><a href="#4-1-2-基本限流配置" class="headerlink" title="4.1.2 基本限流配置"></a>4.1.2 基本限流配置</h4><p>“流量限制”配置两个主要的指令，<code>limit_req_zone</code>和<code>limit_req</code>，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 192.168.174.20 代理服务器配置</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/limit_server.conf </span><br><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;</span><br><span class="line">upstream myweb &#123;</span><br><span class="line">        server 192.168.174.21:80;</span><br><span class="line">        &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        location /login &#123;</span><br><span class="line">                limit_req zone=mylimit;</span><br><span class="line">                proxy_pass http://myweb;</span><br><span class="line">                proxy_set_header Host $host:$server_port;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 192.168.174.21后端服务器配置:</span></span><br><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/localtion_server.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location /login &#123;</span><br><span class="line">                root    /usr/share/nginx/html;</span><br><span class="line">                index   index.html index.html;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mkdir /usr/share/nginx/html/login</span><br><span class="line">[root@localhost ~]# echo "login" &gt; /usr/share/nginx/html/login/index.html</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br></pre></td></tr></table></figure><ul><li><strong>$binary_remote_addr</strong>：表示客户端的 IP 地址，二进制格式的表示方式，节省内存。</li><li><strong>zone=mylimit:10m</strong>：定义一个名为 <code>mylimit</code> 的共享内存区域，大小为 10MB，用于存储限速信息。10MB 可以存储大约16万个客户端的速率限制数据。</li><li><strong>rate=1r/s</strong>：设置速率限制为每秒1个请求。</li></ul><p>创建一个速率限制区域，用于记录客户端 IP 地址及其请求速率，并限制每个 IP 地址每秒只能发送1个请求。</p><h4 id="4-1-3-处理突发请求"><a href="#4-1-3-处理突发请求" class="headerlink" title="4.1.3 处理突发请求"></a>4.1.3 处理突发请求</h4><p>如果我们在1000毫秒内接收到2个请求，怎么办？对于第二个请求，Nginx将给客户端返回错误。这可能并不是我们想要的结果，因为应用本质上趋向于突发性。相反地，我们希望缓冲任何超额的请求，然后及时地处理它们。我们更新下配置，在<code>limit_req</code>中使用<code>burst</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/limit_server.conf </span><br><span class="line"><span class="meta">#</span><span class="bash"> 针对单个用户</span></span><br><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;</span><br><span class="line">        upstream myweb &#123;</span><br><span class="line">                server 192.168.174.21:80;</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">        server &#123;</span><br><span class="line">                listen 80;</span><br><span class="line">                server_name localhost;</span><br><span class="line">                location /login &#123;</span><br><span class="line">                        limit_req zone=mylimit burst=20;</span><br><span class="line">                        proxy_pass http://myweb;</span><br><span class="line">                        proxy_set_header Host $host:$server_port;</span><br><span class="line">                        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br></pre></td></tr></table></figure><p><code>burst</code>参数定义了超出zone指定速率的情况下(假设速率限制在每秒1个请求，或每100毫秒一个请求)，客户端还能发起多少请求。上一个请求100毫秒内到达的请求将会被放入队列，我们将队列大小设置为20。</p><p>这意味着，如果从一个给定IP地址发送21个请求，Nginx会立即将第一个请求发送到上游服务器群，然后将余下20个请求放在队列中。然后每100毫秒转发一个排队的请求，只有当传入请求使队列中排队的请求数超过20时，Nginx才会向客户端返回错误。</p><h3 id="4-2-配置流量控制相关功能"><a href="#4-2-配置流量控制相关功能" class="headerlink" title="4.2 配置流量控制相关功能"></a>4.2 配置流量控制相关功能</h3><h4 id="4-2-1-配置日志记录"><a href="#4-2-1-配置日志记录" class="headerlink" title="4.2.1 配置日志记录"></a>4.2.1 配置日志记录</h4><p>默认情况下，Nginx会在日志中记录由于流量限制而延迟或丢弃的请求，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024/08/06 23:45:20 [error] 1888#1888: *34 limiting requests, excess: 0.061 by zone "mylimit", client: 192.168.174.1, server: localhost, request: "GET /login/ HTTP/1.1", host: "192.168.174.20"</span><br></pre></td></tr></table></figure><p>日志条目中包含的字段：</p><ul><li><code>limiting requests</code> -Nginx 拒绝了该请求。</li><li><code>excess</code> - 表示请求超过速率限制的程度。在这种情况下，超出了 0.061 秒。</li><li><code>zone</code> - 使用 <code>mylimit</code> 速率限制区域。</li><li><code>client</code> - 发起请求的客户端IP地址</li><li><code>server</code> - 服务器IP地址或主机名</li><li><code>request</code> - 客户端发起的实际HTTP请求</li><li><code>host</code> - 请求的主机名</li></ul><p>默认情况下，Nginx以<code>error</code>级别来记录被拒绝的请求，如上面示例中的<code>[error]</code>所示(Nginx以较低级别记录延时请求，一般是<code>info</code>级别)。如要更改Nginx的日志记录级别，需要使用<code>limit_req_log_level</code>指令。这里，我们将被拒绝请求的日志记录级别设置为<code>warn</code>：</p><p>一定要定义日志位置和级别才可以：</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062349555.png" alt="image-20240806234906526"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/limit_server.conf </span><br><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;</span><br><span class="line">        upstream myweb &#123;</span><br><span class="line">                server 192.168.174.21:80;</span><br><span class="line">                &#125;</span><br><span class="line">        server &#123;</span><br><span class="line">                listen 80;</span><br><span class="line">                server_name localhost;</span><br><span class="line"></span><br><span class="line">                location /login &#123;</span><br><span class="line">                        limit_req zone=mylimit;</span><br><span class="line">                        limit_req_log_level warn; # 修改日志级别为警告，默认错误级别</span><br><span class="line">                        proxy_pass http://myweb;</span><br><span class="line">                        proxy_set_header Host $host:$server_port;</span><br><span class="line">                        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062349209.png" alt="image-20240806234918164"></p><h4 id="4-2-1-发送到客户端的错误代码"><a href="#4-2-1-发送到客户端的错误代码" class="headerlink" title="4.2.1 发送到客户端的错误代码"></a>4.2.1 发送到客户端的错误代码</h4><p>一般情况下，客户端超过配置的流量限制时，Nginx响应状态码为<strong>503(Service Temporarily Unavailable)</strong>。可以使用<code>limit_req_status</code>指令来设置为其它状态码(例如下面的<strong>404</strong>状态码):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/limit_server.conf </span><br><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;</span><br><span class="line">upstream myweb &#123;</span><br><span class="line">        server 192.168.174.21:80;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name www.tanke.love;</span><br><span class="line"></span><br><span class="line">        location /login &#123;</span><br><span class="line">limit_req zone=mylimit;</span><br><span class="line">limit_req_log_level warn;</span><br><span class="line">limit_req_status 404; # 自定义返回状态码</span><br><span class="line">            proxy_pass http://myweb;</span><br><span class="line">            proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br></pre></td></tr></table></figure><h2 id="5、Nginx-访问控制"><a href="#5、Nginx-访问控制" class="headerlink" title="5、Nginx 访问控制"></a>5、Nginx 访问控制</h2><h3 id="5-1-nginx-访问控制模块"><a href="#5-1-nginx-访问控制模块" class="headerlink" title="5.1 nginx 访问控制模块"></a>5.1 nginx 访问控制模块</h3><ol><li><code>ngx_http_access_module</code>：这是Nginx中最基本的访问控制模块，允许根据客户端的IP地址、请求方法、请求URI等信息来控制访问权限。可以设置allow指令来允许特定IP或IP段访问，使用deny指令来禁止某些IP或IP段访问。</li><li><code>ngx_http_auth_request_module</code>：这个模块提供了基于HTTP基本认证的访问控制。通过设置用户名和密码，可以限制未授权的用户访问特定的资源或路径。</li></ol><h3 id="5-2-基于IP的访问控制"><a href="#5-2-基于IP的访问控制" class="headerlink" title="5.2 基于IP的访问控制"></a>5.2 基于IP的访问控制</h3><p>​    基于IP的访问控制是Nginx中实现访问控制的一种方式，主要通过内置的<code>ngx_http_access_module</code>模块来实现。这个模块允许你根据客户端的IP地址来控制对服务器资源的访问权限。</p><p>以下是一些关于Nginx基于IP访问控制的具体信息：</p><ul><li><p><strong>配置语法</strong>：在Nginx的配置文件中，你可以使用<code>allow</code>和<code>deny</code>指令来设置IP访问控制。这些指令可以指定单个IP地址、IP地址范围或者所有IP地址（all）。</p></li><li><p><strong>配置示例</strong>：例如，如果你想允许特定IP地址（如192.168.1.1）访问某个路径（如/path/），同时拒绝其他所有IP地址的访问，你可以这样配置：</p></li><li><pre><code class="bash">location /path/ {    allow 192.168.1.1;    deny all;}    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **应用场景**：这种访问控制方式适用于需要对特定IP地址或IP段进行访问限制的情况，比如设置IP白名单允许特定用户访问，或者设置IP黑名单禁止特定用户访问。</span><br><span class="line"></span><br><span class="line">**配置语法**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">Syntax：allow address | CIDR | unix: | all;</span><br><span class="line">default：默认无</span><br><span class="line">Context：http，server，location</span><br><span class="line"></span><br><span class="line">Syntax：deny address | CIDR | unix: | all;</span><br><span class="line">default：默认无</span><br><span class="line">Context：http，server，location</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><strong>配置测试</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编写配置文件</span></span><br><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/access_mod.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location ~ ^/admin &#123;</span><br><span class="line">                root /www/html;</span><br><span class="line">                index index.html index.hml;</span><br><span class="line">                deny 192.168.1.8;</span><br><span class="line">                allow all;</span><br><span class="line">                #deny 192.168.1.8;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建发布目录</span></span><br><span class="line">[root@localhost ~]# mkdir -p /www/html/admin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建发布文件</span></span><br><span class="line">[root@localhost ~]# echo "admin" &gt; /www/html/admin/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">需要注意:</span></span><br><span class="line">如果先允许访问，在定义拒绝访问。那么拒绝访问不生效。</span><br></pre></td></tr></table></figure><p><strong>指定<code>location</code>拒绝所有请求</strong></p><p>如果你想拒绝某个指定URL地址的所有请求，而不是仅仅对其限速，只需要在<code>location</code>块中配置<code>deny</code> <strong>all</strong>指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/access_mod.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location /foo.html &#123;</span><br><span class="line">                root /home/www/html;</span><br><span class="line">                deny all;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-基于用户的信任登录"><a href="#5-3-基于用户的信任登录" class="headerlink" title="5.3 基于用户的信任登录"></a>5.3 基于用户的信任登录</h3><p>​    基于用户的信任登录是Nginx中实现访问控制的一种方式，主要通过内置的<code>ngx_http_auth_basic_module</code>模块来实现。这个模块允许你要求用户输入正确的用户名和密码才能访问服务器资源。</p><p>以下是一些关于Nginx基于用户信任登录的具体信息：</p><ul><li><p><strong>配置语法</strong>：在Nginx的配置文件中，你可以使用<code>auth_basic</code>指令来启用基本认证，并使用<code>auth_basic_user_file</code>指令指定包含用户名和加密后密码的文件路径。</p></li><li><p><strong>配置示例</strong>：例如，如果你想要求用户输入正确的用户名和密码才能访问某个路径（如/path/），你可以这样配置：</p><ul><li><pre><code class="bash">location /path/ {    auth_basic <span class="string">"Restricted Content"</span>;    auth_basic_user_file /etc/nginx/.htpasswd;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **应用场景**：这种访问控制方式适用于需要对用户进行身份验证的情况，比如限制只有授权用户才能访问某些敏感数据或功能。</span><br><span class="line"></span><br><span class="line">**配置语法**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">Syntax：auth_basic string | off;</span><br><span class="line">default：auth_basic off;</span><br><span class="line">Context：http，server，location，limit_except</span><br><span class="line"></span><br><span class="line">Syntax：auth_basic_user_file file;</span><br><span class="line">default：默认无</span><br><span class="line">Context：http，server，location，limit_except</span><br><span class="line">file：存储用户名密码信息的文件。</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>配置示例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编写配置文件</span></span><br><span class="line">[root@localhost ~]#  vim /etc/nginx/conf.d/auth_mod.conf</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location ~ ^/admin &#123;</span><br><span class="line">root /www/html;</span><br><span class="line">index index.html index.hml;</span><br><span class="line">auth_basic "Auth access test!";</span><br><span class="line">auth_basic_user_file /etc/nginx/auth_conf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>auth_basic</code>不为<code>off</code>，开启登录验证功能，<code>auth_basic_user_file</code>加载账号密码文件。</p><p><strong>建立口令文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建发布目录</span></span><br><span class="line">[root@localhost ~]#  mkdir /www/html/admin -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建发布文件</span></span><br><span class="line">[root@localhost ~]#  echo "hello qf" &gt; /home/www/html/admin/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; htpasswd 是开源 http 服务器 apache httpd 的一个命令工具，用于生成 http 基本认证的密码文件</span></span><br><span class="line">[root@localhost ~]#  yum install -y httpd-tools </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 第一次新建用户</span></span><br><span class="line">[root@localhost ~]#  htpasswd -cm /etc/nginx/auth_conf user10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 第二次添加用户</span></span><br><span class="line">[root@localhost ~]#  htpasswd -m /etc/nginx/auth_conf user20</span><br><span class="line">[root@localhost ~]#  cat /etc/nginx/auth_conf</span><br><span class="line">user10:$apr1$MOa9UVqF$RlYRMk7eprViEpNtDV0n40</span><br><span class="line">user20:$apr1$biHJhW03$xboNUJgHME6yDd17gkQNb0</span><br></pre></td></tr></table></figure><ul><li><strong><code>-c</code></strong>：创建一个新的密码文件。如果文件已经存在，这个选项将覆盖它。</li><li><strong><code>-m</code></strong>：使用 MD5 算法对密码进行加密。</li><li><strong><code>/etc/nginx/auth_conf</code></strong>：指定存储用户名和密码的文件路径。</li><li><strong><code>user10</code></strong>：新创建的用户名。</li></ul><p><strong>访问测试</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408062351899.png" alt="image-20240806235113868"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://l66stbz.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx详解+实操_01</title>
    <link href="https://l66stbz.github.io/2024/08/09/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_01/"/>
    <id>https://l66stbz.github.io/2024/08/09/nginx%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%93%8D_01/</id>
    <published>2024-08-09T13:50:00.000Z</published>
    <updated>2024-08-10T10:29:52.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h2 id="1、HTTP-介绍："><a href="#1、HTTP-介绍：" class="headerlink" title="1、HTTP 介绍："></a>1、HTTP 介绍：</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>​    HTTP协议是超文本传输协议,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><h3 id="1-2-HTTP-工作原理"><a href="#1-2-HTTP-工作原理" class="headerlink" title="1.2 HTTP 工作原理"></a>1.2 HTTP 工作原理</h3><p>​        HTTP（超文本传输协议）是应用层协议。它是整个数据通信的基础，基于请求/响应模式，客户端与服务器之间通过互相发送报文来通信，工作流程如下：</p><ol><li><strong>建立连接</strong>: 客户端（通常是Web浏览器）和服务器之间首先需要建立<code>一个TCP连接</code>。这是因为HTTP协议通常承载于TCP协议之上，确保<code>数据</code>的<code>可靠传输</code>。</li><li><strong>发送请求</strong>: 客户端向服务器发送一个HTTP请求，这个请求包含请求行、请求头和请求体。请求行包括请求方法（如GET或POST），所请求资源的URL以及HTTP协议版本。请求头包含附加信息，比如用户代理、Cookie等。如果是POST请求，请求体中还会包含提交的数据。</li><li><strong>服务器响应</strong>: 服务器接收到请求后，根据请求内容和服务器上的资源生成HTTP响应。响应同样由三部分组成：状态行、响应头和响应体。状态行包括HTTP状态码和原因短语，响应头包含服务器类型、内容类型等附加信息，响应体则携带着实际返回给客户端的数据，例如HTML页面或图片等。</li><li><strong>传输数据</strong>: 服务器将响应通过之前建立的TCP连接发送回客户端。客户端收到响应后，浏览器会根据返回的内容类型渲染出相应的页面或者处理其他类型的数据。</li><li><strong>断开连接</strong>: 数据传输完成后，客户端和服务器关闭TCP连接并释放相关资源。由于HTTP是无状态的，每次通信都是独立的，不会默认保存之前的请求或响应信息。如果需要跟踪用户的状态，通常会使用Cookie或会话机制来实现。</li></ol><h3 id="1-3-常见的web服务器"><a href="#1-3-常见的web服务器" class="headerlink" title="1.3 常见的web服务器"></a>1.3 常见的web服务器</h3><ol><li><p><strong>Apache HTTP Server</strong>：也被称为阿帕奇服务器，它是最广泛使用的Web服务器之一。作为一个开源项目，Apache可以运行在各种操作系统上，包括Unix、Windows和Linux。它以稳定性、可扩展性和安全性著称，在处理大量请求时表现出色。</p></li><li><p><strong>Nginx</strong>：Nginx是一个高性能的HTTP和反向代理服务器，它以处理高并发连接而闻名。Nginx消耗的资源较少，因此在负载较高的情况下仍能保持较低的内存和CPU使用率。</p></li><li><p><strong>Tomcat</strong>：虽然Apache Tomcat主要是作为Java 容器，但它也可以作为独立的Web服务器使用，尤其适合需要动态生成内容的Web应用。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561893004169.png" alt="1561893004169"></p></li></ol><p><strong>HTTPD和NGINX的区别</strong></p><ol><li><p><strong>处理客户端请求</strong>：<strong>Apache采用同步多进程模型，为每个请求创建一个新线程。</strong>这意味着在高并发场景下，Apache会为每个连接分配一个独立的进程或线程，这可能会导致资源使用量随着并发数的增加而线性增长。Nginx则采用异步非阻塞方式，使用事件驱动架构在一个线程中处理多个请求。这种模型使得Nginx在处理大量并发连接时更为高效，尤其是在静态内容服务和反向代理方面。</p></li><li><p><strong>性能和稳定性</strong>：Nginx因其轻量级和高效的事件驱动架构，在性能上通常优于Apache。它特别适用于需要处理高并发请求的场景。而Apache在低至中等流量的环境中表现良好，其模块化设计和丰富的功能使得它在稳定性和模块化方面有一定的优势。</p></li></ol><h3 id="1-4-HTTP注意事项："><a href="#1-4-HTTP注意事项：" class="headerlink" title="1.4 HTTP注意事项："></a><strong>1.4 HTTP注意事项：</strong></h3><ol><li><p><strong><code>无连接性</code></strong>：HTTP通常是一种无连接协议，这意味着每次连接只处理一个请求。一旦服务器处理完客户端的请求并且客户端接收到响应，连接就会断开。这种机制有助于节省传输时间，但同时也意味着每次新的请求都需要建立新的连接。</p></li><li><p><strong><code>无状态性</code></strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p></li><li><p><strong><code>缓存控制</code></strong>：为了提高加载速度和减少带宽消耗，HTTP提供了缓存机制。</p></li><li><p><strong><code>持久连接</code></strong>：虽然HTTP/1.1默认是持久连接（也称为HTTP Keep-Alive），但这需要Web服务器和客户端的支持。持久连接可以减少TCP连接的建立和关闭所带来的开销，提高传输效率。</p></li></ol><h3 id="1-5-HTTP-消息结构"><a href="#1-5-HTTP-消息结构" class="headerlink" title="1.5 HTTP 消息结构"></a>1.5 HTTP 消息结构</h3><p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p><p><strong>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</strong></p><p><strong>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Nginx、Apache Web服务器），通过接收客户端的请求并向客户端发送HTTP响应数据。</strong></p><p><strong>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。用来标识互联网上某一资源的地址，通常用于访问网页、文件、图片等。</strong></p><ul><li><p><strong>协议</strong>：例如，<code>http://</code> 或 <code>https://</code>。</p><p><strong>域名</strong>：例如，<code>www.tabke.love</code>。</p><p><strong>路径</strong>：指向具体的资源，例如，<code>/tanke/tanke.html</code>。</p><p><strong>查询参数</strong>（可选）：用于传递附加信息，例如，<code>?id=123&amp;name=test</code>。</p></li></ul><p><a href="https://www.kengni.com:80/tanke.html?id=123&amp;name=test" target="_blank" rel="noopener">https://www.kengni.com:80/tanke.html?id=123&amp;name=test</a></p><h3 id="1-6-客户端请求消息"><a href="#1-6-客户端请求消息" class="headerlink" title="1.6 客户端请求消息"></a>1.6 客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p><p>(<a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=QQ%E9%9F%B3%E4%B9%90" target="_blank" rel="noopener">https://www.baidu.com/s?ie=UTF-8&amp;wd=QQ%E9%9F%B3%E4%B9%90</a>,此链接可看请求头的内容)</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561893148999.png" alt="1561893148999"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408012146420.png" alt="img"></p><blockquote><ul><li>GET /wzt/favicon.ico HTTP/1.1：表示请求方法为GET，请求的资源路径为/wzt/favicon.ico，使用的HTTP协议版本为1.1。</li><li>Accept: image/avif,image/webp,image/apng,image/svg+xml,image/<em>,</em>/*;q=0.8：表示客户端接受的图像类型和质量。</li><li>Accept-Encoding: gzip, deflate：表示客户端接受的压缩格式。</li><li>Accept-Language: zh-CN,zh;q=0.9：表示客户端接受的语言和优先级。</li><li>Connection: keep-alive：表示客户端希望保持连接，以便进行后续请求。</li><li>Cookie: _ga_C569W2WCN6=GS1.1.1712754252.1.0.1712754252.0.0.0; …：表示客户端发送的Cookie信息，用于服务器识别用户。</li><li>Host: <a href="http://www.mobiletrain.org：表示请求的目标主机名为www.mobiletrain.org。">www.mobiletrain.org：表示请求的目标主机名为www.mobiletrain.org。</a></li><li>Referer: <a href="http://www.mobiletrain.org/?pinzhuanbdtg=biaoti：表示请求的来源页面URL。" target="_blank" rel="noopener">http://www.mobiletrain.org/?pinzhuanbdtg=biaoti：表示请求的来源页面URL。</a> </li><li>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36：表示客户端的浏览器信息和操作系统信息。</li></ul></blockquote><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240411151326745.png" alt="image-20240411151326745"></p><blockquote><p>这段响应信息是HTTP协议的一部分，它包含了服务器对客户端请求的响应。以下是各个字段的含义：</p><ul><li>HTTP/1.1 200 OK：这是HTTP协议的版本和状态码，表示请求成功。</li><li>Server: nginx：服务器使用的是nginx。</li><li>Date: Wed, 10 Apr 2024 13:04:29 GMT：响应生成的时间。</li><li>Content-Type: image/x-icon：响应的内容类型是图像，具体格式为.ico。</li><li>ETag: “63478391-47e”：ETag是用于缓存控制的标识符。</li><li>Access-Control-Allow-Origin: *：允许任何来源访问该资源。</li><li>Accept-Ranges: bytes：服务器接受字节范围请求。</li><li>X-Cache-Lookup: Cache Miss：表示请求的资源未在缓存中找到。</li><li>Last-Modified: Thu, 13 Oct 2022 03:18:41 GMT：资源的最后修改时间。</li><li>Content-Length: 1150：响应内容的长度，单位为字节。</li><li>X-NWS-LOG-UUID: 3120119176189980775：这可能是一个自定义的头部字段，用于日志记录。</li><li>Connection: keep-alive：表示客户端和服务器之间的连接将保持活动状态，以便进行后续请求。</li></ul></blockquote><h3 id="1-7-服务器响应消息"><a href="#1-7-服务器响应消息" class="headerlink" title="1.7 服务器响应消息"></a>1.7 服务器响应消息</h3><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561893177737.png" alt="1561893177737"></p><p>*<em>实例 *</em></p><p>下面实例是一点典型的使用GET来传递数据的实例：</p><p>客户端请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connected to www.testpm.cn (47.244.247.240) port 80 (#0)</span><br><span class="line">&gt; GET /hello.txt HTTP/1.1   # 请求方式与版本协议。</span><br><span class="line">&gt; User-Agent: curl/7.29.0   #用什么客户端访问</span><br><span class="line">&gt; Host: www.testpm.cn  #主机名，域名。主机和端口号，</span><br><span class="line">&gt; Accept: */*  #匹配什么文件类型，“*” 是通用匹配。匹配所有类型</span><br></pre></td></tr></table></figure><p>服务端响应:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt; HTTP/1.1 200 OK       #请求返回的状态码</span><br><span class="line">&lt; Server: nginx/1.16.0  #请求的服务和版本号</span><br><span class="line">&lt; Date: Thu, 04 Jul 2019 08:19:40 GMT</span><br><span class="line">&lt; Content-Type: text/plain #文本类型，有html，plain:普通文本</span><br><span class="line">&lt; Content-Length: 12</span><br><span class="line">&lt; Last-Modified: Thu, 04 Jul 2019 08:13:25 GMT</span><br><span class="line">&lt; Connection: keep-alive  #是否支持长连接</span><br><span class="line">&lt; ETag: "5d1db525-c"  #标识，每次访问如果与最开始的一样返回304否则校验不一致返回200</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><h3 id="1-8-描述HTTP-的工作过程"><a href="#1-8-描述HTTP-的工作过程" class="headerlink" title="1.8  描述HTTP 的工作过程"></a><strong>1.8  描述HTTP 的工作过程</strong></h3><p>HTTP协议的工作过程可以通过一个简单的例子来解释，例如，当你在浏览器中输入一个URL（例如：<a href="http://www.qf.com/test/index.html?name=qf&amp;age=18）并按下回车键时，背后发生了什么？" target="_blank" rel="noopener">www.qf.com/test/index.html?name=qf&amp;age=18）并按下回车键时，背后发生了什么？</a></p><ol><li>浏览器首先会解析你输入的URL，确定你要访问的是哪个网站，以及具体的页面路径。在这个例子中，你要访问的网站是<a href="http://www.qf.com。" target="_blank" rel="noopener">www.qf.com。</a></li><li>浏览器会向DNS服务器发送一个请求，要求解析<a href="http://www.qf.com的IP地址。DNS服务器会返回对应的IP地址。" target="_blank" rel="noopener">www.qf.com的IP地址。DNS服务器会返回对应的IP地址。</a></li><li>浏览器会向这个IP地址发送一个HTTP GET请求。这个请求包含了一些信息，例如你的浏览器类型，你接受的语言等。</li><li>服务器收到这个HTTP请求后，会解析这个请求，确定你要获取的是哪个页面。然后，服务器会从硬盘中找到这个页面，然后返回一个HTTP响应。这个响应包含了页面的内容，以及一些元信息，例如页面的类型，编码方式等。</li><li>浏览器收到HTTP响应后，会解析这个响应，然后将页面的内容显示在浏览器中。</li></ol><h3 id="1-9-HTTP-请求方法"><a href="#1-9-HTTP-请求方法" class="headerlink" title="1.9 HTTP 请求方法"></a>1.9 <code>HTTP 请求方法</code></h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 </p><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><p>重点方法：</p><p><code>GET</code>：用于向服务器请求获取某个资源。（获取一个index.html页面）</p><p><code>POST</code>：用于向服务器提交数据，通常用于表单提交、文件上传等场景。（会产生新的数据）</p><p><code>PUT</code>：用于向服务器更新或保存某个资源，通常用于上传文件、更新数据等场景。（覆盖/更新文件、图片等，不会产生新的数据）</p><p><code>DELETE</code>：用于向服务器删除某个资源，通常用于删除文件、删除数据等场景。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561896279402.png" alt="1561896279402"></p><p><strong>GET</strong>和<strong>POST</strong>是HTTP协议中两种常见的请求方法，它们的工作细节如下：</p><p><strong><code>GET请求</code>是最常见的请求方法，通常用于获取资源。</strong></p><p>​    GET请求的参数会附加在URL之后，通过问号（?）分隔，参数之间用&amp;符号连接。例如，<code>http://www.qf.com/index.html?name=John&amp;age=22</code>。这种方式的缺点是传输数据的大小有限制（因为浏览器对URL的长度有限制），并且不适合传输敏感信息（如密码），因为参数会直接暴露在URL中。</p><p><strong><code>POST请求</code>通常用于提交数据。</strong></p><p>​    POST请求将参数放在HTTP请求的主体中(HTTP的请求主体（Request Body）是HTTP请求消息的一部分，用于在客户端向服务器发送请求时附带额外的数据。这些数据可以是文本、JSON、XML或其他格式，具体取决于请求的类型和客户端与服务器之间的约定。)，而不是URL中。POST请求没有对传输数据的大小进行限制，而且可以传输任何类型的数据，包括二进制数据。因此，POST请求通常用于提交表单数据。</p><p>下面是一个GET请求和POST请求的例子：</p><p>GET请求示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html?name=maoxiansheng&amp;age=18</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.qf.com</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure><p>POST请求示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /api/users HTTP/1.1  </span><br><span class="line"><span class="attribute">Host</span>: www.qf  </span><br><span class="line"><span class="attribute">Content-Type</span>: application/json  </span><br><span class="line"><span class="attribute">Content-Length</span>: 45  </span><br><span class="line">  </span><br><span class="line">&#123;  </span><br><span class="line">  "name": "qianfeng",  </span><br><span class="line">  "email": "qianfeng@1000phone.com"  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GET请求示例中，参数<code>name=John&amp;age=22</code>附加在URL之后。在POST请求示例中，参数<code>&quot;name&quot;: &quot;qianfeng&quot;,    &quot;email&quot;: &quot;qianfeng@1000phone.com&quot;</code>放在HTTP请求的主体中。</p><p>需要注意的是，虽然POST请求在传输大量或敏感数据时更安全，但无论是GET还是POST，都不能提供真正的安全性。为了保护数据的安全，应该使用<code>HTTPS协议</code>，它可以对传输的数据进行加密。</p><h3 id="1-10-HTTP-状态码"><a href="#1-10-HTTP-状态码" class="headerlink" title="1.10 HTTP 状态码"></a><strong>1.10 HTTP 状态码</strong></h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为<code>HTTP Status Code</code>。</p><p>下面是常见的HTTP状态码：</p><ul><li>200 - 请求成功，表示成功处理了请求的状态代码。</li></ul><ul><li><p>301 - 表示被请求的资源已永久移动到新的位置。当服务器返回301状态码时，它会告诉客户端（如浏览器）请求的资源已被永久移动到另一个URL，客户端在接收到301响应后，应该使用新的URL发起后续的请求。</p><p>比如建设一个网站后，将网站的url变换了，重新申请一个域名，但是希望之前的用户访问之前url仍然可以访问到，就可以做一个重定向新的url下面。比如京东最早域名<a href="http://www.360buy.com名重定向到现在www.jd.com" target="_blank" rel="noopener">www.360buy.com名重定向到现在www.jd.com</a></p></li></ul><ul><li>302  - 302状态码表示临时重定向。当服务器收到请求时，如果资源暂时不可用或已经移动到其他位置，服务器会返回一个HTTP 302状态码，客户端会自动发送一个新的请求到这个新的URL地址，以获取所需的资源。</li></ul><ul><li><p><code>404</code>- 表示客户端请求的资源在服务器上不存在或无法找到。当浏览器或客户端尝试访问一个网页或资源，但服务器无法找到与请求URL对应的文件或页面时，就会返回这个错误。</p><p>HTTP 404错误可能由以下原因引起：</p><ol><li><strong>URL错误</strong>：输入的URL可能有误，比如拼写错误、大小写错误、路径错误或者参数错误等。</li><li><strong>页面被删除或移动</strong>：请求的页面可能已经被删除，或者移动到了其他位置，而URL没有相应地更新。</li><li><strong>服务器配置问题</strong>：服务器的配置可能存在问题，导致无法正确解析URL或找到相应的资源。</li><li><strong>资源不存在</strong>：请求的资源（如文件、图片等）可能从未在服务器上创建或已被删除。</li></ol></li></ul><ul><li><p><code>403</code> - 表示服务器理解了客户端的请求，但是拒绝执行此请求。这通常意味着客户端没有访问所请求资源的权限。HTTP 403错误可能由多种原因引起，包括：</p><ol><li><strong>权限不足</strong>：服务器可能要求客户端提供有效的身份验证凭据，以便确定其是否具有访问请求资源的权限。如果客户端没有提供正确的凭据或凭据无效，服务器将返回403状态码。</li><li><strong>IP地址限制</strong>：服务器可能根据IP地址对访问进行限制。如果客户端的IP地址被服务器列入黑名单或没有被列入白名单，服务器将返回403状态码。</li><li><strong>文件权限设置</strong>：服务器上的文件或目录可能设置了访问权限，如果客户端没有足够的权限访问这些文件或目录，服务器将返回403状态码。</li></ol></li></ul><ul><li><p><code>503</code>-错误表示服务不可用，这通常意味着服务器暂时无法处理请求。</p><ol><li><strong>服务器过载</strong>：当服务器接收到的请求过多，超过了其处理能力时，就可能导致服务器过载。这可能是由于服务器硬件性能不足、网络带宽不足或应用程序代码存在问题等原因引起的。</li><li><strong>服务器维护</strong>：服务器可能需要定期进行维护和升级，以保持其稳定性和性能。在这种情况下，服务器可能会暂时关闭，以便进行必要的更新和修复。</li><li><strong>错误的服务器配置</strong>：Web服务器或应用服务器配置错误也可能导致HTTP 503错误。这包括代理服务器的配置错误或应用程序池的错误配置等。</li></ol></li></ul><ul><li><p><code>504</code>-也称为“网关超时”（Gateway Timeout）错误，通常发生在作为网关或代理的服务器没有从上游服务器（如另一个代理服务器或Web服务器）收到及时的响应时。这通常意味着代理服务器等待上游服务器的响应时间过长，超出了设定的等待时间阈值。</p><ol><li><strong>上游服务器过载</strong>：上游服务器可能由于处理过多的请求或资源不足而无法及时响应代理服务器的请求。</li><li><strong>网络延迟或故障</strong>：代理服务器与上游服务器之间的网络连接可能存在问题，导致请求和响应的传输延迟或失败。</li><li><strong>上游服务器配置错误</strong>：上游服务器的配置可能存在问题，导致它无法正确处理代理服务器的请求。</li></ol></li></ul><p><strong>HTTP状态码分类</strong></p><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><ul><li><strong>1xx（信息性状态码）</strong> : 这类状态码表示请求已被服务器接收，需要客户端继续操作。</li><li><strong>2xx（成功状态码）</strong> : 这类状态码表示服务器已成功处理了请求。</li><li><strong>3xx（重定向状态码）</strong> : 这类状态码表示需要客户端采取进一步的操作才能完成请求。例如，301 Moved Permanently表示被请求的资源已永久移动到新位置，302 Found表示请求的资源现在临时从不同的URI响应请求。</li><li><strong>4xx（客户端错误状态码）</strong> : 这类状态码表示客户端似乎发生了错误，妨碍了服务器的处理。</li><li><strong>5xx（服务器错误状态码）</strong> : 这类状态码表示服务器在尝试处理请求时发生了错误。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561896413177.png" alt="1561896413177"></p><p>HTTP状态码列表:</p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="2、Nginx-服务"><a href="#2、Nginx-服务" class="headerlink" title="2、Nginx 服务"></a>2、Nginx 服务</h2><h3 id="2-1-Nginx-介绍"><a href="#2-1-Nginx-介绍" class="headerlink" title="2.1 Nginx 介绍"></a>2.1 Nginx 介绍</h3><p> <em>Nginx</em> (engine x) 是一个高性能的 HTTP 和<code>反向代理</code>服务，也是一个IMAP/POP3/SMTP服务。因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。  </p><p>Nginx是一款<code>轻量级</code>的<code>Web 服务器</code>/<code>反向代理</code>服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p><p>在高连接并发的情况下，Nginx是Apache服务器不错的替代品。</p><p><strong>创始人伊戈尔·赛索耶夫</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561897072438.png" alt="1561897072438"></p><h3 id="2-2-为什么选择-Nginx"><a href="#2-2-为什么选择-Nginx" class="headerlink" title="2.2 为什么选择 Nginx"></a>2.2 为什么选择 Nginx</h3><p>Nginx（engine x）是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。它最初由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发，自发布以来，因其稳定性、丰富的功能集、简单的配置文件和低系统资源消耗而广受好评。</p><p>Nginx的特点包括：</p><ol><li><strong>高性能</strong>：Nginx使用<code>事件驱动</code>模型，可以同时处理大量的并发连接，而且在高负载和大流量情况下仍然能够保持良好的性能。</li><li><strong>轻量级</strong>：Nginx的代码量较少，占用的内存也较少，使其可以在资源受限的系统中运行，并且在高负载下也不易崩溃。</li><li><strong>可扩展性</strong>：Nginx支持众多的第三方模块，可以根据需要进行自定义开发，实现更多的功能。</li><li><strong>高度可靠性</strong>：Nginx是基于稳定的、成熟的事件驱动架构开发的，能够有效地避免因代码错误或第三方库问题导致的崩溃，从而保证了服务的高可靠性。</li><li><strong>热部署</strong>：Nginx支持在不停止服务的情况下更新配置文件和软件升级，为用户提供了极大的便利。</li></ol><p>在功能方面，Nginx具有：</p><ol><li><strong>HTTP代理与反向代理</strong>：作为web服务器，Nginx最常用的功能之一是反向代理。它可以根据不同的正则匹配，采取不同的转发策略，并且能够对返回结果进行错误页跳转、异常判断等。如果被分发的服务器存在异常，Nginx可以将请求重新转发给另一台服务器。</li><li><strong>负载均衡</strong>：Nginx提供了多种负载均衡策略，如轮询、加权轮询和ip hash等，以优化请求的分配和处理方式，从而平均分配后端服务器的负载，提高系统的可用性和可靠性。</li><li><strong>Web缓存</strong>：Nginx支持对不同的文件做不同的缓存处理。</li></ol><h3 id="2-3-IO多路复用"><a href="#2-3-IO多路复用" class="headerlink" title="2.3 IO多路复用"></a>2.3 IO多路复用</h3><h4 id="2-3-1-I-O-multiplexing【多并发】"><a href="#2-3-1-I-O-multiplexing【多并发】" class="headerlink" title="2.3.1 I/O multiplexing【多并发】"></a>2.3.1 I/O multiplexing【多并发】</h4><ul><li>第一种方法就是最传统的多线程并发模型 (每进来一个新的I/O流会分配一个新的进程管理。)</li></ul><p>多进程并发模型是一种传统的服务器架构模式，它的核心思想是利用操作系统的<code>多进程机制</code>来实现并发处理多个客户端请求。在这种模型中，主进程负责监听客户端的连接请求，一旦接收到新的请求，主进程会通过fork()操作创建一个子进程（线程）来独立处理这个请求。这样，父进程可以继续回到监听状态，等待其他客户端的连接。每个子进程处理完一个请求后就会退出，释放资源。这种模型的优点是可以快速响应客户请求，尤其是在客户与服务器交互频繁的场景下。</p><p>然而，这种模型也存在一些缺点：</p><ul><li><strong>资源消耗</strong>：进程是操作系统资源分配的基本单位，每个进程都需要占用一定的内存和CPU资源。在高并发环境下，如果创建大量进程，会导致服务器资源消耗过快，增加服务器负载。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561897144109.png" alt="1561897144109"></p><ul><li>第二种方法就是<code>I/O多路复用</code>(单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流 。)I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流。发明它的原因，是尽量多的提高服务器的吞吐能力。<code>I/O多路复用是一种高效处理多个I/O流的技术，它允许单个线程通过记录和跟踪每个流的状态来同时管理多个I/O流，而不是为每个流创建单独的线程。这样做可以提高服务器应用程序的性能，尤其是在需要处理成千上万并发连接的情况下。</code></li></ul><p><code>在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流。</code>这句话描述的是一种单线程中管理多个I/O流的方法，其中“拨开关”的比喻可能是指通过在多个I/O流之间切换来实现并发处理的方式。这里的“拨开关”可以理解为线程在多个I/O流之间快速切换，检查哪个流准备好进行读或写操作。当一个流准备好时，线程就与之交互（读取数据或发送数据），然后迅速切换到下一个流。这种快速的切换给人的感觉就像是在“拨动开关”，在一个流和另一个流之间来回切换</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561897166658.png" alt="1561897166658"></p><p> <strong>一个请求到来了，nginx使用epoll接收请求的过程是怎样的?</strong></p><ol><li><strong>建立监听</strong>：Nginx通过epoll创建一个事件监听的集合，这个集合能够同时监控多个网络连接的文件描述符。</li><li><strong>事件注册</strong>：对于每一个进入的连接，Nginx会将其文件描述符注册到epoll中，以便对这些连接进行事件监听。</li><li><strong>事件检测</strong>：epoll机制允许Nginx高效地检测哪些注册的连接有活动（比如数据可读或可写），而不需要像传统的轮询那样检查每个连接。</li><li><strong>事件处理</strong>：一旦某个连接上有数据到来，epoll通知Nginx，然后Nginx可以立即响应该连接，处理传入的数据，例如读取HTTP请求。</li><li><strong>动态调整</strong>：epoll能够动态地添加或移除所监听的文件描述符，这使得Nginx在处理大量并发连接时非常灵活和高效。</li><li><strong>资源优化</strong>：由于不是所有连接在任何时刻都是活跃的，epoll只关注那些真正有事件发生的连接，从而节省了系统资源，提高了性能。</li><li><strong>非阻塞I/O</strong>：Nginx利用epoll实现非阻塞I/O操作，这意味着内核在没有数据可读时不会将进程置于等待状态，而是让其继续执行其他任务。</li></ol><h4 id="2-3-2-异步，非阻塞"><a href="#2-3-2-异步，非阻塞" class="headerlink" title="2.3.2  异步，非阻塞"></a>2.3.2  异步，非阻塞</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web01 ~]<span class="comment"># ps -aux | grep nginx</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408021413024.png" alt="img"></p><p> <strong>1个master进程，2个work进程</strong></p><p>master进程只负责监听用户的请求，但并不处理请求。work进程才处理请求。</p><p>​     每进来一个request，会有一个worker进程去处理。但不是<code>全程的处理</code>，处理到什么程度呢？处理到可能<code>发生阻塞</code>的地方，比如向后端服务器转发request，并等待请求返回。那么，这个处理的worker不会这么一直等着，他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。这就是异步。此时，如果再有request 进来，他就可以很快再按这种方式处理。这就是<code>非阻塞</code>和<code>IO多路复用</code>。而一旦上游服务器返回了，就会触发这个事件，worker进程才会来接手，这个request才会接着往下走。这就是<code>异步回调</code>。</p><h2 id="3、Nginx安装部署和配置管理"><a href="#3、Nginx安装部署和配置管理" class="headerlink" title="3、Nginx安装部署和配置管理"></a>3、Nginx安装部署和配置管理</h2><h3 id="3-1-Nginx部署-Yum安装方式"><a href="#3-1-Nginx部署-Yum安装方式" class="headerlink" title="3.1 Nginx部署-Yum安装方式"></a>3.1 Nginx部署-Yum安装方式</h3><p>访问nginx的官方网站：<a href="http://www.nginx.org/" target="_blank" rel="noopener">http://www.nginx.org/</a></p><p>Nginx版本类型</p><ul><li>Mainline version：  主线版，即开发版</li></ul><ul><li><code>Stable version：最新稳定版，生产环境上建议使用的版本</code></li></ul><ul><li>Legacy versions：    遗留的老版本的稳定版</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408021414109.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编写nginx yum源文件（稳定版）</span></span><br><span class="line">[root@nginx-server ~]# vim /etc/yum.repos.d/nginx.repo </span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 缓存元数据</span></span><br><span class="line">[root@nginx-server ~]# yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装nginx服务</span></span><br><span class="line">[root@nginx-server ~]# yum install nginx -y</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看nginx相关信息</span></span><br><span class="line">[root@nginx-server ~]# nginx -V</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408021415977.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看NGINX版本信息</span></span><br><span class="line">[root@nginx-server ~]# nginx -v</span><br><span class="line">nginx version: nginx/1.24.0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 关闭安全策略</span></span><br><span class="line">[root@nginx-server ~]# setenforce 0</span><br><span class="line">[root@nginx-server ~]# sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 关闭防火墙</span></span><br><span class="line">[root@nginx-server ~]# systemctl disable  --now firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 启动nginx并设置开机启动</span></span><br><span class="line">[root@nginx-server ~]# systemctl enable --now  nginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看nginx启动状态</span></span><br><span class="line">[root@nginx-server ~]# systemctl status nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看nginx进程</span></span><br><span class="line">[root@nginx-server ~]# ps -aux | grep nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看nginx端口</span></span><br><span class="line">[root@nginx-server ~]# ss -tunlp | grep -w 80</span><br></pre></td></tr></table></figure><p><strong>浏览器输入ip访问:</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561536791743.png" alt="1561536791743"></p><h3 id="3-2-Nginx-编译安装"><a href="#3-2-Nginx-编译安装" class="headerlink" title="3.2 Nginx 编译安装"></a>3.2 Nginx 编译安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装gcc</span></span><br><span class="line">[root@nginx-server ~]# yum -y install gcc gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装pcre软件包（使nginx支持http rewrite模块）</span></span><br><span class="line">[root@nginx-server ~]# yum install -y pcre pcre-devel</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装openssl-devel（使nginx支持ssl）</span></span><br><span class="line">[root@nginx-server ~]# yum install -y openssl openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 安装zlib</span></span><br><span class="line">[root@nginx-server ~]# yum install -y zlib zlib-devel</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建用户nginx</span></span><br><span class="line">[root@nginx-server ~]# useradd -s /sbin/nologin nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 下载安装包</span></span><br><span class="line">[root@nginx-server ~]# wget http://nginx.org/download/nginx-1.24.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 解压安装包</span></span><br><span class="line">[root@nginx-server ~]# tar xzf nginx-1.24.0.tar.gz -C /usr/local/  &amp;&amp; cd /usr/local/nginx-1.24.0/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 预备编译,指定相关参数</span></span><br><span class="line">[root@nginx-server nginx-1.24.0]#  ./configure --prefix=/usr/local/nginx --group=nginx --user=nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 编译安装</span></span><br><span class="line">[root@nginx-server nginx-1.24.0]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><code>自动化安装NGINX脚本(生产勿用，需要修改其中的相关配置信息)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; NGINX自动化安装脚本</span></span><br><span class="line">$ vim install_nginx.sh </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">ck_ok</span></span> () &#123;</span><br><span class="line"> <span class="keyword">if</span> [ $? -ne 0 ]</span><br><span class="line">  <span class="keyword">then</span> </span><br><span class="line">     <span class="built_in">echo</span> <span class="string">"error."</span></span><br><span class="line">     <span class="built_in">exit</span> 1</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙及selinux</span></span><br><span class="line"><span class="function"><span class="title">disable</span></span> () &#123;</span><br><span class="line">systemctl <span class="built_in">disable</span> --now firewalld &amp;&gt;/dev/null</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">'s#SELINUX=enforcing#SELINUX=disabled#g'</span> /etc/selinux/config </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">repos_bak</span></span> () &#123;</span><br><span class="line">mkdir /etc/yum.repos.d/repo.bak</span><br><span class="line">cp -r  /etc/yum.repos.d/*.repo  /etc/yum.repos.d/repo.bak/</span><br><span class="line">ck_ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换国内源</span></span><br><span class="line"><span class="function"><span class="title">install_repos</span></span> () &#123;</span><br><span class="line">sed -e <span class="string">'s|^mirrorlist=|#mirrorlist=|g'</span> \</span><br><span class="line">    -e <span class="string">'s|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g'</span> \</span><br><span class="line">    -i.bak \</span><br><span class="line">    /etc/yum.repos.d/CentOS-*.repo</span><br><span class="line">ck_ok</span><br><span class="line">yum install -y epel-release </span><br><span class="line">sed -e <span class="string">'s!^metalink=!#metalink=!g'</span> \</span><br><span class="line">    -e <span class="string">'s!^#baseurl=!baseurl=!g'</span> \</span><br><span class="line">    -e <span class="string">'s!https\?://download\.fedoraproject\.org/pub/epel!https://mirrors.tuna.tsinghua.edu.cn/epel!g'</span> \</span><br><span class="line">    -e <span class="string">'s!https\?://download\.example/pub/epel!https://mirrors.tuna.tsinghua.edu.cn/epel!g'</span> \</span><br><span class="line">    -i /etc/yum.repos.d/epel&#123;,-testing&#125;.repo</span><br><span class="line">yum makecache fast </span><br><span class="line">yum install -y gcc gcc-c++  pcre pcre-devel openssl openssl-devel zlib zlib-devel  wget</span><br><span class="line">ck_ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">disable</span></span><br><span class="line"></span><br><span class="line">repos_bak</span><br><span class="line"></span><br><span class="line">install_repos</span><br><span class="line"><span class="comment"># 创建nginx启动用户</span></span><br><span class="line">useradd -s /sbin/nologin  nginx</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入您所要安装的NGINX版本："</span> tags</span><br><span class="line">wget http://nginx.org/download/nginx-<span class="variable">$&#123;tags&#125;</span>.tar.gz</span><br><span class="line">ck_ok </span><br><span class="line"></span><br><span class="line">tar xzf nginx-<span class="variable">$&#123;tags&#125;</span>.tar.gz -C /usr/<span class="built_in">local</span>/  &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx-<span class="variable">$&#123;tags&#125;</span>/</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx --group=nginx --user=nginx --sbin-path=/usr/<span class="built_in">local</span>/nginx/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --http-client-body-temp-path=/tmp/nginx/client_body --http-proxy-temp-path=/tmp/nginx/proxy --http-fastcgi-temp-path=/tmp/nginx/fastcgi --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-pcre --with-http_realip_module --with-stream</span><br><span class="line">ck_ok</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"编译安装完成"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; nginx systemd 启动脚本</span></span><br><span class="line">$ cat &gt; /lib/systemd/system/nginx.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network-online.target remote-fs.target nss-lookup.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/var/run/nginx.pid</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/sh -c <span class="string">"/bin/kill -s HUP \$(/bin/cat /var/run/nginx.pid)"</span></span><br><span class="line">ExecStop=/bin/sh -c <span class="string">"/bin/kill -s TERM \$(/bin/cat /var/run/nginx.pid)"</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ systemctl unmask nginx.service</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl <span class="built_in">enable</span> nginx</span><br><span class="line">$ systemctl start nginx</span><br></pre></td></tr></table></figure><p><strong>Nginx 编译参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx 安装的模块</span></span><br><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -V</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 模块参数具体功能</span></span><br><span class="line">--with-cc-opt='-g -O2 -fPIE -fstack-protector    //设置额外的参数将被添加到CFLAGS变量。（FreeBSD或者ubuntu使用）</span><br><span class="line">--param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2' </span><br><span class="line">--with-ld-opt='-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now' </span><br><span class="line"></span><br><span class="line">--prefix=/usr/local/nginx                        //指向安装目录</span><br><span class="line">--conf-path=/etc/nginx/nginx.conf                //指定配置文件</span><br><span class="line">--http-log-path=/var/log/nginx/access.log        //指定访问日志</span><br><span class="line">--error-log-path=/var/log/nginx/error.log        //指定错误日志</span><br><span class="line">--lock-path=/var/lock/nginx.lock                 //指定lock文件</span><br><span class="line">--pid-path=/run/nginx.pid                        //指定pid文件</span><br><span class="line"></span><br><span class="line">--http-client-body-temp-path=/var/lib/nginx/body    //设定http客户端请求临时文件路径</span><br><span class="line">--http-fastcgi-temp-path=/var/lib/nginx/fastcgi     //设定http fastcgi临时文件路径</span><br><span class="line">--http-proxy-temp-path=/var/lib/nginx/proxy         //设定http代理临时文件路径</span><br><span class="line">--http-scgi-temp-path=/var/lib/nginx/scgi           //设定http scgi临时文件路径</span><br><span class="line">--http-uwsgi-temp-path=/var/lib/nginx/uwsgi         //设定http uwsgi临时文件路径</span><br><span class="line"></span><br><span class="line">--with-debug                                        //启用debug日志</span><br><span class="line">--with-pcre-jit                                     //编译PCRE包含“just-in-time compilation”</span><br><span class="line">--with-ipv6                                         //启用ipv6支持</span><br><span class="line">--with-http_ssl_module                              //启用ssl支持</span><br><span class="line">--with-http_stub_status_module                      //获取nginx自上次启动以来的状态</span><br><span class="line">--with-http_realip_module                 //允许从请求标头更改客户端的IP地址值，默认为关</span><br><span class="line">--with-http_auth_request_module           //实现基于一个子请求的结果的客户端授权。如果该子请求返回的2xx响应代码，所述接入是允许的。如果它返回401或403中，访问被拒绝与相应的错误代码。由子请求返回的任何其他响应代码被认为是一个错误。</span><br><span class="line">--with-http_addition_module               //作为一个输出过滤器，支持不完全缓冲，分部分响应请求</span><br><span class="line">--with-http_dav_module                    //增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法 默认关闭，需编译开启</span><br><span class="line">--with-http_geoip_module                  //使用预编译的MaxMind数据库解析客户端IP地址，得到变量值</span><br><span class="line">--with-http_gunzip_module                 //它为不支持“gzip”编码方法的客户端解压具有“Content-Encoding: gzip”头的响应。</span><br><span class="line">--with-http_gzip_static_module            //在线实时压缩输出数据流</span><br><span class="line">--with-http_image_filter_module           //传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）</span><br><span class="line">--with-http_spdy_module                   //SPDY可以缩短网页的加载时间</span><br><span class="line">--with-http_sub_module                    //允许用一些其他文本替换nginx响应中的一些文本</span><br><span class="line">--with-http_xslt_module                   //过滤转换XML请求</span><br><span class="line">--with-mail                               //启用POP3/IMAP4/SMTP代理模块支持</span><br><span class="line">--with-mail_ssl_module                    //启用ngx_mail_ssl_module支持启用外部模块支持</span><br></pre></td></tr></table></figure><h3 id="3-3-NGINX配置文件详解"><a href="#3-3-NGINX配置文件详解" class="headerlink" title="3.3 NGINX配置文件详解"></a>3.3 NGINX配置文件详解</h3><ol><li><strong>全局模块</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">user  nobody;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br></pre></td></tr></table></figure><ul><li><code>user nobody;</code>：指定 Nginx 进程运行的用户。</li><li><code>worker_processes 1;</code>：指定 Nginx 启动的工作进程数。通常设置为 CPU 核心数。</li><li><code>error_log logs/error.log;</code>：指定错误日志文件的路径和日志级别。</li><li><code>pid logs/nginx.pid;</code>：指定存储 Nginx 主进程 PID 的文件路径。</li></ul><ol start="2"><li><strong>events模块</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>worker_connections 1024;</code>：每个工作进程允许的最大连接数。设置为 1024。该参数用于设置每个worker进程允许的最大并发连接数。worker_connections参数用于指定每个Nginx worker进程可以同时处理的最大连接数。在这个例子中，worker_connections</li><li>设置为1024，表示每个worker进程最多可以同时处理1024个连接。通过设置worker_connections，可以限制每个worker进程的负载，避免因过多的并发连接导致服务器资源耗尽或性能下降。</li></ul><ol start="3"><li><strong>HTTP模块</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">    #                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br></pre></td></tr></table></figure><ul><li><code>include mime.types;</code>：包含 MIME 类型映射文件，告诉 Nginx 如何处理不同类型的文件。</li><li><code>default_type application/octet-stream;</code>：默认的 MIME 类型，如果没有其他匹配的类型，使用这个。</li><li><code>log_format</code> 和 <code>access_log</code>：指定日志格式和访问日志路径。</li><li><code>sendfile on;</code>：启用 sendfile 选项，提高文件传输效率。允许在内核级别直接将文件数据从磁盘传输到网络，而不需要通过用户空间的缓冲区。这样可以减少CPU和内存的开销，提高文件传输的效率。通过将sendfile设置为on，可以启用sendfile选项，从而优化文件传输的性能。这对于大文件传输或者需要快速响应的场景非常有用。</li><li><code>tcp_nopush on;</code>：提高网络传输效率。允许在发送HTTP响应时控制数据包的发送方式。当TCP_NOPUSH选项被设置为on时，Nginx会在发送HTTP响应头之后立即发送响应体的数据，而不是等待整个响应体都准备好后再一起发送。这样可以减少延迟，提高传输效率。</li><li><code>keepalive_timeout 65;</code>：保持连接超时时间，设置为 65 秒。允许在一个TCP连接上发送多个HTTP请求和响应，而不需要每次都重新建立连接。通过使用keepalive，可以减少TCP连接的建立和关闭次数，从而提高服务器的性能和效率。</li><li><code>gzip on;</code>：启用 gzip 压缩。Gzip 压缩可以显著提高网站性能，通过减少传输数据的大小，加快网页加载速度。</li></ul><ol start="4"><li><strong>server模块</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache's document root</span><br><span class="line">    # concurs with nginx's one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>listen 80;</code>：指定虚拟主机监听的端口，设置为 80（HTTP）。</li><li><code>server_name localhost;</code>：指定虚拟主机名称。</li><li><code>charset koi8-r;</code>：设置字符集。</li><li><code>access_log logs/host.access.log main;</code>：指定访问日志路径和格式。</li></ul><ol start="5"><li><strong>location 模块</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>location /</code>：匹配根路径。</li><li><code>root html;</code>：指定根目录路径为 <code>html</code> 目录。</li><li><code>index index.html index.htm;</code>：指定默认的索引文件。</li></ul><ol start="6"><li><strong>错误页面配置</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error_page   500 502 503 504  /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">    root   html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>error_page 500 502 503 504 /50x.html;</code>：指定在发生 500、502、503、504 错误时，显示 <code>/50x.html</code> 页面。</li><li><code>location = /50x.html</code>：精确匹配 <code>/50x.html</code>，并指定根目录为 <code>html</code>。</li></ul><ol start="7"><li><p><strong>代理和 FastCGI 配置</strong></p><p>FastCGI 是一种改进的CGI协议，通过优化性能和资源利用率，使得Web服务器能够更有效地处理动态内容的生成和处理，特别是在高流量和高并发的网络环境中表现出色。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">location ~ \.php$ &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    proxy_pass   http://127.0.0.1;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">location ~ \.php$ &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    root           html;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    fastcgi_index  index.php;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    fastcgi_param  SCRIPT_FILENAME  /scripts<span class="variable">$fastcgi_script_name</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    include        fastcgi_params;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>location ~ \.php$</code>：使用正则表达式匹配以 <code>.php</code> 结尾的请求。</li><li><code>proxy_pass http://127.0.0.1;</code>：将匹配到的请求代理到本地端口 <code>80</code> 上。</li><li><code>location ~ \.php$</code>：使用正则表达式匹配以 <code>.php</code> 结尾的请求。</li><li><code>root html;</code>：设置根目录为 <code>html</code>。表示根目录在 <code>html</code> 文件夹中。</li><li><code>fastcgi_pass 127.0.0.1:9000;</code>：将匹配到的请求传递给本地运行的 FastCGI 服务器，该服务器监听在 <code>127.0.0.1</code> 的端口 <code>9000</code> 上。</li><li><code>fastcgi_index index.php;</code>：使用 <code>index.php</code> 作为索引文件。</li><li><code>fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;</code>：设置 <code>SCRIPT_FILENAME</code> FastCGI 参数，该参数指定了请求的 PHP 脚本文件的路径。<code>$fastcgi_script_name</code> 是请求的 URI，<code>/scripts</code> 是在服务器根目录中的路径。</li><li><code>include fastcgi_params;</code>：包含 FastCGI 参数文件，该文件定义了一组 FastCGI 参数，通常存储在 Nginx 安装目录的 <code>conf</code> 或 <code>conf.d</code> 目录中。</li></ul><blockquote><p>当 Nginx 收到一个以 <code>.php</code> 结尾的请求时，这个请求将被传递给本地的 FastCGI 服务器进行处理。FastCGI 服务器通常是 PHP-FPM（PHP FastCGI Process Manager），它负责处理 PHP 脚本。Nginx 在这里充当一个 FastCGI 客户端，将请求转发给 FastCGI 服务器，然后将服务器的响应返回给客户端。</p></blockquote><ol start="8"><li><strong>拒绝访问 .ht 文件</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> deny access to .htaccess files, <span class="keyword">if</span> Apache<span class="string">'s document root</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> concurs with nginx<span class="string">'s one</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">location ~ /\.ht &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    deny  all;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>location ~ /\.ht</code>：匹配 <code>.ht</code> 文件。</li><li><code>deny all;</code>：拒绝所有访问。被注释掉了。</li></ul><ol start="9"><li><strong>HTTPS 服务器</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HTTPS server</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    listen       443 ssl;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">    ssl_certificate      cert.pem;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">    location / &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        root   html;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        index  index.html index.htm;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>listen 443 ssl;</code>：指定服务器监听 443 端口，这是标准的 HTTPS 端口，并启用 SSL 功能。</p></li><li><p><code>server_name localhost;</code>：指定服务器名称，这里设置为 <code>localhost</code>。</p></li><li><p><code>ssl_certificate cert.pem;</code>：指定服务器的 SSL 证书文件路径。<code>cert.pem</code> 是证书文件。</p></li><li><p><code>ssl_certificate_key cert.key;</code>：指定服务器的 SSL 证书私钥文件路径。<code>cert.key</code> 是私钥文件。</p></li><li><p><code>ssl_session_cache shared:SSL:1m;</code>：启用共享的 SSL 会话缓存，大小为 1MB。这有助于提高 SSL 握手的性能，因为客户端可以重用现有的 SSL 会话。</p></li><li><p><code>ssl_session_timeout 5m;</code>：设置 SSL 会话超时时间为 5 分钟。</p></li><li><p><code>ssl_ciphers HIGH:!aNULL:!MD5;</code>：指定允许使用的 SSL 加密套件。<code>HIGH</code> 表示高安全性套件，<code>!aNULL</code> 排除不带认证的套件，<code>!MD5</code> 排除使用 MD5 算法的套件。</p></li><li><p><code>ssl_prefer_server_ciphers on;</code>：指示服务器优先使用自己的加密套件，而不是客户端的套件顺序。这有助于确保使用强加密。</p></li></ul><p><strong>Nginx配置文件组成部分</strong></p><ul><li><strong>全局块</strong>：这是配置文件的最顶层，用于定义对整个Nginx服务器生效的参数。例如，可以设置工作进程数、错误日志的位置等。全局块中配置的指令作用于整个Nginx服务器，而不是某个特定的server或location。</li><li><strong>events块</strong>：位于全局块下面，用来设置与连接处理相关的参数，比如每个工作进程允许的最大并发连接数等。这个块通常用来调整Nginx如何处理网络连接和请求的传输速率。</li><li><strong>http块</strong>：包含了所有与HTTP服务相关的设置，如路由匹配、静态文件服务、反向代理和负载均衡等。在http块内部，可以包含http全局块、多个server块以及每个server块中的多个location块。每个server块代表一个虚拟主机的配置，而location块则用于匹配并处理特定的URL请求。</li></ul><p><strong>检测nginx配置文件是否正确</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ln -s /usr/local/nginx/sbin/nginx  /sbin/</span><br><span class="line">[root@localhost ~]# nginx -t</span><br></pre></td></tr></table></figure><p><strong>通过 nginx 命令控制 nginx 服务</strong></p><p>a、常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /path/nginx.conf       # 以特定目录下的配置文件启动nginx:</span><br><span class="line">nginx -s reload              # 修改配置后重新加载生效</span><br><span class="line">nginx -s stop    # 快速停止nginx</span><br><span class="line">nginx # 快速启动nginx</span><br><span class="line">nginx -t     # 测试当前配置文件是否正确</span><br><span class="line">nginx -t -c /path/to/nginx.conf  # 测试特定的nginx配置文件是否正确</span><br></pre></td></tr></table></figure><h3 id="3-4-Nginx-日志文件详解"><a href="#3-4-Nginx-日志文件详解" class="headerlink" title="3.4 Nginx 日志文件详解"></a><strong>3.4 Nginx 日志文件详解</strong></h3><p>​    nginx 日志文件分为 <strong>log_format</strong> 和 <strong>access_log</strong> 两部分</p><p>​    log_format 定义记录的格式，其语法格式为</p><p>​    log_format        样式名称        样式详情</p><p>​    配置文件中默认有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  'remote_addr - remote_user [time_local] "request" '</span><br><span class="line">                  'status body_bytes_sent "$http_referer" '</span><br><span class="line">                  '"http_user_agent" "http_x_forwarded_for"';</span><br></pre></td></tr></table></figure><ol><li><code>log_format</code></li></ol><ul><li><code>log_format</code>：定义日志格式。</li><li><code>main</code>：这是日志格式的名称。在 <code>access_log</code> 指令中引用这个日志格式。</li></ul><ol start="2"><li><code>remote_addr</code></li></ol><ul><li><code>$remote_addr</code>：记录客户端的 IP 地址。这个字段表示请求是从哪个 IP 地址发出的。</li></ul><ol start="3"><li><code>remote_user</code></li></ol><ul><li><code>$remote_user</code>：记录客户端通过 HTTP 基本认证的用户名。如果请求没有进行认证，则这个字段为空。</li></ul><ol start="4"><li><code>time_local</code></li></ol><ul><li><code>$time_local</code>：记录请求的本地时间和日期。格式通常为 <code>day/month/year:hour:minute:second timezone</code>（例如：<code>03/Jul/2024:08:33:00 +0800</code>）。</li></ul><ol start="5"><li><code>request</code></li></ol><ul><li><code>$request</code>：记录请求行，包含了请求方法、请求 URI 和 HTTP 协议版本。例如：<code>GET /index.html HTTP/1.1</code>。</li></ul><ol start="6"><li><code>status</code></li></ol><ul><li><code>$status</code>：记录响应的 HTTP 状态码。</li></ul><ol start="7"><li><code>body_bytes_sent</code></li></ol><ul><li><code>$body_bytes_sent</code>：记录发送给客户端的响应主体的字节数，不包括响应头。如果响应没有主体，则这个字段为 <code>0</code>。</li></ul><ol start="8"><li><code>$http_referer</code></li></ol><ul><li><code>$http_referer</code>：记录请求的 <code>Referer</code> 头部字段的值。这个字段表示客户端从哪个页面链接到当前请求的页面。</li></ul><ol start="9"><li><code>http_user_agent</code></li></ol><ul><li><code>$http_user_agent</code>：记录请求的 <code>User-Agent</code> 头部字段的值。这个字段包含了客户端浏览器的详细信息。</li></ul><ol start="10"><li><code>http_x_forwarded_for</code></li></ol><ul><li><code>$http_x_forwarded_for</code>：记录请求的 <code>X-Forwarded-For</code> 头部字段的值。这个字段通常由代理服务器添加，表示原始客户端的 IP 地址。</li></ul><p><strong>日志示例如下：</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408042113210.png" alt="img"></p><h3 id="3-5-使用-limit-rate-限制客户端传输数据的速度"><a href="#3-5-使用-limit-rate-限制客户端传输数据的速度" class="headerlink" title="3.5 使用 limit_rate 限制客户端传输数据的速度"></a><strong>3.5 使用 limit_rate 限制客户端传输数据的速度</strong></h3><p>​    限制客户端的下载速度。这个功能对于控制带宽、优化服务器性能以及防止带宽滥用。</p><p>在这个例子中，<strong>limit_rate设置为50k</strong>，表示每个客户端连接的最大传输速率为50KB/s。通过设置limit_rate，<strong>可以控制客户端请求的传输速率，避免因单个客户端占用过多带宽而导致其他客户端无法正常访问。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改nginx配置文件</span></span><br><span class="line">[root@localhost ~]# vim  /etc/nginx/conf.d/limit_rate.conf</span><br><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name limit.tanke.love;</span><br><span class="line">   location / &#123;</span><br><span class="line">            root   /www/limit;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            limit_rate  50k;  #对每个连接的限速为2k/s</span><br><span class="line">            # limit_rate_after 1m;  # 下载 1 MB 后开始限速</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 上传测试视频</span></span><br><span class="line">[root@localhost ~]# ll /www/limit/</span><br><span class="line">总用量 156180</span><br><span class="line">-rw-r--r--. 1 root root 159920333 8月   1 22:22 1.mp4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 准备默认资源文件</span></span><br><span class="line">[root@localhost ~]# echo "limit_rate" &gt; /www/limit/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 检查语法格式</span></span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 重新加载配置文件</span></span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 测试限流</span></span><br><span class="line">[root@localhost ~]# curl  http://192.168.174.20/1.mp4  -o /dev/null</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202408012226732.png" alt="img"></p><ul><li><p><strong><code>% Total</code></strong>: 文件的总大小。</p><p><strong><code>% Received</code></strong>: 已接收的百分比。</p><p><strong><code>% Xferd</code></strong>: 已传输的数据量。</p><p><strong><code>Average Speed</code></strong>: 平均下载速度。</p><p><strong><code>Time Total</code></strong>: 总时间。</p><p><strong><code>Time Spent</code></strong>: 已经花费的时间。</p><p><strong><code>Time Left</code></strong>: 剩余时间。</p><p><strong><code>Current Speed</code></strong>: 当前下载速度。</p></li></ul><blockquote><p><code>Current Speed</code> 显示为 52668 bytes/sec（约为 51.43359375 KB/sec），接近设置的 <code>50k</code> 限制。ZZ</p></blockquote><h3 id="3-6-Nginx-虚拟主机配置"><a href="#3-6-Nginx-虚拟主机配置" class="headerlink" title="3.6 Nginx 虚拟主机配置"></a>3.6 Nginx 虚拟主机配置</h3><p><strong>什么是虚拟主机？</strong><br>虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供web服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561605672295.png" alt="1561605672295"></p><p>Nginx 支持三种类型的虚拟主机配置，具体包括<strong>基于域名、基于IP和基于端口的虚拟主机</strong>。</p><ol><li><strong>基于域名的虚拟主机</strong>：这种类型的虚拟主机使用server_name指令来区分不同的虚拟主机，适用于外部网站的发布。通过域名系统（DNS）解析到同一个IP地址的不同域名可以指向不同的网站内容。</li><li><strong>基于IP的虚拟主机</strong>：一块主机绑定多个IP地址，每个IP地址对应一个虚拟主机。这种方式要求服务器有多个IP地址，每个虚拟主机通过不同的IP进行访问。</li><li><strong>基于端口的虚拟主机</strong>：通过不同的端口号来区分不同的虚拟主机，适用于需要在同一台物理服务器上运行多个服务的情况。</li></ol><p>Nginx通过提供虚拟主机的功能，允许用户在单一服务器上部署多个网站或应用，而无需安装多个Nginx实例。</p><h4 id="1-基于域名的虚拟主机"><a href="#1-基于域名的虚拟主机" class="headerlink" title="1. 基于域名的虚拟主机"></a><strong>1. 基于域名的虚拟主机</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/limit_rate.conf </span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name limit.tanke.love;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /www/limit/;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    limit_rate 2k;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name one.tanke.love;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /www/one;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 创建资源目录和文件</span></span><br><span class="line">[root@localhost ~]# mkdir /www/one</span><br><span class="line">[root@localhost ~]# echo "one" &gt; /www/one/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 检测nginx配置文件语法</span></span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 热加载nginx</span></span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果修改的是nginx的资源文件，则不需要进行服务重启和热更新。</p></blockquote><h4 id="2-基于ip的虚拟主机"><a href="#2-基于ip的虚拟主机" class="headerlink" title="2. 基于ip的虚拟主机"></a><strong>2. 基于ip的虚拟主机</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip a </span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:17:f1:af brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.174.20/24 brd 10.0.105.255 scope global dynamic ens33</span><br><span class="line">       valid_lft 81438sec preferred_lft 81438sec</span><br><span class="line">    inet6 fe80::9d26:f3f0:db9c:c9be/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@localhost ~]# ifconfig ens33:1 192.168.174.21/24</span><br><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.174.20  netmask 255.255.255.0  broadcast 10.0.105.255</span><br><span class="line">        inet6 fe80::9d26:f3f0:db9c:c9be  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:17:f1:af  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 9844  bytes 1052722 (1.0 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5567  bytes 886269 (865.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33:1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.174.21  netmask 255.255.255.0  broadcast 10.0.105.255</span><br><span class="line">        ether 00:0c:29:17:f1:af  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br><span class="line">2、配置通过ip区分的虚拟机</span><br><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/ip_server.conf</span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name 192.168.174.20;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /www/20;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name 192.168.174.21;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /www/21;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建站点目录和资源文件</span></span><br><span class="line">[root@localhost ~]# mkdir /www/&#123;20,21&#125;</span><br><span class="line">[root@localhost ~]# echo "20" &gt; /www/20/index.html</span><br><span class="line">[root@localhost ~]# echo "21" &gt; /www/21/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测nginx配置文件语法</span></span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line"><span class="meta">#</span><span class="bash"> 热加载nginx</span></span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问</span></span><br><span class="line">http://192.168.174.20</span><br><span class="line">http://192.168.174.21</span><br><span class="line"><span class="meta">#</span><span class="bash"> 补充</span></span><br><span class="line">-- 删除绑定的临时ip</span><br><span class="line">[root@localhost ~]# ifconfig ens33:1 192.168.174.21 down</span><br><span class="line">重启一下nginx</span><br><span class="line">[root@localhost ~]# systemctl restart nginx</span><br></pre></td></tr></table></figure><h4 id="3-基于端口的虚拟主机"><a href="#3-基于端口的虚拟主机" class="headerlink" title="3. 基于端口的虚拟主机"></a><strong>3. 基于端口的虚拟主机</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/nginx/conf.d/port_server.conf</span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name port.tanke.love;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /www/port80/;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 81;</span><br><span class="line">  server_name port.tanke.love;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /www/port81;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建站点目录和资源文件</span></span><br><span class="line">[root@localhost ~]# mkdir /www/&#123;port80,port81&#125;</span><br><span class="line">[root@localhost ~]# echo "port80" &gt; /www/port80/index.html</span><br><span class="line">[root@localhost ~]# echo "port81" &gt; /www/port81/index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载配置文件:</span></span><br><span class="line">[root@localhost ~]# nginx -t</span><br><span class="line">[root@localhost ~]# systemctl reload nginx</span><br><span class="line">测试访问:</span><br><span class="line">浏览器输入：http://port.tanke.love</span><br><span class="line">浏览器输入：http://port.tanke.love:81</span><br></pre></td></tr></table></figure><h2 id="4、Nginx-proxy-代理"><a href="#4、Nginx-proxy-代理" class="headerlink" title="4、Nginx proxy 代理"></a>4、Nginx proxy 代理</h2><h3 id="4-1-反向代理产生背景"><a href="#4-1-反向代理产生背景" class="headerlink" title="4.1 反向代理产生背景"></a>4.1 反向代理产生背景</h3><p>​    <strong>反向代理产生的背景是<code>互联网的高速发展和用户需求的激增</code></strong>。</p><ul><li><strong>提高服务器性能</strong>：随着用户数量的增加，单个服务器处理大量请求的能力有限，通过使用反向代理，可以将请求分散到多个服务器上，从而提高整体的处理能力和效率。</li><li><strong>负载均衡</strong>：反向代理可以作为负载均衡器，将客户端的请求均匀地分配到后端的<code>相同服务</code>器群中，确保每个服务器的负载处于合理水平，避免某单一服务器过载而影响服务质量。</li><li><strong>安全性提升</strong>：反向代理可以隐藏后端服务器的真实IP地址，增加系统的安全性。保护内部网络不受外界直接访问。</li><li><strong>缓存静态内容</strong>：反向代理服务器可以缓存静态内容，如图片、CSS和JavaScript文件，这样可以减少对后端服务器的重复请求，加快内容的加载速度。</li></ul><h3 id="4-2-反向代理服务的实现"><a href="#4-2-反向代理服务的实现" class="headerlink" title="4.2 反向代理服务的实现"></a>4.2 反向代理服务的实现</h3><ol><li><strong>配置反向代理服务器</strong>：首先需要设置一个反向代理服务器，可以是Nginx、Apache等常见的Web服务器软件。在服务器上进行相应的配置，指定后端服务器的地址和端口号。</li><li><strong>安装和配置后端服务器</strong>：根据具体需求，选择并安装适当的后端服务器软件，如Tomcat、Node.js等。然后对后端服务器进行配置。</li><li><strong>配置反向代理规则</strong>：在反向代理服务器上配置转发规则，将客户端的请求转发到正确的后端服务器。这可以通过修改配置文件或使用特定的命令来实现。</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561616855038.png" alt="    1561616855038"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561616834649.png" alt="1561616834649"></p><h3 id="4-3-正向代理和反向代理的区别"><a href="#4-3-正向代理和反向代理的区别" class="headerlink" title="4.3 正向代理和反向代理的区别"></a>4.3 正向代理和反向代理的区别</h3><ol><li><strong>代理对象不同</strong>：<code>正向代理的代理对象是客户端，它位于客户端和目标服务器之间，客户端通过代理服务器发送请求到目标服务器，并从目标服务器获取内容。</code>反向代理的代理对象是服务器，它位于客户端和目标服务器之间，客户端的请求直接发送到反向代理服务器，然后由反向代理服务器将请求转发给目标服务器。</li><li><strong>使用场景不同</strong>：正向代理通常用于访问被限制或不可访问的内容，或者在内部网络中提供对外访问的方式。反向代理则主要用于实现负载均衡、安全策略、缓存等功能，提高网站性能和可用性。</li><li><strong>设置需求不同</strong>：正向代理通常需要客户端进行设置，以使其通过代理服务器进行访问，这通常涉及到在客户端的网络设置中指定代理服务器的IP地址和端口号。反向代理则通常不需要客户端进行任何设置，客户端发出的请求直接发送到反向代理服务器，然后由反向代理服务器转发请求到后端真实服务器。</li><li><strong>安全性不同</strong>：正向代理隐藏客户端的IP地址和身份信息，因为请求是通过代理服务器发出的。反向代理隐藏服务器的真实IP地址和身份信息，<code>客户无需知道后端服务的真实地址</code>。因为请求是直接发送到反向代理服务器，然后由反向代理服务器将请求转发给目标服务器。</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561616889383.png" alt="1561616889383"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561617154985.png" alt="1561617154985"></p><p>反向代理中，<code>proxy</code>和<code>server</code>同属一个LAN，反向代理中代理的对象是服务端，proxy和server同属一个LAN，对client透明。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561617180382.png" alt="1561617180382"></p><p>正向代理和反向代理对比示意图，正向代理中代理的对象是客户端，proxy和client同属一个LAN，对server透明；</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1561618001304.png" alt="1561618001304"></p><h3 id="4-4-常用的集群软件"><a href="#4-4-常用的集群软件" class="headerlink" title="4.4 常用的集群软件"></a>4.4 常用的集群软件</h3><ul><li><strong>开源</strong>：LVS，Keepalived，Haproxy，Nginx</li><li><strong>商业</strong>：F5</li></ul><h3 id="4-5-Nginx-proxy模块配置"><a href="#4-5-Nginx-proxy模块配置" class="headerlink" title="4.5 Nginx proxy模块配置"></a>4.5 <code>Nginx proxy模块配置</code></h3><h4 id="4-5-1-Nginx-proxy代理模块"><a href="#4-5-1-Nginx-proxy代理模块" class="headerlink" title="4.5.1 Nginx proxy代理模块"></a>4.5.1 Nginx proxy代理模块</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_proxy_module</span><br></pre></td></tr></table></figure><h4 id="4-5-2-代理配置"><a href="#4-5-2-代理配置" class="headerlink" title="4.5.2 代理配置"></a>4.5.2 代理配置</h4><p>​    准备两台nginx主机，一台为代理服务器，一台为后端服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; nginx 01代理服务器配置修改</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/pass_server.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen      80;</span><br><span class="line">  server_name limit.tanke.love;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://192.168.174.21:80;</span><br><span class="line">    proxy_redirect default;</span><br><span class="line">    proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">    proxy_set_header   X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header   X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    proxy_connect_timeout 30;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_buffering on;</span><br><span class="line">    proxy_buffer_size 32k;</span><br><span class="line">    proxy_buffers 4 128k;</span><br><span class="line">    proxy_busy_buffers_size 256k;</span><br><span class="line">    proxy_max_temp_file_size 256k;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line">proxy_pass http://192.168.174.21:80;  <span class="comment"># 代理的真实后端地址；</span></span><br><span class="line"></span><br><span class="line">proxy_set_header<span class="comment"># proxy_set_header指令来设置代理服务器向后端服务器发送的请求头部信息。在这个例子中，proxy_set_header Host $http_host;表示将客户端请求的Host头部信息（即$http_host变量）设置为代理服务器向后端服务器发送的请求头部信息中的Host字段。</span></span><br><span class="line"></span><br><span class="line">proxy_set_header   X-Real-IP <span class="variable">$remote_addr</span>; <span class="comment"># 使用proxy_set_header指令来设置代理服务器向后端服务器发送的请求头部信息。在这个例子中，proxy_set_header X-Real-IP $remote_addr;表示将客户端的IP地址（即$remote_addr变量）设置为代理服务器向后端服务器发送的请求头部信息中的X-Real-IP字段。</span></span><br><span class="line"></span><br><span class="line">proxy_set_header   X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment"># 将客户端的IP地址和代理服务器的IP地址一起传递给后端服务器。</span></span><br><span class="line"></span><br><span class="line">proxy_connect_timeout 30; <span class="comment"># proxy_connect_timeout指令来设置代理服务器与后端服务器建立连接的超时时间。</span></span><br><span class="line"></span><br><span class="line">proxy_send_timeout 60;<span class="comment"># proxy_send_timeout指令来设置代理服务器向后端服务器发送请求的超时时间。</span></span><br><span class="line"></span><br><span class="line">proxy_read_timeout 60;<span class="comment"># proxy_read_timeout指令来设置代理服务器从后端服务器接收响应的超时时间。</span></span><br><span class="line"></span><br><span class="line">proxy_buffering on;<span class="comment"># proxy_buffering on;表示开启代理服务器的缓冲功能。目的是为了让代理服务器能够缓存从后端服务器接收到的响应数据，从而提高整体的性能和用户体验。通过开启代理服务器的缓冲功能，可以确保代理服务器能够将响应数据缓存起来，从而减少与后端服务器之间的通信次数，提高响应速度。</span></span><br><span class="line"></span><br><span class="line">proxy_buffer_size 32k;<span class="comment"># proxy_buffer_size指令来设置代理服务器缓冲区的大小。</span></span><br><span class="line"></span><br><span class="line">proxy_buffers 4 128k;<span class="comment"># 代理服务器的缓冲区数量和每个缓冲区的大小。这个参数决定了Nginx在代理客户端请求时用于缓存后端服务器响应的缓冲区的总数量和每个缓冲区的最大容量。4：这是缓冲区的数量，即Nginx将创建4个缓冲区来存储来自后端服务器的响应数据。128k：这是每个缓冲区的大小，即每个缓冲区可以存储最多128KB的数据。</span></span><br><span class="line"></span><br><span class="line">proxy_busy_buffers_size 256k;<span class="comment"># 设置代理服务器的繁忙缓冲区大小。这个参数决定了Nginx在处理高负载时，用于缓存后端服务器响应的额外缓冲区的大小。</span></span><br><span class="line"></span><br><span class="line">proxy_max_temp_file_size 256k;<span class="comment"># 设置代理服务器的最大临时文件大小。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意事项： buffer 缓冲区</p><ul><li><strong>并发连接数</strong>：更多的并发连接意味着需要更多的繁忙缓冲区。每个连接可能会使用一个繁忙缓冲区，因此需要根据预期的并发量来设置繁忙缓冲区的数量。</li><li><strong>响应大小</strong>：如果后端服务器返回的响应体通常较大，可能需要增加繁忙缓冲区的大小以避免性能问题。同时，如果响应体很小，那么过多的繁忙缓冲区或过大的繁忙缓冲区可能会浪费内存。</li><li><strong>内存限制</strong>：Nginx的繁忙缓冲区大小不能无限制地增加，因为服务器的内存是有限的。必须确保繁忙缓冲区的配置不会消耗过多的内存，影响其他进程或服务的性能。</li><li><strong>后端服务器性能</strong>：后端服务器的响应速度也会影响繁忙缓冲区大小的设置。如果后端服务器响应迅速，可能不需要很大的繁忙缓冲区；如果响应慢，较大的繁忙缓冲区可以减少Nginx等待数据的时间。</li></ul></blockquote><h4 id="4-5-3-服务端配置"><a href="#4-5-3-服务端配置" class="headerlink" title="4.5.3 服务端配置"></a>4.5.3 服务端配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/nginx/conf.d/default.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost; </span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-4-测试访问"><a href="#4-5-4-测试访问" class="headerlink" title="4.5.4 测试访问"></a>4.5.4 测试访问</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问代理服务器域名</span></span><br><span class="line">游览器访问：limit.tanke.love</span><br></pre></td></tr></table></figure><p>服务端查看<code>/var/log/nginx/access.log</code> 访问日志</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328111901587.png" alt="image-20240328111901587"></p><blockquote><p>192.168.174.20 反向代理服务器地址<br>192.168.174.21 客户端真实地址</p></blockquote><hr><h2 id="5、Nginx-负载均衡"><a href="#5、Nginx-负载均衡" class="headerlink" title="5、Nginx 负载均衡"></a>5、Nginx 负载均衡</h2><h3 id="5-1-负载均衡作用"><a href="#5-1-负载均衡作用" class="headerlink" title="5.1 负载均衡作用"></a>5.1 负载均衡作用</h3><ol><li><strong>提高并发处理能力</strong>：通过将网络流量<code>平均分发</code>到多个服务器上，负载均衡器能够提高系统整体的响应速度和并发处理能力。</li><li><strong>增强系统的伸缩性</strong>：当需要增加或减少服务器数量时，负载均衡器可以重新分配请求，确保系统可以根据需求进行扩展或缩减。</li><li><strong>提升系统的可用性</strong>：负载均衡器会监控各个服务器的状态，自动跳过不可用的服务器，确保请求只被分发给可用的服务器，从而保证服务的连续性。</li><li><strong>安全防护功能</strong>：一些负载均衡解决方案提供了安全功能，如黑白名单处理、防火墙以及防御DDoS攻击等。</li><li><strong>优化资源使用</strong>：负载均衡技术可以确保没有单个服务器承受过多的负载，从而避免过载，实现资源的最优使用。</li><li><strong>最小化响应时间</strong>：通过智能地将请求分配给多个服务器，负载均衡有助于减少用户的等待时间，提供更快的服务响应。</li></ol><h3 id="5-2-Nginx-负载均衡模块"><a href="#5-2-Nginx-负载均衡模块" class="headerlink" title="5.2 Nginx 负载均衡模块"></a>5.2 Nginx 负载均衡模块</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_upstream_module</span><br><span class="line">ngx_http_proxy_module</span><br></pre></td></tr></table></figure><ul><li><strong>ngx_http_upstream_module</strong>：用于定义负载均衡策略和后端服务器组的模块。<code>upstream</code>指令用于定义后端服务器组，这些服务器组会被Nginx用来进行负载均衡。</li><li><strong>ngx_http_proxy_module</strong>：负责将客户端的请求转发到<code>upstream</code>模块定义的后端服务器组。通过<code>proxy_pass</code>指令，Nginx可以将请求发送到指定的服务器组，从而实现负载均衡。</li></ul><h3 id="5-3-Nginx-upstream-配置"><a href="#5-3-Nginx-upstream-配置" class="headerlink" title="5.3 Nginx upstream 配置"></a>5.3 Nginx upstream 配置</h3><p>​            upstream 配置与http块下，和server块同级。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 代理服务器配置</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/nginx.conf </span></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    upstream <span class="built_in">test</span> &#123;</span><br><span class="line">       server 192.168.174.21:80;</span><br><span class="line">       server 192.168.174.22:80;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/upstream_server.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name upstream.tanke.love;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://<span class="built_in">test</span>;</span><br><span class="line">    proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">    proxy_set_header   X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header   X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 后端主机nginx02配置网页资源</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "nginx02" &gt; /usr/share/nginx/html/index.html </span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /usr/share/nginx/html/index.html </span></span><br><span class="line">nginx02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端主机nginx03配置网页资源</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "nginx03" &gt; /usr/share/nginx/html/index.html </span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /usr/share/nginx/html/index.html </span></span><br><span class="line">nginx03</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理服务器检查配置文件语法</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理服务器热加载nginx</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问代理服务器</span></span><br><span class="line">http://upstream.tanke.love</span><br></pre></td></tr></table></figure><h4 id="5-3-1-Nginx负载均衡策略"><a href="#5-3-1-Nginx负载均衡策略" class="headerlink" title="5.3.1 Nginx负载均衡策略"></a>5.3.1 <code>Nginx负载均衡策略</code></h4><ul><li><p><strong><code>轮询（Round Robin）</code></strong>：这是默认的负载均衡策略。在这种策略下，每个请求会按时间顺序逐一分配到不同的后端服务器节点，确保每个节点平均处理请求。</p><ul><li><strong>优点</strong>：<ul><li><strong>简单高效</strong>：轮询策略实现起来相对简单，不需要复杂的算法支持，因此在处理请求时效率较高。</li><li><strong>自动故障转移</strong>：如果某个后端服务器宕机或无法响应，Nginx能够自动检测到并将请求转发到其他健康的服务器上，这样可以提高系统的整体可用性。</li><li><strong>均匀分配</strong>：在大多数情况下，轮询策略能够保证请求被均匀地分配到各个后端服务器上，从而提高了系统的吞吐量和资源的利用率。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>会话一致性问题</strong>：由于请求可能会被随机分配到不同的服务器上，这可能会导致同一个用户的连续请求落在不同服务器上，从而影响会话的一致性。</li><li><strong>缺乏灵活性</strong>：轮询策略不会考虑后端服务器的实际处理能力，也不会根据请求的内容进行优化分配，这可能会导致某些服务器过载而其他服务器却处于空闲状态。</li></ul></li></ul></li><li><p><strong><code>加权轮询（Weighted Round Robin）</code></strong>：这种策略允许根据服务器的性能为其分配权重，性能更好的服务器可以处理更多的请求。</p><ul><li><strong>优点</strong>：<ul><li><strong>性能优化</strong>：允许性能更强的服务器处理更多的请求，这样可以充分利用资源，提高整体的处理能力。</li><li><strong>灵活性</strong>：可以根据实际情况调整服务器的权重，以适应不同的负载需求和服务器性能。</li><li><strong>适应性</strong>：在服务器性能差异较大时，能够更好地平衡负载，避免某些服务器过载而其他服务器空闲的情况发生。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>压力集中</strong>：在系统启动初期，高权重的节点可能会承受较大的压力，导致机器负载突然增高，而其他机器则处于低负载状态，这可能会影响服务的平滑性。</li><li><strong>复杂性</strong>：相比简单的轮询策略，加权轮询需要更多的配置和管理，增加了系统的复杂性。</li><li><strong>会话一致性</strong>：尽管加权轮询考虑了服务器的性能，但仍然可能导致同一用户的请求被分配到不同服务器，影响会话一致性。                             </li></ul></li></ul></li><li><p><strong><code>最少连接（Least Connections）</code></strong>：在这个策略下，Nginx会将新请求分配给当前连接数最少的服务器，这样可以保证服务器间的负载更加均衡。</p><ul><li><strong>优点</strong>：<ul><li><strong>提高服务器利用率</strong>：在高负载情况下，将请求转发给当前连接数较少的后端服务器，可以更有效地利用服务器资源，避免某些服务器过载。</li><li><strong>适应性强</strong>：适用于处理时间不确定或服务器性能差异较大的环境，能够根据实际情况动态调整请求分配，提高整体的处理能力和效率。</li><li><strong>减少响应时间</strong>：通过将请求分配给当前连接数较少的服务器，可以减少用户的等待时间，提高服务的响应速度。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>可能导致空闲</strong>：在某些情况下，如果某个服务器的处理能力非常强，可能会导致其他服务器长期处于空闲状态，从而影响其性能和稳定性。</li><li><strong>可能不公平</strong>：如果服务器的处理能力不同，仅仅根据连接数来分配请求可能会导致某些服务器承担更多的负载，而其他服务器则相对较少，这在一定程度上违背了负载均衡的公平性原则。                      </li></ul></li></ul></li><li><p><strong><code>IP Hash</code></strong>：这种策略会根据客户端IP地址的哈希值来选择服务器，这样可以确保同一用户的请求总是被发送到同一台服务器，有助于实现会话保持。</p><ul><li><strong>优点</strong>：<ul><li><strong>会话保持</strong>：根据客户端IP的哈希值来分配请求，确保来自同一IP的请求被发送到相同的后端服务器。这有助于维持客户端与服务器之间的会话状态，特别是对于需要保持登录状态或其他会话信息的应用来说非常重要。</li><li><strong>减少响应时间</strong>：由于同一用户的请求被定向到同一台服务器，可以减少因服务器间会话恢复而产生的延迟，提高应用的响应速度。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>无法处理高并发</strong>：当某个客户端的请求量异常增加时，可能会导致该客户端对应的后端服务器负载过高，而其他服务器却处于相对空闲的状态。                                   </li></ul></li></ul></li><li><p><strong><code>URL Hash</code></strong>：这种策略会根据请求的URL的哈希值来选择服务器，适用于需要根据URL分配请求到特定服务器的场景。</p><ul><li><p><strong>优点</strong>：</p><ul><li><strong>会话保持</strong>：确保相同URL的请求始终被分配到同一台后端服务器，有助于保持会话的一致性，特别适用于需要维护用户登录状态等场景。</li><li><strong>提高效率</strong>：由于相同URL的请求被定向到同一服务器，这可以减少服务器间状态复制的需要，提高缓存效率，尤其适用于后端服务器使用缓存的场景。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>服务器动态变化敏感</strong>：如果后端服务器列表发生变化（如增加或减少服务器），可能会导致哈希结果的变化，进而影响到之前已经分配的服务器，这需要在使用中特别注意。</li></ul></li></ul></li><li><p><strong><code>Fair</code></strong>：根据后端服务器的响应时间进行动态分配请求，实现更合理的负载均衡。nginx本身不支持fair，需要独立安装<code>upstream_fair</code>模块。</p><ul><li><strong>优点</strong>：<ul><li><strong>动态调整</strong>：Fair策略能够动态地根据服务器的实际处理能力来分配请求，这样可以更合理地利用服务器资源，提高整体的处理效率。</li><li><strong>适应性强</strong>：对于那些处理能力不一或处理时间不确定的服务器集群，Fair策略能够更好地平衡负载，避免某些服务器过载而其他服务器空闲的情况发生。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>对突发流量敏感</strong>：由于Fair策略是根据服务器当前的响应时间来分配请求，因此对于突发流量的处理可能不够迅速，需要一段时间来调整分配策略。</li><li><strong>可能引起资源分配不均</strong>：在服务器性能差异较大的情况下，Fair策略可能会导致性能较好的服务器承担更多的请求，而性能较差的服务器则可能处于较为空闲的状态。</li></ul></li></ul></li></ul><h5 id="轮询策略"><a href="#轮询策略" class="headerlink" title="轮询策略"></a><strong>轮询策略</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  upstream <span class="built_in">test</span> &#123;</span><br><span class="line">       server 192.168.174.21:80;</span><br><span class="line">       server 192.168.174.22:80;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>负载均衡状态配置参数：</p><ul><li><p><code>down;</code>    表示不在将用户的请求转发到此主机中；</p></li><li><p><code>backup;</code> 预留的备份机器。当其他所有的非backup机器出现故障时，才会请求backup机器，因此这台机器的压力最轻。</p></li><li><p><code>max_fails</code>：表示允许的最大失败次数。当一个后端服务器在 <code>fail_timeout</code> 时间内连续失败这么多次后，Nginx 会将该服务器标记为不可用，不再向其转发请求。默认值为 1。</p></li><li><p><code>fail_timeout</code>：表示失败检查的时间间隔。在这个时间段内，如果一个后端服务器的失败次数达到了 <code>max_fails</code>，那么 Nginx 会将其标记为不可用。默认值为 10s。 </p></li><li><pre><code class="bash"><span class="comment"># down</span>http {    upstream backend {        server 192.168.174.21 down;        server 192.168.174.22;    }    ...}<span class="comment"># backup;</span>http {    upstream backend {        server 192.168.174.21 backup;        server 192.168.174.22;    }    ...}<span class="comment"># max_fails  fail_timeout</span>http {    upstream backend {        server 192.168.174.21 max_fails=3 fail_timeout=30s;        server 192.168.174.22 max_fails=3 fail_timeout=30s;    }    ...}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### **加权轮询**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">http &#123;</span><br><span class="line">  upstream backend &#123;</span><br><span class="line">      server 192.168.174.21 weight&#x3D;2;</span><br><span class="line">      server 192.168.174.22 weight&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h5 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a><strong>ip_hash</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream backend &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">      server 192.168.174.21; </span><br><span class="line">      server 192.168.174.22;   </span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="URL-Hash"><a href="#URL-Hash" class="headerlink" title="URL Hash"></a><strong>URL Hash</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream backend &#123;</span><br><span class="line">  <span class="built_in">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">      server 192.168.174.21; </span><br><span class="line">      server 192.168.174.22;   </span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a><strong>最少连接</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream backend&#123;</span><br><span class="line">  least_conn;</span><br><span class="line">  server 192.168.174.21;</span><br><span class="line">  server 192.168.174.22;</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fair"><a href="#fair" class="headerlink" title="fair"></a><strong>fair</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        fair;</span><br><span class="line">        server 192.168.174.21;</span><br><span class="line">        server 192.168.174.21;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 参考链接：<a href="https://github.com/gnosek/nginx-upstream-fair" target="_blank" rel="noopener">https://github.com/gnosek/nginx-upstream-fair</a></p><h2 id="6、Nginx会话保持"><a href="#6、Nginx会话保持" class="headerlink" title="6、Nginx会话保持"></a>6、Nginx会话保持</h2><h4 id="6-1-什么是会话保持"><a href="#6-1-什么是会话保持" class="headerlink" title="6.1 什么是会话保持"></a>6.1 什么是会话保持</h4><p>会话保持是一种在<strong>负载均衡环境中维持客户端和服务器之间的交互状态的机制</strong>。</p><p>会话保持的目的是确保来自同一用户的连续请求被分配到同一台服务器上处理，从而保持用户会话的连续性。这对于维护用户登录状态等敏感信息至关重要。以下是一些关键点：</p><ol><li><strong>识别关联性</strong>：会话保持可以识别客户端与服务器之间交互过程的关联性。</li><li><strong>Web开发技术</strong>：在Web开发中，会话保持通常通过Session和Cookie机制来实现。</li><li><strong>Session与Cookie</strong>：Session是一种服务器端的会话管理机制，而Cookie是客户端的一种缓存机制，两者都可以用于跟踪用户会话。</li><li><strong>粘滞会话（Sticky Sessions）</strong>：会话保持有时也称为粘滞会话，它确保一系列相关联的访问请求会被分配到同一台服务器上处理。</li></ol><h4 id="6-2-什么是Cookie和Session"><a href="#6-2-什么是Cookie和Session" class="headerlink" title="6.2 什么是Cookie和Session"></a>6.2 什么是Cookie和Session</h4><p><strong>Cookie和Session都是用于跟踪和管理网站用户状态的技术，但它们的存储位置和使用方式有所不同</strong>。</p><p><strong><code>Cookie</code></strong> 是一种存储在用户浏览器中的小型文本文件，它可以用来记录用户信息，如登录状态、网站偏好设置等。当用户访问一个网站时，服务器会向用户的浏览器发送Cookie，浏览器会保存这些信息。下次用户再次访问该网站时，浏览器会将这些Cookie信息发送回服务器，服务器通过这些信息来识别用户并生成个性化的内容。</p><p><strong><code>Session</code></strong> 则是在服务器端记录用户信息的一种机制。当用户访问服务器时，服务器会创建一个新的Session，并将其唯一标识（如ID）存储在Cookie中，然后发送给客户端浏览器。这样，每次用户与服务器交互时，服务器都可以通过这个Session标识来识别用户，并获取与之相关的信息，如登录状态或购物车内容等。</p><h4 id="6-3-Nginx实现回话保持的手段"><a href="#6-3-Nginx实现回话保持的手段" class="headerlink" title="6.3 Nginx实现回话保持的手段"></a>6.3 Nginx实现回话保持的手段</h4><ol><li><strong>基于客户端IP地址的会话保持</strong>：</li></ol><ul><li><p><strong>ip_hash</strong>：这种方法使用源地址哈希算法，确保来自同一客户端的请求总是被发送到相同的后端服务器。这有助于保持客户端与服务器之间的会话状态，特别是对于需要维持登录状态或其他会话信息的应用来说非常重要。然而，这种方法的缺点是如果后端服务器宕机，会话信息可能会丢失，同时如果多个客户端处于同一局域网内，可能会导致负载不均衡。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream backend &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">      server 192.168.174.21; </span><br><span class="line">      server 192.168.174.22;   </span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>基于后端存储的会话保持</strong>：（了解）</li></ol><ul><li>可以通过数据库、Redis或Memcached等后端存储服务来实现Session的复制和同步。这种方法不依赖于Nginx本身，而是通过后端存储服务的会话同步机制来保持用户会话状态。</li></ul><p>我们知道一个请求在经过一个服务器处理时，服务器会保存相关的会话信息，比如session，但是该请求如果第一个服务器没处理完，通过nginx轮询到第二个服务器上，那么这个服务器是没有会话信息的。</p><p>最典型的一个例子：用户第一次进入一个系统是需要进行登录身份验证的，首先将请求跳转到Tomcat1服务器进行处理，登录信息是保存在Tomcat1 上的，这时候需要进行别的操作，那么可能会将请求轮询到第二个Tomcat2上，那么由于Tomcat2 没有保存会话信息，会以为该用户没有登录，然后继续登录一次，如果有多个服务器，每次第一次访问都要进行登录，这显然是很影响用户体验的。</p><p>这里产生的一个问题也就是集群环境下的 <code>session 共享</code>，如何解决这个问题？</p><ul><li>选择一个中间件，将登录信息保存在一个中间件上，这个中间件可以为Redis这样的数据库。那么第一次登录，我们将session 信息保存在 Redis 中，跳转到第二个服务器时，我们可以先去Redis上查询是否有登录信息，如果有，就能直接进行登录之后的操作了，而不用进行重复登录。</li></ul><h2 id="7、Nginx动静分离"><a href="#7、Nginx动静分离" class="headerlink" title="7、Nginx动静分离"></a>7、Nginx动静分离</h2><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p><strong>Nginx 动静分离是指将动态和静态资源请求分开处理，以提高网站性能和稳定性</strong>。</p><p>Nginx作为一个高性能的Web服务器，可以有效地处理静态资源，如HTML、JavaScript、CSS和图片等文件，而将动态资源请求，通常是指需要后端服务器处理的请求，如PHP、Java等，交给专门的应用服务器处理，如Tomcat。</p><ul><li><strong>提高响应速度</strong>：Nginx对静态资源的处理非常高效，可以快速响应客户端的请求，减少页面加载时间。</li><li><strong>减轻后端压力</strong>：动态资源请求通常涉及到数据库操作，将这些请求交给专门的应用服务器处理，可以避免Nginx承担过多的计算任务，从而保证动态内容的生成和处理更加专注和高效。</li><li><strong>提升网站稳定性</strong>：动静分离可以有效分散服务器负载，避免单点故障，提高整个网站的稳定性和可靠性。</li><li><strong>优化资源利用</strong>：通过合理配置Nginx，可以实现客户端缓存，减少不必要的数据传输，节省带宽。</li></ul><p><img src="https://pics4.baidu.com/feed/b21bb051f8198618fd6fec9e2c438b7f8bd4e63f.jpeg@f_auto?token=52352fb4457ef3d37e57d4271f7865de" alt="img"></p><h3 id="7-2-环境准备"><a href="#7-2-环境准备" class="headerlink" title="7.2 环境准备"></a>7.2 环境准备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 <span class="comment"># 反向代理服务器</span></span><br><span class="line">192.168.174.21 <span class="comment"># 处理静态资源服务器</span></span><br><span class="line">192.168.174.22 <span class="comment"># 处理动态请求服务器</span></span><br></pre></td></tr></table></figure><h4 id="7-2-1-代理服务器配置"><a href="#7-2-1-代理服务器配置" class="headerlink" title="7.2.1 代理服务器配置"></a>7.2.1 代理服务器配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim  /etc/nginx/conf.d/upstream.conf </span></span><br><span class="line">upstream static &#123;</span><br><span class="line">        server 192.168.174.21:80;</span><br><span class="line">&#125;</span><br><span class="line">upstream phpserver &#123;</span><br><span class="line">        server 192.168.174.22:80;</span><br><span class="line">&#125;</span><br><span class="line">     server &#123;</span><br><span class="line">        listen      80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        <span class="comment">#动态资源加载</span></span><br><span class="line">        location ~ \.(php|jsp)$ &#123;</span><br><span class="line">            proxy_pass http://phpserver;</span><br><span class="line">            proxy_set_header Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">#静态资源加载</span></span><br><span class="line">        location ~* .*\.(html|gif|jpg|png|bmp|swf|css|js)$ &#123;</span><br><span class="line">            proxy_pass http://static;</span><br><span class="line">            proxy_set_header Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 检查语法格式</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><h4 id="7-2-2-静态资源服务器配置"><a href="#7-2-2-静态资源服务器配置" class="headerlink" title="7.2.2 静态资源服务器配置"></a>7.2.2 静态资源服务器配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 修改配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/static.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line"></span><br><span class="line">        location ~* \.(html|jpg|png|js|css|gif|bmp|jpeg)$ &#123;</span><br><span class="line">        root /home/www/nginx;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 检查语法格式</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建站点目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /home/www/nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建站点文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "jingtai" &gt; /home/www/nginx/index.html    //模拟静态资源</span></span><br></pre></td></tr></table></figure><h4 id="7-2-3-动态资源服务器配置"><a href="#7-2-3-动态资源服务器配置" class="headerlink" title="7.2.3 动态资源服务器配置"></a>7.2.3 动态资源服务器配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; 安装 PHP 所需的epel源</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 安装 PHP 安装源</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 安装PHP</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum install php71w-xsl php71w php71w-ldap php71w-cli php71w-common php71w-devel php71w-gd php71w-pdo php71w-mysql php71w-mbstring php71w-bcmath php71w-mcrypt   php71w-fpm -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 启动PHP服务</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl enable --now php-fpm   #不启动的话会报502错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 备份 nginx 配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /etc/nginx/conf.d/default.conf   /etc/nginx/conf.d/default.conf.old</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 修改配置</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/default.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen      80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location ~* \.php$ &#123;</span><br><span class="line">            root           /home/nginx/html;   <span class="comment"># 指定网站目录</span></span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;     <span class="comment"># 指定访问地址</span></span><br><span class="line">            fastcgi_index  index.php;   <span class="comment"># 指定默认文件</span></span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;   <span class="comment"># 站点根目录，取决于root配置项</span></span><br><span class="line">            include        fastcgi_params;   <span class="comment"># 包含nginx常量定义</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 检查语法</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 重新加载配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建站点目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mdkir -p /home/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; 创建站点文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "dongtai" &gt; /home/nginx/html/index.php   //模拟动态资源</span></span><br></pre></td></tr></table></figure><h2 id="8、Nginx防盗链"><a href="#8、Nginx防盗链" class="headerlink" title="8、Nginx防盗链"></a>8、Nginx防盗链</h2><h3 id="7-1-介绍-1"><a href="#7-1-介绍-1" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p>​    Nginx可以通过<strong>配置实现防盗链</strong>，以保护网站资源不被未经授权的使用。两个网站 A 和 B， B网站引用了A网站上的图片，这种行为就叫做盗链。 防盗链，就是要防止B引用A的图片。以下是一些常用的方法：</p><p><strong>使用refer模块</strong>：这是Nginx中一个用于检查HTTP请求头中的Referer字段的模块。通过配置valid_referers指令，可以指定允许访问资源的合法来源域名或URL模式。如果请求的Referer头部与这些模式匹配，则认为请求是合法的，否则拒绝访问。这种方法相对简单，但可能受到伪造Referer头的影响。</p><p><strong>Nginx防盗链模块</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_referer_module</span><br></pre></td></tr></table></figure><p><strong>如何区分哪些是不正常的用户？</strong></p><pre><code>HTTP Referer是Header的一部分，当浏览器向Web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器借此可以获得一些信息用于处理，例如防止未经允许的网站盗链图片、文件等。因此HTTP Referer头信息是可以通过程序来伪装生成的，所以通过Referer信息防盗链并非100%可靠，但是，它能够限制大部分的盗链情况。</code></pre><h3 id="7-2-Nginx防盗链配置"><a href="#7-2-Nginx防盗链配置" class="headerlink" title="7.2 Nginx防盗链配置"></a>7.2 Nginx防盗链配置</h3><p><strong>环境准备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 <span class="comment">#受害者(被盗链者)</span></span><br><span class="line">192.168.174.21 <span class="comment">#违法者(盗链者)</span></span><br><span class="line">192.168.174.22 <span class="comment">#旁观者(客户端)</span></span><br></pre></td></tr></table></figure><p><strong>简单了解Nginx默认access日志格式</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328212852810.png" alt="image-20240328212852810"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.1<span class="comment"># 客户端地址</span></span><br><span class="line">-</span><br><span class="line">-  <span class="comment"># 访问用户</span></span><br><span class="line">[28/Mar/2024:21:28:07 +0800]<span class="comment"># 访问时间</span></span><br><span class="line"><span class="string">"GET / HTTP/1.1"</span> <span class="comment"># 请求方法，请求路径，协议版本</span></span><br><span class="line">200<span class="comment"># 状态码</span></span><br><span class="line">7806<span class="comment"># 访问字节大小</span></span><br><span class="line"><span class="string">"-"</span><span class="comment"># 是否从其他链接跳转，链接地址</span></span><br><span class="line"><span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"</span> <span class="comment"># 客户端访问方式</span></span><br><span class="line"><span class="string">"-"</span><span class="comment"># 反向代理地址</span></span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328213256174.png" alt="image-20240328213256174"></p><blockquote><p>上图红色方框中，显示上一级链接地址。如果存在则显示，无则显示<code>&quot;-&quot;</code></p></blockquote><p><strong>受害者环境准备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 <span class="comment">#受害者(被盗链者)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/referers_nginx.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">   listen    80;</span><br><span class="line">   server_name   localhost;</span><br><span class="line">   location / &#123;</span><br><span class="line">      root /usr/share/nginx/html;</span><br><span class="line">      index qf.png;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器访问<a href="http://192.168.174.20" target="_blank" rel="noopener">http://192.168.174.20</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328213615308.png" alt="image-20240328213615308"></p></blockquote><p><strong>非法者环境准备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.21 <span class="comment">#违法者(盗链者)</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/referers_nginx.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">  listen   80;</span><br><span class="line">  server_name   localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /usr/share/nginx/html/index.html </span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;qf.com&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body style=<span class="string">"background-color:red;"</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"http://192.168.174.20/qf.png"</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>游览器访问<a href="http://192.168.174.21" target="_blank" rel="noopener">http://192.168.174.21</a><br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328214339171.png" alt="image-20240328214339171"></p></blockquote><p><strong>查看被盗链主机的访问日志</strong></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328214448292.png" alt="image-20240328214448292"></p><blockquote><p>“<a href="http://192.168.174.21/&quot;" target="_blank" rel="noopener">http://192.168.174.21/&quot;</a> 盗链者地址</p></blockquote><p><strong>禁用盗链IP/URL，受盗链主机配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-server ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="comment"># 日志格式添加"$http_referer"</span></span><br><span class="line">log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                         <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                         <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"><span class="comment"># valid_referers 使用方式                         </span></span><br><span class="line">Syntax: valid_referers none | blocked | server_names | string ...;</span><br><span class="line">Default: —</span><br><span class="line">Context: server, location</span><br><span class="line"></span><br><span class="line"><span class="comment"># none : 允许没有http_referer的请求访问资源；</span></span><br><span class="line"><span class="comment"># blocked : 允许不是http://开头的，不带协议的请求访问资源；</span></span><br><span class="line"><span class="comment"># server_names : 只允许指定ip/域名来的请求访问资源（白名单）。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/referers_nginx.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">   listen    80;</span><br><span class="line">   server_name   localhost;</span><br><span class="line">   location / &#123;</span><br><span class="line">      root /usr/share/nginx/html;</span><br><span class="line">      index qf.png;</span><br><span class="line">      valid_referers none blocked www.jd.com;  <span class="comment"># 允许www.jd.com 允许访问</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> 403;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># none允许空值访问，客户端直接访问。所以加不加ip都可以访问，如果把none擦除，就不能访问了</span></span><br><span class="line">valid_referers none blocked www.jd.com 192.168.174.21; 添加到白名单盗链者就可以继续访问到图片。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>盗链者再次访问图片<br><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328220321210.png" alt="image-20240328220321210"></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">在其中一台机器测试:</span><br><span class="line">测试不带http_refer：</span><br><span class="line">[root@localhost ~]<span class="comment"># curl -I "http://192.168.174.20"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.24.0</span><br><span class="line">Date: Thu, 28 Mar 2024 14:08:14 GMT</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Length: 7806</span><br><span class="line">Last-Modified: Thu, 28 Mar 2024 13:24:12 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"66056f7c-1e7e"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试带非法http_refer:</span><br><span class="line">[root@localhost ~]<span class="comment"># curl -e http://www.baidu.com -I "http://192.168.174.20"</span></span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">Server: nginx/1.24.0</span><br><span class="line">Date: Thu, 28 Mar 2024 14:08:30 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 153</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试带合法的http_refer:</span><br><span class="line">[root@localhost ~]<span class="comment">#  curl -e http://www.jd.com -I "http://192.168.174.20"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.24.0</span><br><span class="line">Date: Thu, 28 Mar 2024 14:09:17 GMT</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Length: 7806</span><br><span class="line">Last-Modified: Thu, 28 Mar 2024 13:24:12 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"66056f7c-1e7e"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># curl -e http://192.168.174.22 -I "http://192.168.174.20"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.24.0</span><br><span class="line">Date: Thu, 28 Mar 2024 14:09:34 GMT</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Length: 7806</span><br><span class="line">Last-Modified: Thu, 28 Mar 2024 13:24:12 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">"66056f7c-1e7e"</span></span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240328221027750.png" alt="image-20240328221027750"></p><h2 id="9、Nginx重定向"><a href="#9、Nginx重定向" class="headerlink" title="9、Nginx重定向"></a>9、Nginx重定向</h2><h3 id="9-1-Nginx-rewrite介绍"><a href="#9-1-Nginx-rewrite介绍" class="headerlink" title="9.1 Nginx rewrite介绍"></a>9.1 Nginx rewrite介绍</h3><p>Rewrite对称URL Rewrite，即URL重写，就是把传入Web的请求重定向到其他URL的过程。</p><ul><li>URL Rewrite最常见的应用是URL伪静态化，是将动态页面显示为静态页面方式的一种技术。比如<a href="http://www.123.com/news/index.php?id=123" target="_blank" rel="noopener">http://www.123.com/news/index.php?id=123</a> 使用URLRewrite 转换后可以显示为 <a href="http://www.123.com/news/123.html对于追求完美主义的网站设计师，就算是网页的地址也希望看起来尽量简洁明快。理论上，搜索引擎更喜欢静态页面形式的网页，搜索引擎对静态页面的评分一般要高于动态页面。所以，UrlRewrite可以让我们网站的网页更容易被搜索引擎所收录。" target="_blank" rel="noopener">http://www.123.com/news/123.html对于追求完美主义的网站设计师，就算是网页的地址也希望看起来尽量简洁明快。理论上，搜索引擎更喜欢静态页面形式的网页，搜索引擎对静态页面的评分一般要高于动态页面。所以，UrlRewrite可以让我们网站的网页更容易被搜索引擎所收录。</a></li><li>从安全角度上讲，如果在URL中暴露太多的参数，无疑会造成一定量的信息泄漏，可能会被一些黑客利用，对你的系统造成一定的破坏，所以静态化的URL地址可以给我们带来更高的安全性。</li><li>实现网站地址跳转，例如用户访问360buy.com，将其跳转到jd.com。例如当用户访问tianyun.com的80端口时，将其跳转到443端口。</li></ul><h3 id="9-2-Rewrite-相关指令"><a href="#9-2-Rewrite-相关指令" class="headerlink" title="9.2  Rewrite 相关指令"></a>9.2  Rewrite 相关指令</h3><ul><li><strong>return指令</strong>：用于返回指定的HTTP状态码，通常与重定向一起使用，例如<code>return 301 $uri</code>会将请求重定向到新的URI。</li><li><strong>if语句</strong>：允许根据某些条件执行特定的重写规则。这个指令可以让你根据不同的请求头或请求参数来应用不同的重写规则。</li><li><strong>set指令</strong>：用于设置变量，这些变量可以在rewrite规则中被引用，或者在其他地方用于进一步的处理。</li><li><strong>rewrite指令</strong>：这是实现URL重写的关键指令，它根据正则表达式部分的内容，将请求重定向到替换（replacement）部分，结尾是标志（flag）。</li></ul><h4 id="9-2-1-if语句"><a href="#9-2-1-if语句" class="headerlink" title="9.2.1 if语句"></a>9.2.1 if语句</h4><p><strong>应用环境</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server块，location块</span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123; … &#125;</span><br><span class="line"><span class="keyword">if</span> 可以支持如下条件判断匹配符号</span><br><span class="line">~ 正则匹配 (区分大小写)    </span><br><span class="line">~*     正则匹配 (不区分大小写)</span><br><span class="line">!~                  正则不匹配 (区分大小写)</span><br><span class="line">!~*            正则不匹配  (不区分大小写)</span><br><span class="line">-f 和!-f     用来判断是否存在文件</span><br><span class="line">-d 和!-d     用来判断是否存在目录</span><br><span class="line">-e 和!-e     用来判断是否存在文件或目录</span><br><span class="line">-x 和!-x     用来判断文件是否可执行</span><br><span class="line"></span><br><span class="line">在匹配过程中可以引用一些Nginx的全局变量</span><br><span class="line"><span class="variable">$args</span>请求中的参数;</span><br><span class="line"><span class="variable">$document_root</span>    针对当前请求的根路径设置值;</span><br><span class="line"><span class="variable">$host</span>请求信息中的<span class="string">"Host"</span>，如果请求中没有Host行，则等于设置的服务器名;</span><br><span class="line"><span class="variable">$limit_rate</span>对连接速率的限制;</span><br><span class="line"><span class="variable">$request_method</span>请求的方法，比如<span class="string">"GET"</span>、<span class="string">"POST"</span>等;</span><br><span class="line"><span class="variable">$remote_addr</span>客户端地址;</span><br><span class="line"><span class="variable">$remote_port</span>客户端端口号;</span><br><span class="line"><span class="variable">$remote_user</span>客户端用户名，认证用;</span><br><span class="line"><span class="variable">$request_filename</span>   当前请求的文件路径名（带网站的主目录/usr/<span class="built_in">local</span>/nginx/html/images /a.jpg）</span><br><span class="line"><span class="variable">$request_uri</span>当前请求的文件路径名（不带网站的主目录/images/a.jpg）</span><br><span class="line"><span class="variable">$query_string</span>与<span class="variable">$args</span>相同;</span><br><span class="line"><span class="variable">$scheme</span>用的协议，比如http或者是https</span><br><span class="line"><span class="variable">$server_protocol</span>请求的协议版本，<span class="string">"HTTP/1.0"</span>或<span class="string">"HTTP/1.1"</span>;</span><br><span class="line"><span class="variable">$server_addr</span> 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费);</span><br><span class="line"><span class="variable">$server_name</span>请求到达的服务器名;</span><br><span class="line"><span class="variable">$document_uri</span> 与<span class="variable">$uri</span>一样，URI地址;</span><br><span class="line"><span class="variable">$server_port</span> 请求到达的服务器端口号;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-Rewrite-flag标记位"><a href="#9-2-2-Rewrite-flag标记位" class="headerlink" title="9.2.2 Rewrite flag标记位"></a>9.2.2 Rewrite flag标记位</h4><p>Nginx的rewrite指令支持多种flag，用于控制重写规则的行为。以下是一些常用的flag：</p><ol><li><strong>last</strong>：表示完成当前的重写规则后，停止处理后续的重写规则,从头再匹配。</li><li><strong>break</strong>：表示完全停止处理后续的重写规则。</li><li><strong>redirect</strong>：表示将请求重定向到新的URI，并返回HTTP状态码为302。</li><li><strong>permanent</strong>：表示将请求永久重定向到新的URI，并返回HTTP状态码为301。</li></ol><p>这些flag可以根据需要组合使用，以实现不同的URL重写和重定向行为。例如，<code>rewrite ^/old-url/(.*)$ /new-url/$1 permanent;</code>中的<code>permanent</code> flag表示将请求永久重定向到新的URI，并返回HTTP状态码为301。</p><p><strong>last和break区别</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/last_break.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    location /<span class="built_in">break</span>/ &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        rewrite .* /<span class="built_in">test</span>/break.html <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /last/ &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        rewrite .* /<span class="built_in">test</span>/last.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /<span class="built_in">test</span>/ &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        rewrite .* /<span class="built_in">test</span>/test.html <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost conf.d]<span class="comment"># cd /usr/share/nginx/html/</span></span><br><span class="line">[root@localhost html]<span class="comment"># mkdir test</span></span><br><span class="line">[root@localhost html]<span class="comment"># echo "last" &gt; test/last.html</span></span><br><span class="line">[root@localhost html]<span class="comment"># echo "break" &gt; test/break.html</span></span><br><span class="line">[root@localhost html]<span class="comment"># echo "test" &gt; test/test.html</span></span><br></pre></td></tr></table></figure><ul><li><p><code>last 标记在本条 rewrite 规则执行完后，会对其所在的 server { … } 标签重新发起请求;</code></p></li><li><p><code>break 标记则在本条规则匹配完成后，停止匹配，不再做后续的匹配；</code></p></li></ul><p><strong>redirect 和 permanent区别</strong></p><p>则是返回的不同方式的重定向，对于客户端来说一般状态下是没有区别的。而对于搜索引擎，相对来说301的重定向更加友好，如果我们把一个地址采用301跳转方式跳转的话，搜索引擎会把老地址的相关信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。使用302重定向时，搜索引擎(特别是google)有时会查看跳转前后哪个网址更直观，然后决定显示哪个，如果它觉的跳转前的URL更好的话，也许地址栏不会更改。</p><h4 id="9-2-3-Rewrite-常见案例"><a href="#9-2-3-Rewrite-常见案例" class="headerlink" title="9.2.3 Rewrite 常见案例"></a>9.2.3 Rewrite 常见案例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 rewrite.tanke.love</span><br><span class="line"><span class="comment"># 举例一：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/rewrite_server.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  rewrite.tanke.love;</span><br><span class="line">        location /a &#123;</span><br><span class="line">        root /html;</span><br><span class="line">        index   index.html index.htm;</span><br><span class="line">        rewrite .* /b/index.html permanent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /b &#123;</span><br><span class="line">        root    /html;</span><br><span class="line">        index   index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 创建网站资源路径</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /html/&#123;a,b&#125;</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "a" &gt; /html/a/index.html</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "b" &gt; /html/b/index.html</span></span><br><span class="line"><span class="comment"># 检查配置文件语法是否错误,热加载nginx</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 游览器访问http://rewrite.tanke.love/a</span></span><br></pre></td></tr></table></figure><blockquote><p>上述案例使用游览器访问<a href="http://rewrite.tanke.love/a后会永久重定向至http://rewrite.tanke.love/b/index.html" target="_blank" rel="noopener">http://rewrite.tanke.love/a后会永久重定向至http://rewrite.tanke.love/b/index.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 rewrite.tanke.love</span><br><span class="line"><span class="comment"># 举例二：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/rewrite02_server.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  rewrite.tanke.love;</span><br><span class="line"></span><br><span class="line">    location /2023/a &#123;</span><br><span class="line">        root    /var/www/html;</span><br><span class="line">        index   index.html;</span><br><span class="line">        rewrite ^/2023/(.*)$ /2024/<span class="variable">$1</span> permanent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /2024/a &#123;</span><br><span class="line">        root    /var/www/html;</span><br><span class="line">        index   index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备网站资源目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /var/www/html/&#123;2023,2024&#125;/a</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "2023" &gt; /var/www/html/2023/a/index.html</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "2024" &gt; /var/www/html/2024/a/index.html</span></span><br><span class="line">[root@localhost ~]<span class="comment"># tree /var/www/</span></span><br><span class="line">/var/www/</span><br><span class="line">└── html</span><br><span class="line">    ├── 2023</span><br><span class="line">    │   └── a</span><br><span class="line">    │       └── index.html</span><br><span class="line">    └── 2024</span><br><span class="line">        └── a</span><br><span class="line">            └── index.html</span><br><span class="line"><span class="comment"># 检查配置文件语法是否错误,热加载nginx</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 游览器访问http://rewrite.tanke.love/2023/a</span></span><br></pre></td></tr></table></figure><blockquote><p>上述案例：当用户游览器访问<a href="http://rewrite.tanke.love/2023/a时，将永久重定向至http://rewrite.tanke.love/2024/a/index.html" target="_blank" rel="noopener">http://rewrite.tanke.love/2023/a时，将永久重定向至http://rewrite.tanke.love/2024/a/index.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 rewrite.tanke.love</span><br><span class="line"><span class="comment"># 举例三：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim rewrite03_server.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen    80;</span><br><span class="line">  server_name rewrite.tanke.love;</span><br><span class="line">  location / &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="variable">$host</span> ~* rewrite.tanke.love ) &#123;</span><br><span class="line">        rewrite .* http://baidu.com permanent;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx </span></span><br><span class="line"><span class="comment"># 游览器访问http://rewrite.tanke.love</span></span><br></pre></td></tr></table></figure><blockquote><p>上述案例：当用户访问<a href="http://rewrite.tanke.love/是永久重定向至http://baidu.com" target="_blank" rel="noopener">http://rewrite.tanke.love/是永久重定向至http://baidu.com</a></p><p><code>$host</code>为客户端访问的域名。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 rewrite.tanke.love</span><br><span class="line"><span class="comment"># 举例四：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim rewrite04_server.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen    80;</span><br><span class="line">  server_name rewrite.tanke.love;</span><br><span class="line">  location /a &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="variable">$host</span> ~* rewrite.tanke.love ) &#123;</span><br><span class="line">        rewrite .* http://192.168.21<span class="variable">$request_uri</span> permanent;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重定向主机配置文件准备</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/default.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">  listen   80;</span><br><span class="line">  server_name   localhost;</span><br><span class="line">  location /a &#123;</span><br><span class="line">    root /usr/share/nginx/;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir /usr/share/nginx/a</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "192.168.172.21" &gt; /usr/share/nginx/a/index.html</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>上述案例：当用户访问<a href="http://rewrite.tanke.love/a是永久重定向至http://192.168.174.21/a" target="_blank" rel="noopener">http://rewrite.tanke.love/a是永久重定向至http://192.168.174.21/a</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 rewrite.tanke.love</span><br><span class="line"></span><br><span class="line"><span class="comment">#  http://rewrite.tanke.love/login/qf.html ==&gt;  http://rewrite.tanke.love/reg/login.html?user=qf</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/rewrite06_server.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">   listen    80;</span><br><span class="line">   server_name   rewrite.tanke.love;</span><br><span class="line"></span><br><span class="line">   location /login &#123;</span><br><span class="line">       root   /usr/share/nginx/html;</span><br><span class="line">       rewrite ^/login/(.*)\.html$ http://<span class="variable">$host</span>/reg/login.html?user=<span class="variable">$1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   location /reg &#123;</span><br><span class="line">       root /usr/share/nginx/html;</span><br><span class="line">       index login.html;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /usr/share/nginx/html/reg</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "login" &gt; /usr/share/nginx/html/reg/login.html</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>定义了两个路径：/login和/reg。</p><p>对于/login路径，它设置了根目录为”/usr/share/nginx/html”。它还使用了一个正则表达式重写规则，将URL中的”/login/“后面的内容作为参数传递给”/reg/login.html”页面，并附加在URL中作为查询参数”user”的值。</p><p>对于/reg路径，它同样设置了根目录为”/usr/share/nginx/html”，并将默认索引文件设置为”login.html”。</p><p>这段配置的作用是将访问/login路径的请求重定向到/reg路径下的”login.html”页面，并将原始路径中的参数传递给该页面。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">192.168.174.20 rewrite.tanke.love</span><br><span class="line"><span class="comment"># 举例7</span></span><br><span class="line"><span class="comment"># http://rewrite.tanke.love/qf/11-22-33/1.html  ==&gt;  http://rewrite.tanke.love/qf/11/22/33/1.html</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/rewrite07_server.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">  listen   80;</span><br><span class="line">  server_name rewrite.tanke.love;</span><br><span class="line">       location /qf &#123;</span><br><span class="line">            rewrite ^/qf/([0-9]+)-([0-9]+)-([0-9]+)(.*)$ /qf/<span class="variable">$1</span>/<span class="variable">$2</span>/<span class="variable">$3</span><span class="variable">$4</span> permanent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /qf/11/22/33 &#123;</span><br><span class="line">                root /html;</span><br><span class="line">                index   1.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 资源文件配置</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mdkir  -p /html/qf/11/22/33/</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "qf" &gt; /html/qf/11/22/33/1.html </span></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br><span class="line"><span class="comment"># 游览器访问</span></span><br><span class="line">http://rewrite.tanke.love/qf/11-22-33/1.html</span><br></pre></td></tr></table></figure><blockquote><p>定义了两个路径：/qf和/qf/11/22/33。</p><p>对于/qf路径，它使用了一个正则表达式重写规则，将URL中的”/qf/“后面的内容按照数字进行分组，并将这些数字作为参数传递给新的URL路径。新的URL路径为”/qf/11/22/33”，其中<code>$1、$2、$3</code>分别代表第一组、第二组和第三组的数字，<code>$4</code>表示剩余的字符串。这个重写规则使用了”permanent”标志，表示返回301永久重定向。</p><p>对于/qf/11/22/33路径，它设置了根目录为”/html”，并将默认索引文件设置为”1.html”。</p><p>这段配置的作用是将访问/qf路径的请求重定向到/qf/11/22/33路径下的”1.html”页面，并根据原始路径中的参数进行URL的重新组织。</p></blockquote><h4 id="9-2-4-set指令使用"><a href="#9-2-4-set指令使用" class="headerlink" title="9.2.4 set指令使用"></a>9.2.4 set指令使用</h4><p>​    set 指令是用于定义一个变量，并且赋值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server,location,if</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\hosts <span class="comment"># win域名解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#http://liubei.tanke.love ==&gt; http://rewrite.tanke.love/liubei</span></span><br><span class="line"><span class="comment">#http://guanyu.tanke.love ==&gt; http://rewrite.tanke.love/guanyu</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /usr/share/nginx/html/&#123;liubei,guanyu&#125;</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "liubei.." &gt; /usr/share/nginx/html/liubei/index.html</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "guanyu.." &gt; /usr/share/nginx/html/guanyu/index.html</span></span><br><span class="line"></span><br><span class="line">编辑配置文件:</span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/set_server.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  rewrite.tanke.love;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         root   /usr/share/nginx/html;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">         <span class="keyword">if</span> ( <span class="variable">$host</span> ~* <span class="string">"^rewrite.tanke.love$"</span> ) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> ( <span class="variable">$host</span> ~* <span class="string">"^(.*)\.tanke\.love$"</span> ) &#123;</span><br><span class="line">                <span class="built_in">set</span> <span class="variable">$user</span> <span class="variable">$1</span>;</span><br><span class="line">                rewrite .* http://rewrite.tanke.love/<span class="variable">$user</span> permanent;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    location /liubei &#123;</span><br><span class="line">         root /usr/share/nginx/html;</span><br><span class="line">         index  index.html index.hml;</span><br><span class="line">        &#125;</span><br><span class="line">    location /guanyu &#123;</span><br><span class="line">         root /usr/share/nginx/html;</span><br><span class="line">         index index.html index.hml;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>该配置文件定义了一个监听在端口 80 上的服务器，并指定了服务器名称为 “rewrite.tanke.love”。它包含三个 <code>location</code> 块，分别对应不同的路径：</p><ul><li><code>/</code>：根路径，将请求映射到 <code>/usr/share/nginx/html</code> 目录下的 <code>index.html</code> 或 <code>index.htm</code> 文件。如果请求的主机名是 “rewrite.tanke.love”，则直接返回该文件；否则，如果主机名匹配正则表达式 <code>^(.*)\.tanke\.love$</code>，则将主机名中的第一个部分作为变量 <code>$user</code> 的值，并将请求重定向到 <code>http://rewrite.tanke.love/$user</code>，使用永久重定向（301）。</li><li><code>/liubei</code>：将请求映射到 <code>/usr/share/nginx/html</code> 目录下的 <code>index.html</code> 或 <code>index.hml</code> 文件。</li><li><code>/guanyu</code>：将请求映射到 <code>/usr/share/nginx/html</code> 目录下的 <code>index.html</code> 或 <code>index.hml</code> 文件。</li></ul><p>这个配置文件的作用是根据请求的主机名和路径来处理请求，并根据需要进行重定向。</p></blockquote><h4 id="9-2-5-return指令使用"><a href="#9-2-5-return指令使用" class="headerlink" title="9.2.5 return指令使用"></a>9.2.5 return指令使用</h4><p>​    return 指令用于返回状态码给客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作用域</span></span><br><span class="line">server,location,<span class="keyword">if</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果访问的.sh结尾的文件则返回403操作拒绝错误</span></span><br><span class="line"><span class="comment"># http://rewrite.tanke.love/1.sh   返回403</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/nginx/conf.d/return_server.conf </span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  rewrite.tanke.love;</span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/http_access.log  main;</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    location ~* \.sh$ &#123;</span><br><span class="line">        <span class="built_in">return</span> 403;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl reload nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>定义了一个监听在端口 80 上的服务器，并指定了服务器名称为 “rewrite.tanke.love”。它包含两个 <code>location</code> 块，分别对应不同的路径：</p><ul><li><code>/</code>：根路径，将请求映射到 <code>/usr/share/nginx/html</code> 目录下的 <code>index.html</code> 或 <code>index.htm</code> 文件。</li><li><code>~* \.sh$</code>：匹配以 <code>.sh</code> 结尾的文件名，返回 HTTP 状态码 403（禁止访问）。</li></ul><p>这个配置文件的作用是处理请求，并根据请求的文件类型进行相应的操作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https重定向</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  *.vip9999.top vip9999.top;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$host</span> ~* <span class="string">"^www.vip9999.top$|^vip9999.top$"</span> ) &#123;</span><br><span class="line">                <span class="built_in">return</span> 301 https://www.vip9999.top<span class="variable">$request_uri</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$host</span> ~* <span class="string">"^(.*).vip9999.top$"</span> ) &#123;</span><br><span class="line">                <span class="built_in">set</span> <span class="variable">$user</span> <span class="variable">$1</span>;</span><br><span class="line">                <span class="built_in">return</span> 301 https://www.vip9999.top/<span class="variable">$user</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  www.vip9999.top;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                root      /usr/share/nginx/html;</span><br><span class="line">                index     index.php index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root           /usr/share/nginx/html;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate cert/214025315060640.pem;</span><br><span class="line">        ssl_certificate_key cert/214025315060640.key;</span><br><span class="line">        ssl_session_cache shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  10m;</span><br><span class="line">        ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="10、Nginx-Location-指令详解"><a href="#10、Nginx-Location-指令详解" class="headerlink" title="10、Nginx Location 指令详解"></a>10、Nginx Location 指令详解</h2><p>​    Nginx 的 HTTP 配置主要包括三个区块，结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http &#123; <span class="comment"># 这个是协议级别</span></span><br><span class="line">　　include mime.types;</span><br><span class="line">　　default_type application/octet-stream;</span><br><span class="line">　　keepalive_timeout 65;</span><br><span class="line">　　gzip on;</span><br><span class="line">　　　　server &#123; <span class="comment"># 这个是服务级别</span></span><br><span class="line">　　　　　　listen 80;</span><br><span class="line">　　　　　　server_name localhost;</span><br><span class="line">　　　　　　　　location / &#123;  <span class="comment"># 这个是请求级别</span></span><br><span class="line">　　　　　　　　　　root html;</span><br><span class="line">　　　　　　　　　　index index.html index.htm;</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>协议级别</code>：这部分配置指定了使用的协议为HTTP，并包含了一个名为mime.types的文件，用于定义文件扩展名与MIME类型的映射关系。</li><li><code>服务级别</code>：这部分配置指定了监听的端口号为80，服务器名称为localhost。<code>虚拟主机</code>。</li><li><code>请求级别</code>：这部分配置指定了根目录为html，默认的索引文件为index.html和index.htm。</li></ol><h3 id="10-1-Location-区块"><a href="#10-1-Location-区块" class="headerlink" title="10.1 Location 区块"></a>10.1 Location 区块</h3><ul><li>location 是在 <code>server</code> 块中配置，根据<code>不同的 URl</code>使用不同的配置，来处理<code>不同的请求</code>。</li><li>location 是<code>有顺序</code>的，会被<code>第一个匹配</code>的location 处理。</li></ul><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~|@] pattern&#123;……&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-location-前缀含义"><a href="#10-2-location-前缀含义" class="headerlink" title="10.2 location 前缀含义"></a>10.2 location 前缀含义</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=    表示精确匹配，优先级也是最高的,只有请求的 URI 与指定的字符串完全相等时才会匹配。</span><br><span class="line">^~   表示如果该模式匹配成功，将停止搜索其他匹配项并立即处理该请求。</span><br><span class="line">~    表示区分大小写的正则匹配  </span><br><span class="line">~*   表示不区分大小写的正则匹配</span><br><span class="line">!~   表示区分大小写不匹配的正则</span><br><span class="line">!~*  表示不区分大小写不匹配的正则</span><br><span class="line">/    通用匹配，任何请求都会匹配到</span><br></pre></td></tr></table></figure><h4 id="10-2-1-location-配置示例"><a href="#10-2-1-location-配置示例" class="headerlink" title="10.2.1 location 配置示例"></a>10.2.1 location 配置示例</h4><ol><li>没有修饰符 <code>/</code>表示：必须以指定模式开始</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /home/www/nginx/abc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "2.html" &gt;  /home/www/nginx/abc/2.html</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.tanke.love;</span><br><span class="line"></span><br><span class="line">    location  /abc &#123;</span><br><span class="line">        root    /home/www/nginx;</span><br><span class="line">        index   2.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">那么，如下是对的：</span><br><span class="line">http://www.tanke.love/abc</span><br></pre></td></tr></table></figure><ol start="2"><li><code>=</code>表示：必须与指定的模式精确匹配</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo "a" &gt; /usr/share/nginx/html/a.html</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "b" &gt; /usr/share/nginx/html/b.html</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.tanke.love;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        index a.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location = / &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        index b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进行测试：</span><br><span class="line">http://www.tanke.love</span><br><span class="line">http://www.tanke.love/a.html</span><br></pre></td></tr></table></figure><ol start="3"><li><code>~</code> 表示：指定的正则表达式要区分大小写</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /home/www/nginx/&#123;abc,ABC&#125;</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "abc" &gt; /home/www/nginx/abc/2.html </span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "ABC" &gt; /home/www/nginx/ABC/2.html </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        server_name www.tanke.love;</span><br><span class="line">        location ~ /abc &#123;</span><br><span class="line">                root /home/www/nginx;</span><br><span class="line">                index 2.html index.html;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ /ABC &#123;</span><br><span class="line">                root /home/www/nginx;</span><br><span class="line">                index 2.html index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么：</span><br><span class="line">http://www.tanke.love/abc/</span><br></pre></td></tr></table></figure><ol start="4"><li><code>~*</code> 表示：指定的正则表达式不区分大小写</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        server_name www.tanke.love;</span><br><span class="line">        location ~* /abc &#123;</span><br><span class="line">                root /home/www/nginx;</span><br><span class="line">                index 2.html index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">那么：</span><br><span class="line">http://www.tanke.love/ABC/</span><br></pre></td></tr></table></figure><ol start="5"><li><code>^~</code> ：类似于无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配，那么就停止搜索其他模式了。</li></ol><h4 id="10-2-2-location-查找顺序、优先级"><a href="#10-2-2-location-查找顺序、优先级" class="headerlink" title="10.2.2 location 查找顺序、优先级"></a>10.2.2 location 查找顺序、优先级</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">= 大于 ^~  大于 ~|~*|!~|!~* 大于 /</span><br><span class="line">多个location配置的情况下匹配顺序为：首先匹配 =，其次匹配^~, 其次是按正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</span><br><span class="line">================================================</span><br><span class="line">(1) =:表示完全匹配;</span><br><span class="line">(2) ^~:匹配URI的前缀，如果一个URI同时满足两个规则的话，匹配最长的规则;</span><br><span class="line">(3) ~:匹配正则表达式，大小写敏感；</span><br><span class="line">(4) ~*:匹配正则表达式，大小写不敏感；</span><br><span class="line">优先级：（1）&gt; (2) &gt; (3) = (4)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">location 区段匹配示例</span><br><span class="line"></span><br><span class="line">location = / &#123;</span><br><span class="line">　　<span class="comment"># 只匹配 / 的查询.</span></span><br><span class="line">　　[ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">　　<span class="comment"># 匹配任何以 / 开始的查询，但是正则表达式与一些较长的字符串将被首先匹配。</span></span><br><span class="line">　　[ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">　　<span class="comment"># 匹配任何以 /images/ 开始的查询并且停止搜索，不检查正则表达式。</span></span><br><span class="line">　　[ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">　　<span class="comment"># 匹配任何以gif, jpg, or jpeg结尾的文件，但是所有 /images/ 目录的请求将在Configuration C中处理。</span></span><br><span class="line">　　[ configuration D ]</span><br><span class="line">&#125; </span><br><span class="line">各请求的处理如下例：</span><br><span class="line">/ → configuration A</span><br><span class="line">/documents/document.html → configuration B</span><br><span class="line">/images/1.gif → configuration C</span><br><span class="line">/documents/1.jpg → configuration D</span><br></pre></td></tr></table></figure><h4 id="10-2-3-root-和alias-指令区别"><a href="#10-2-3-root-和alias-指令区别" class="headerlink" title="10.2.3  root 和alias 指令区别"></a>10.2.3  root 和alias 指令区别</h4><p>在 Nginx 配置中，<code>location</code> 指令用于定义如何处理不同的 URL 请求。其中 <code>root</code> 和 <code>alias</code> 是两个常用的指令，它们的含义如下：</p><ol><li><strong>root</strong>：<code>root</code> 指令用于指定请求的根目录。当客户端发起请求时，Nginx 会将请求的 URI 与指定的根目录进行拼接，以确定实际的文件路径。例如，如果 <code>root</code> 设置为 <code>/var/www/html</code>，而客户端请求的是 <code>/index.html</code>，那么 Nginx 将会查找文件 <code>/var/www/html/index.html</code>。</li><li><strong>alias</strong>：<code>alias</code> 指令用于指定请求的别名目录。与 <code>root</code> 不同，<code>alias</code> 不会将请求的 URI 与指定的目录进行拼接，而是直接使用指定的目录作为请求的根目录。例如，如果 <code>alias</code> 设置为 <code>/var/www/images</code>，而客户端请求的是 <code>/index.jpg</code>，那么 Nginx 将会查找文件 <code>/var/www/images/index.jpg</code>。</li></ol><p>需要注意的是，<code>root</code> 和 <code>alias</code> 只能选择其中一个来使用，不能同时使用。通常情况下，建议使用 <code>root</code> 指令来指定请求的根目录，因为它更加直观和简单。</p><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name rewrite.tanke.love;</span><br><span class="line">  location /img &#123;</span><br><span class="line">    <span class="comment"># root /var/www/image;</span></span><br><span class="line">    <span class="comment">#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</span></span><br><span class="line">    <span class="built_in">alias</span> /var/www/image;</span><br><span class="line">    <span class="comment">#若按照上述配置的话，则访问/img/目录里面的文件时，nginx会自动去/var/www/image/目录找文件</span></span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">访问rewrite.tanke.love/img测试</span><br></pre></td></tr></table></figure><ul><li><code>alias</code> 是一个目录别名的定义;</li><li><code>root</code> 则是最上层目录的定义。</li><li>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的,而root则可有可无。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://l66stbz.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat运维实战</title>
    <link href="https://l66stbz.github.io/2024/08/08/Tomcat%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/"/>
    <id>https://l66stbz.github.io/2024/08/08/Tomcat%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/</id>
    <published>2024-08-08T13:50:00.000Z</published>
    <updated>2024-08-23T08:00:32.255Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Tomcat-运维实战"><a href="#Tomcat-运维实战" class="headerlink" title="Tomcat 运维实战"></a>Tomcat 运维实战</h2><p>[TOC]</p><h3 id="1、Java常识"><a href="#1、Java常识" class="headerlink" title="1、Java常识"></a>1、Java常识</h3><ul><li><code>JVM（Java虚拟机）</code>：<ul><li>是一个抽象的计算机器，它使计算机能够运行Java程序。它是Java运行环境（JRE）的关键部分。JVM将Java字节码转换为机器语言，使得Java程序可以在不同的平台上运行而无需修改。</li></ul></li><li><strong>JRE（Java运行环境）</strong>：<ul><li>JRE是一组软件工具，提供运行Java应用程序所需的环境。它包括JVM、类库和其他支持文件。当您在系统上安装Java时，您实际上安装的是JRE。JRE足以运行Java应用程序。</li></ul></li><li><strong>Java类库</strong>：<ul><li>Java类库（也称为Java API - 应用程序编程接口）是一组预先编写的类、接口和包，为Java应用程序提供常用功能。开发人员可以利用它们来高效地构建Java应用程序。</li></ul></li></ul><h4 id="1-1-什么是JAVA虚拟机"><a href="#1-1-什么是JAVA虚拟机" class="headerlink" title="1.1 什么是JAVA虚拟机"></a><strong>1.1 什么是JAVA虚拟机</strong></h4><p>Java虚拟机（JVM）是Java平台的核心组件之一，它是一个在物理计算机上模拟的计算机，能够执行Java字节码。JVM的主要功能包括：</p><ol><li><strong>字节码执行</strong>：JVM执行Java编译器生成的字节码文件（.class文件），这些字节码文件包含了被编译的Java程序的中间代码。JVM通过解释字节码或将其即时编译为本地机器代码来执行Java程序。</li><li><strong>内存管理</strong>：JVM负责分配和管理Java程序运行所需的内存。这包括对内存的动态分配、垃圾回收以及内存区域的划分（如堆、栈、方法区等）。</li><li><strong>垃圾回收</strong>：JVM中的垃圾回收器负责自动回收不再使用的内存对象，以避免内存泄漏和内存溢出问题，从而保证Java程序的稳定性和可靠性。</li></ol><p><strong>白话文解释：</strong></p><p>所谓虚拟机，就是一台虚拟的计算机。他是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<code>系统虚拟机</code>和<code>程序虚拟机</code>。大名鼎鼎的VisualBox、VMware就属于系统虚拟机。他们完全是对物理计算机的仿真。提供了一个可以运行完整操作系统的软件平台。<br>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。无论是系统虚拟机还是程序虚拟机，在上面运行的软件都限制于虚拟机提供的资源中。</p><h4 id="1-2-JAVA-如何做到跨平台"><a href="#1-2-JAVA-如何做到跨平台" class="headerlink" title="1.2 JAVA 如何做到跨平台"></a><strong>1.2 JAVA 如何做到跨平台</strong></h4><p>Java实现跨平台的关键在于其独特的编译和执行方式：</p><ol><li><strong>字节码</strong>： Java源代码首先被编译成<code>Java字节码</code>（.class文件），而不是针对特定平台的本地机器代码。这个字节码是与<code>平台无关</code>的中间代码，它包含了被执行的程序逻辑，但与具体的操作系统和硬件无关。</li><li><strong>JVM（Java虚拟机）</strong>： Java字节码由Java虚拟机（JVM）执行。JVM是一个针对特定平台的软件程序，它负责在运行时将字节码翻译成本地机器码，并在特定平台上执行。因此，只需为每个平台实现一个JVM，就能够在该平台上运行Java程序。</li><li><strong>一次编写，到处运行</strong>： 由于Java程序被编译成平台无关的字节码，所以同一份Java代码可以在任何安装了Java虚拟机的平台上运行，而不需要对代码进行修改或重新编译。这就实现了“<code>一次编写，到处运行</code>”的理念，使得Java具有了强大的跨平台能力。</li></ol><p>Java实现跨平台的核心是将源代码编译成与<code>平台无关</code>的<code>字节码</code>，并由Java虚拟机在各个平台上解释和执行字节码。这种设计使得Java成为了一种广泛应用的<code>跨平台</code>编程语言。同一个JAVA程序(JAVA字节码的集合)，通过JAVA虚拟机(JVM)运行于各大主流操作系统平台<br>比如Windows、CentOS、Ubuntu等。程序以虚拟机为中介，来实现跨平台。</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562148557621.png" alt="1562148557621"></p><h4 id="1-3-常用虚拟机参数"><a href="#1-3-常用虚拟机参数" class="headerlink" title="1.3 常用虚拟机参数"></a>1.3 常用虚拟机参数</h4><p>Java虚拟机（JVM）提供了多种类型的参数，用于配置和优化Java应用程序的运行。其中，常见的参数类型包括以下三种：</p><ul><li><p><strong>标准参数</strong></p><ul><li>这些参数对所有的JVM都是通用的，例如 <code>-version</code>、<code>-help</code> 等。它们用于控制JVM的一般行为，如打印版本信息、显示帮助信息等。标准参数中包括功能和输出的参数都是很稳定的，很可能在将来的JVM版本中不会改变。你可以用 java 命令（或者是用 java -help）检索出所有标准参数。</li></ul></li><li><h5 id="X-类型参数"><a href="#X-类型参数" class="headerlink" title="X  类型参数"></a>X  类型参数</h5><ul><li><code>非标准化</code>的参数，在将来的版本中可能会改变。所有的这类参数都以 -X 开始。是特定于JVM实现的，可能会在不同版本的JVM之间有所差异。它们用于配置JVM的高级功能，如内存管理、垃圾回收算法、线程堆栈大小等。</li></ul></li><li><h5 id="XX-类型参数"><a href="#XX-类型参数" class="headerlink" title="XX  类型参数"></a>XX  类型参数</h5><ul><li><h2 id="在实际情况中-X-参数和-XX-参数并没有什么不同。X-参数的功能是十分稳定的。用一句话来说明-XX-参数的语法。所有的-XX-参数都以”-XX-”开始，但是随后的语法不同，取决于参数的类型："><a href="#在实际情况中-X-参数和-XX-参数并没有什么不同。X-参数的功能是十分稳定的。用一句话来说明-XX-参数的语法。所有的-XX-参数都以”-XX-”开始，但是随后的语法不同，取决于参数的类型：" class="headerlink" title="在实际情况中 X 参数和 XX 参数并没有什么不同。X 参数的功能是十分稳定的。用一句话来说明 XX 参数的语法。所有的 XX 参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型："></a>在实际情况中 X 参数和 XX 参数并没有什么不同。X 参数的功能是十分稳定的。用一句话来说明 XX 参数的语法。所有的 XX 参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型：</h2>  开启GC日志的参数: <code>-XX:+PrintGC(打印GC日志)</code><ul><li>最大永久代最大值： <code>-XX:MaxPermSize=2048m</code></li></ul></li></ul></li><li><p><strong>应用程序参数</strong></p><ul><li>这些参数是由特定的Java应用程序定义和使用的，它们不是由JVM直接解释的。应用程序参数用于传递给Java应用程序的命令行参数或配置参数，以影响应用程序的行为，如指定输入文件、设置日志级别等。</li></ul></li></ul><h4 id="1-4-常用的JVM参数"><a href="#1-4-常用的JVM参数" class="headerlink" title="1.4 常用的JVM参数"></a>1.4 常用的JVM参数</h4><h5 id="1-4-1-跟踪JAVA虚拟机的垃圾回收"><a href="#1-4-1-跟踪JAVA虚拟机的垃圾回收" class="headerlink" title="1.4.1 跟踪JAVA虚拟机的垃圾回收"></a>1.4.1 跟踪JAVA虚拟机的垃圾回收</h5><p>GC日志：jvm<code>垃圾回收</code>，记录jvm的<code>运行状态</code>，OOM<code>内存溢出</code>的报错信息等。</p><ul><li><code>%t</code> 将会被替代为时间字符串，格式为: <code>YYYY-MM-DD_HH-MM-SS</code></li></ul><p>开启GC日志:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/data0/logs/gc-%t.log"</span><br></pre></td></tr></table></figure><ol><li><h5 id="JVM新生代、永久代、老年代"><a href="#JVM新生代、永久代、老年代" class="headerlink" title="JVM新生代、永久代、老年代"></a>JVM新生代、永久代、老年代</h5></li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/202405102053029.webp" alt></p><p><strong><code>新生代</code>：Tomcat的新生代概念主要指的是JVM中用于存放新创建对象的内存区域</strong>。一般占据堆的<code>1/3</code>空间。可以通过参数<code>-XX:NewRatio</code>来调整。由于频繁创建对象，所以新生代会频繁触发进行垃圾回收。</p><p><strong><code>老年代</code></strong>：<strong>用于存放长时间存活的对象</strong>。</p><p><strong><code>永久代</code></strong>：指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。</p><p><strong>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</strong></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h5 id="1-4-2-配置JAVA虚拟机的堆空间"><a href="#1-4-2-配置JAVA虚拟机的堆空间" class="headerlink" title="1.4.2 配置JAVA虚拟机的堆空间"></a>1.4.2 配置JAVA虚拟机的堆空间</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms：指定Java虚拟机的初始堆大小。例如，-Xms512m表示初始堆大小为512MB。</span><br><span class="line">-Xmx：指定Java虚拟机的最大堆大小。例如，-Xmx1024m表示最大堆大小为1024MB。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这两个参数可以用来控制Java应用程序在运行时所能使用的堆空间大小。通常情况下，将这两个参数设置为相同的值，以避免堆空间大小的动态调整。增大堆空间可以提高应用程序的性能，减少垃圾回收的频率，但也会增加内存的消耗。`推荐设置为可用物理内存的一半`。</span></span><br><span class="line"></span><br><span class="line">例如，如果要将初始堆大小设置为512MB，最大堆大小设置为1024MB，可以使用以下命令：</span><br><span class="line">java -Xms512m -Xmx1024m -jar YourApp.jar</span><br></pre></td></tr></table></figure><h5 id="1-4-3-配置JAVA虚拟机的永久区-方法区"><a href="#1-4-3-配置JAVA虚拟机的永久区-方法区" class="headerlink" title="1.4.3 配置JAVA虚拟机的永久区(方法区)"></a>1.4.3 配置JAVA虚拟机的永久区(方法区)</h5><p><strong>JAVA虚拟机的永久区介绍</strong></p><p>在Java虚拟机中，<code>永久区</code>是一块用于存储类、方法、常量等元数据的内存区域。在早期的Java版本中，永久区主要用于存储这些元数据，例如类的字节码、静态变量、方法信息、常量池等。然而，随着Java技术的发展，永久代在Java 8及之后的版本中被元空间（Metaspace）所取代。</p><p>永久区的特点包括：</p><ol><li><p><strong>固定大小</strong>：永久区的大小在Java虚拟机启动时被固定下来，不能动态调整。在Java 8之前，可以通过设置 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 参数来调整永久代的大小。</p></li><li><p><strong>垃圾回收</strong>：尽管永久区的大小是固定的，但是永久区中的垃圾仍然会被回收。Java虚拟机会执行永久代的垃圾回收以释放不再使用的类和元数据。在Java 8之前，可以通过 <code>-XX:+CMSClassUnloadingEnabled</code> 参数开启永久代的垃圾回收。</p></li><li><p><strong>内存泄漏问题</strong>：永久区的内存泄漏是一个常见的问题。由于永久区的大小是<code>固定</code>的，如果应用程序不断加载新的类或者重新加载类，而没有对原来的类进行<code>垃圾回收</code>，就会导致永久区的内存使用量不断增加，最终导致内存溢出。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize     内存永久保留区域  ：<span class="comment">//所占用的内存是堆内存的一部分内存，不能超过堆内存</span></span><br><span class="line">-XX:MaxPermSize   内存最大永久保留区域</span><br><span class="line"></span><br><span class="line">JDK <span class="number">1.8</span>中 PermSize 和 MaxPermGen 已经无效。JDK <span class="number">1.8</span> 中已经不存在永久代的结论 而以 元空间 代替。</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1569157453195.png" alt="1569157453195"></p><h3 id="2、动、静态请求的区别-面试点"><a href="#2、动、静态请求的区别-面试点" class="headerlink" title="2、动、静态请求的区别(面试点)"></a><strong>2、动、静态请求的区别(<code>面试点</code>)</strong></h3><p>静态请求和动态请求是与网络服务中的<code>内容生成</code>和<code>提供相关</code>的两个重要概念。</p><ol><li><p><strong>静态请求</strong>：</p><ul><li>静态请求是指客户端（通常是Web浏览器）向服务器请求获取静态内容，如HTML文件、CSS样式表、JavaScript脚本、图像、视频和其他媒体文件等。这些内容在服务器上<code>预先存在</code>，不需要在请求时生成或处理。服务器在收到静态请求后，会直接将文件发送给客户端，不进行任何额外的<code>处理或计算</code>。因为静态内容在每次请求时都是<code>相同</code>的，所以静态请求的响应速度通常<code>较快</code>。</li></ul></li><li><p><strong>动态请求</strong>：</p><ul><li>动态请求是指客户端向服务器请求生成动态内容的过程。动态内容是根据用户请求时的<code>特定条件</code>、<code>参数</code>或者数据库中的<code>数据</code>等动态生成的。服务器收到动态请求后，会根据请求的内容、用户信息、数据库查询结果等动态生成需要返回给客户端的内容，然后将生成的内容发送给客户端。动态请求通常涉及服务器端的脚本语言（如PHP、Python、Node.js、Java等）来处理请求并生成响应。由于动态请求需要在服务器端进行处理和计算，响应时间通常<code>较长</code>。</li></ul></li></ol><p>总结：</p><ul><li>静态请求指的是获取预先存在并不需要额外处理的静态内容，响应速度较快。</li><li>动态请求指的是根据特定条件动态生成内容的请求，响应时间较长，需要服务器端进行处理和计算。</li></ul><h3 id="3、企业-Tomcat-运维"><a href="#3、企业-Tomcat-运维" class="headerlink" title="3、企业 Tomcat 运维"></a>3、企业 Tomcat 运维</h3><h4 id="3-1Tomcat-简介"><a href="#3-1Tomcat-简介" class="headerlink" title="3.1Tomcat 简介"></a><strong>3.1Tomcat 简介</strong></h4><p><strong>Tomcat</strong>官网： <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org</a></p><p>Tomcat是Apache软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。并且Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于<code>轻量级</code>应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。</p><p><strong>Tomcat：</strong>JAVA容器，WEB容器，WEB中间件</p><h4 id="3-2-Tomcat端口号说明"><a href="#3-2-Tomcat端口号说明" class="headerlink" title="3.2 Tomcat端口号说明"></a>3.2 Tomcat端口号说明</h4><ol><li><strong><code>HTTP端口（默认端口号为8080）</code></strong>：<ul><li>HTTP端口是用于处理HTTP请求的端口。当浏览器发送HTTP请求时，会使用这个端口与Tomcat服务器通信。</li><li>默认情况下，Tomcat监听8080端口，可以通过在<code>server.xml</code>配置文件中的<code>&lt;Connector&gt;</code>元素来修改。</li></ul></li><li><strong>HTTPS端口（默认端口号为8443）</strong>：<ul><li>HTTPS端口是用于处理HTTPS请求的端口。HTTPS是HTTP的安全版本，通过SSL/TLS加密传输数据。</li><li>默认情况下，Tomcat监听8443端口，可以通过在<code>server.xml</code>配置文件中的<code>&lt;Connector&gt;</code>元素来修改。</li></ul></li><li><strong><code>AJP端口（默认端口号为8009）</code></strong>：<ul><li>AJP（Apache JServ Protocol）端口是用于与Apache HTTP服务器之间进行通信的端口。通常用于将Tomcat与Apache Web服务器进行集成。</li><li>默认情况下，Tomcat监听8009端口，可以通过在<code>server.xml</code>配置文件中的<code>&lt;Connector&gt;</code>元素来修改。</li></ul></li><li><strong><code>Shutdown端口（默认端口号为8005）</code></strong>：<ul><li>Shutdown端口用于<code>接收关闭</code>Tomcat服务器的命令。当管理员想要停止Tomcat服务器时，可以通过连接到这个端口发送关闭命令。</li><li>默认情况下，Tomcat监听8005端口，可以通过在<code>server.xml</code>配置文件中的<code>&lt;Server&gt;</code>元素来修改。</li></ul></li></ol><p><strong>使用方案</strong>：</p><p>方案一：  Tomcat         //单独使用   —-基本不用<br>方案二：  Nginx+Tomcat       //反向代理和负载均衡<br>方案三：<br>                                  Nginx<br>                                      |<br>    +——————————————————–+<br>    |               |               |                       |<br>Tomcat1 Tomcat2 Tomcat3         nginx服务器  —-解析静态页面</p><p>建议使用Nginx和Tomcat配合，Nginx处理静态，Tomcat处理动态程序<br>方案三中后端Tomcat可以运行在单独的主机，也可以是同一台主机上的多实例</p><h4 id="3-3-Tomcat安装"><a href="#3-3-Tomcat安装" class="headerlink" title="3.3 Tomcat安装"></a>3.3 Tomcat安装</h4><h5 id="3-3-1-Tomcat基础环境JDK"><a href="#3-3-1-Tomcat基础环境JDK" class="headerlink" title="3.3.1 Tomcat基础环境JDK"></a>3.3.1 Tomcat基础环境JDK</h5><p>Java Development Kit（JDK）是Java开发工具包的缩写，是Java平台的核心组件之一，提供了用于开发、编译、调试和运行Java应用程序的各种工具和库。以下是JDK的主要组成部分和功能：</p><ol><li><strong>Java编译器（javac）</strong>：<ul><li>Java编译器将Java源代码编译成字节码，可由Java虚拟机（JVM）执行。</li></ul></li><li><strong>Java运行时环境（JRE）</strong>：<ul><li>JDK包含完整的Java运行时环境，包括Java虚拟机（JVM）和Java标准类库。</li></ul></li><li><strong>Java标准类库</strong>：<ul><li>JDK包含了大量的Java标准类库，提供了丰富的API，用于开发各种类型的应用程序，包括文件操作、网络通信、图形用户界面（GUI）、数据库访问等功能。</li></ul></li><li><strong>调试工具</strong>：<ul><li>JDK提供了一系列调试工具，如Java调试器（jdb）和Java虚拟机调试接口（JVMTI），用于调试Java应用程序和排查问题。</li></ul></li><li><strong>JavaDoc工具</strong>：<ul><li>JavaDoc工具用于从Java源代码生成API文档，帮助开发者编写和管理代码文档。</li></ul></li></ol><p><strong>JDK</strong>下载面页：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html&gt;" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html&gt;</a></p><h5 id="3-3-2-安装Tomcat-amp-JDK"><a href="#3-3-2-安装Tomcat-amp-JDK" class="headerlink" title="3.3.2 安装Tomcat &amp; JDK"></a>3.3.2 安装Tomcat &amp; JDK</h5><p>安装时候选择tomcat软件版本要与程序开发使用的版本一致。jdk版本要进行与tomcat保持一致。</p><p>系统环境说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat01 ~]# uname -a</span><br><span class="line">Linux tomcat01 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">[root@java-tomcat01 ~]# cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line"></span><br><span class="line">[root@java-tomcat01 ~]# setenforce 0</span><br><span class="line">[root@java-tomcat01 ~]# sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config</span><br><span class="line"></span><br><span class="line">[root@java-tomcat01 ~]# systemctl disable --now firewalld</span><br></pre></td></tr></table></figure><p>安装JDK</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上传jdk1.8到服务器。安装jdk</span><br><span class="line">[root@java-tomcat1 ~]# tar xzf jdk-8u191-linux-x64.tar.gz -C /usr/local/</span><br><span class="line">[root@java-tomcat1 ~]# cd /usr/local/</span><br><span class="line">[root@java-tomcat1 local]# ln -s jdk1.8.0_211  java  #或者改名都可以</span><br><span class="line">设置环境变量:</span><br><span class="line">[root@java-tomcat1 local]# vim /etc/profile.d/jdk.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/</span></span><br><span class="line">export JAVA_HOME=/usr/local/java   #指定java安装目录</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH    #用于指定java系统查找命令的路径</span><br><span class="line">检测JDK是否安装成功:</span><br><span class="line">[root@java-tomcat1 local]# source  /etc/profile.d/jdk.sh</span><br><span class="line">[root@java-tomcat1 local]# java -version</span><br><span class="line">java version "1.8.0_191"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br></pre></td></tr></table></figure><p>安装Tomcat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压Tomcat安装包到指定目录</span></span><br><span class="line">[root@java-tomcat01 ~]# tar xf apache-tomcat-8.5.45.tar.gz  -C /usr/local/ &amp;&amp;  cd /usr/local/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建软链接</span></span><br><span class="line">[root@java-tomcat01 local]# ln -s apache-tomcat-8.5.45/   tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量:</span></span><br><span class="line">[root@java-tomcat01 local]# vim /etc/profile.d/tomcat.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">export TOMCAT_HOME=/usr/local/tomcat</span><br><span class="line">export PATH=$PATH:$TOMCAT_HOME/bin:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载配置文件</span></span><br><span class="line">[root@java-tomcat1 application]# source  /etc/profile.d/tomcat.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tomcat是否安装成功</span></span><br><span class="line">[root@java-tomcat01 bin]# catalina.sh version</span><br><span class="line">命令会显</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Tomcat实例的基础目录，即配置文件、日志文件等所在的目录路径。</span></span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Tomcat的安装目录，即Tomcat的主要程序文件所在的目录路径。</span></span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Tomcat的临时目录，用于存放临时文件和数据，比如会话数据、上传文件等。</span></span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Java运行时环境（JRE）的安装目录，即Java解释器和标准类库所在的目录路径。</span></span><br><span class="line">Using JRE_HOME:        /usr/local/java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Java类路径（CLASSPATH），用于指定Java程序运行时要加载的类库和目录。在这里指定了两个JAR文件，分别是bootstrap.jar和tomcat-juli.jar，这些JAR文件包含了Tomcat启动和日志相关的类。</span></span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Tomcat服务器的版本信息，这里是Tomcat 8.5.45。</span></span><br><span class="line">Server version: Apache Tomcat/8.5.45</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Tomcat服务器的构建时间，即Tomcat程序文件的编译时间。</span></span><br><span class="line">Server built:   Aug 14 2019 22:21:25 UTC</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Tomcat服务器的具体版本号。</span></span><br><span class="line">Server number:  8.5.45.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示操作系统的名称，这里是Linux。</span></span><br><span class="line">OS Name:        Linux</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示操作系统的版本号。</span></span><br><span class="line">OS Version:     3.10.0-1160.el7.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示操作系统的体系结构，这里是64位的。</span></span><br><span class="line">Architecture:   amd64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Java虚拟机（JVM）的版本信息。</span></span><br><span class="line">JVM Version:    1.8.0_211-b12</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示Java虚拟机（JVM）的提供商，这里是Oracle Corporation。</span></span><br><span class="line">JVM Vendor:     Oracle Corporation</span><br></pre></td></tr></table></figure><h4 id="3-4-Tomcat目录介绍"><a href="#3-4-Tomcat目录介绍" class="headerlink" title="3.4 Tomcat目录介绍"></a>3.4 Tomcat目录介绍</h4><h5 id="3-4-1-tomcat主目录介绍"><a href="#3-4-1-tomcat主目录介绍" class="headerlink" title="3.4.1 tomcat主目录介绍"></a>3.4.1 tomcat主目录介绍</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 ~]# cd /usr/local/tomcat</span><br><span class="line">[root@java-tomcat1 tomcat]# yum install -y tree</span><br><span class="line">[root@java-tomcat1 tomcat]# tree -L 1</span><br><span class="line">.</span><br><span class="line">├── bin     # 包含了Tomcat服务器的可执行文件，如启动和关闭脚本、管理脚本等。</span><br><span class="line">├── BUILDING.txt# 包含了关于如何构建Tomcat服务器的说明文档。</span><br><span class="line">├── conf    # 包含了Tomcat服务器的配置文件，如服务器配置、日志配置、Web应用程序配置等。</span><br><span class="line">├── CONTRIBUTING.md# 包含了关于如何向Tomcat项目贡献代码的说明文档。</span><br><span class="line">├── lib      # 包含了Tomcat服务器运行所需的Java类库文件。</span><br><span class="line">├── LICENSE# 包含了Tomcat服务器的许可证文件。</span><br><span class="line">├── logs     # 包含了Tomcat服务器的日志文件，记录了服务器的运行状态和事件信息。</span><br><span class="line">├── NOTICE# 包含了关于Tomcat服务器的版权和许可信息的通知文件。</span><br><span class="line">├── README.md# 包含了Tomcat服务器的简要说明文档。</span><br><span class="line">├── RELEASE-NOTES# 包含了Tomcat服务器的发布说明文档，记录了每个版本的更新内容和改进。</span><br><span class="line">├── RUNNING.txt# 包含了关于如何运行Tomcat服务器的说明文档。</span><br><span class="line">├── temp     # 用于存放Tomcat服务器的临时文件，如会话数据、上传文件等。</span><br><span class="line">├── webapps  # 用于存放Web应用程序的目录，每个子目录代表一个独立的Web应用程序</span><br><span class="line">└── work     # 用于存放Tomcat服务器的工作目录，如编译的JSP文件、临时缓存等。</span><br><span class="line"></span><br><span class="line">7 directories, 7 files</span><br></pre></td></tr></table></figure><p><strong>2、webapps目录介绍</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 tomcat]# cd webapps/</span><br><span class="line">[root@java-tomcat1 webapps]# tree -L 1</span><br><span class="line">.</span><br><span class="line">├── docs  # 包含了Tomcat服务器的文档和示例文件，如用户手册、API文档等。</span><br><span class="line">├── examples  # 包含了Tomcat服务器的示例应用程序，提供了一些简单的示例代码和演示。</span><br><span class="line">├── host-manager  # 包含了Tomcat的主机管理应用程序，允许管理员通过Web界面管理虚拟主机。</span><br><span class="line">├── manager    # 包含了Tomcat的应用程序管理应用程序，允许管理员通过Web界面管理部署在Tomcat上的Web应用程序</span><br><span class="line">└── `ROOT`    # 是Tomcat服务器的默认根应用程序（也称为ROOT应用程序），即当用户访问Tomcat服务器时默认会加载的应用程序。通常用于展示Tomcat服务器的欢迎页面或其他默认内容。</span><br><span class="line"></span><br><span class="line">5 directories, 0 files</span><br></pre></td></tr></table></figure><p><strong>3、Tomcat配置文件目录介绍（conf）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 webapps]# cd ../conf/</span><br><span class="line">[root@java-tomcat1 conf]# tree -L 1</span><br><span class="line">.</span><br><span class="line">├── catalina.policy# Tomcat服务器的安全策略文件，用于定义安全策略和权限控制。</span><br><span class="line">├── catalina.properties# Tomcat服务器的全局配置文件，包含了一些Tomcat服务器的运行参数和属性设置。</span><br><span class="line">├── context.xml# Tomcat服务器的上下文配置文件，用于配置特定Web应用程序的上下文参数和资源定义。</span><br><span class="line">├── jaspic-providers.xml</span><br><span class="line">├── jaspic-providers.xsd </span><br><span class="line">├── logging.properties# Tomcat服务器的日志配置文件，用于配置日志记录器、日志格式和输出目的地等。</span><br><span class="line">├── `server.xml# Tomcat服务器的主配置文件，包含了服务器的核心配置，如端口设置、连接器配置、虚拟主机设置等。`</span><br><span class="line">├── tomcat-users.xml# Tomcat服务器的用户认证配置文件，用于定义Tomcat服务器的用户、角色和访问权限。</span><br><span class="line">├── tomcat-users.xsd# Tomcat用户认证配置文件的XML模式定义（XSD）文件，用于验证Tomcat用户认证配置文件的结构和语法。</span><br><span class="line">└── web.xml# 定义的Web应用程序配置文件，包含了Web应用程序的部署描述符，用于配置Servlet、过滤器、监听器等组件。</span><br><span class="line"></span><br><span class="line">0 directories, 10 files</span><br></pre></td></tr></table></figure><p><strong>4、Tomcat的管理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动程序 </span></span><br><span class="line">[root@java-tomcat01 conf]# catalina.sh  start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭程序 </span></span><br><span class="line">[root@java-tomcat01 conf]# catalina.sh stop</span><br></pre></td></tr></table></figure><p> <code>注意</code>：<strong>tomcat未启动的情况下使用shutdown脚本，会有大量的输出信息。</strong></p><p>检查tomcat是否启动正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 bin]# netstat -lntp  |grep java</span><br><span class="line">tcp6       0      0 :::8080         :::*                   LISTEN      30560/java</span><br><span class="line">tcp6       0      0 127.0.0.1:8005          :::*          LISTEN      30560/java</span><br><span class="line">tcp6       0      0 :::8009                 :::*           LISTEN      30560/java</span><br></pre></td></tr></table></figure><p><code>说明：</code><strong>所有与java相关的，服务启动都是java命名的进程</strong></p><p>启动完成浏览器进行访问<a href="http://IP:8080" target="_blank" rel="noopener">http://IP:8080</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240406210329630.png" alt="image-20240406210329630"></p><p>查看Tomcat日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat01 conf]# tail -f /usr/local/tomcat/logs/catalina.out </span><br><span class="line">06-Apr-2024 21:02:19.361 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]</span><br><span class="line">06-Apr-2024 21:02:19.373 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["ajp-nio-8009"]</span><br><span class="line">06-Apr-2024 21:02:19.375 信息 [main] org.apache.catalina.startup.Catalina.start Server startup in 443 ms</span><br></pre></td></tr></table></figure><h4 id="3-5-Tomcat主配置文件详解"><a href="#3-5-Tomcat主配置文件详解" class="headerlink" title="3.5 Tomcat主配置文件详解"></a>3.5 Tomcat主配置文件详解</h4><h5 id="3-5-1-server-xml组件类别"><a href="#3-5-1-server-xml组件类别" class="headerlink" title="3.5.1 server.xml组件类别"></a>3.5.1 server.xml组件类别</h5><p>顶级组件：位于整个配置的顶层，如server。</p><p>容器类组件：可以包含其它组件的组件，如service、engine、host、context。</p><p>连接器组件：连接用户请求至tomcat，如connector(引擎)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;  #表示一个运行于JVM中的tomcat实例。</span><br><span class="line">     &lt;service&gt; #服务。将connector关联至engine，因此一个service内部可以有多个connector，但只能有一个引擎engine。</span><br><span class="line">     &lt;connector /&gt; #接收用户请求，类似于httpd的listen配置监听端口的</span><br><span class="line">     &lt;engine&gt;  #核心容器组件，catalina引擎，负责通过connector接收用户请求，并处理请求，将请求转至对应的虚拟主机host。</span><br><span class="line">     &lt;host&gt;   #类似于httpd中的虚拟主机，</span><br><span class="line">     &lt;context&gt;&lt;/context&gt;  #配置context的主要目的指定对应对的webapp的根目录。其还能为webapp指定额外的属性，如部署方式等。</span><br><span class="line">     &lt;/host&gt;</span><br><span class="line">     &lt;host&gt;</span><br><span class="line">     &lt;context&gt;&lt;/context&gt;</span><br><span class="line">     &lt;/host&gt;</span><br><span class="line">     &lt;/engine&gt;</span><br><span class="line">     &lt;/service&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-server-xml配置文件注释"><a href="#3-5-2-server-xml配置文件注释" class="headerlink" title="3.5.2 server.xml配置文件注释"></a>3.5.2 server.xml配置文件注释</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;Server&gt;元素代表整个容器,是Tomcat实例的顶层元素.它包含一个&lt;Service&gt;元素.并且它不能做为任何元素的子元素.</span><br><span class="line">    port指定Tomcat监听shutdown命令端口</span><br><span class="line">    shutdown指定终止Tomcat服务器运行时,发给Tomcat服务器的shutdown监听端口的字符串.该属性必须设置</span><br><span class="line"><span class="meta">--&gt;</span></span><br><span class="line">&lt;Server port="8005" shutdown="SHUTDOWN"&gt;</span><br><span class="line">  &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt;</span><br><span class="line">  &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt;</span><br><span class="line">  &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt;</span><br><span class="line">  &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt;</span><br><span class="line">  &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt;</span><br><span class="line">  &lt;GlobalNamingResources&gt;</span><br><span class="line">    &lt;Resource name="UserDatabase" auth="Container"</span><br><span class="line">              type="org.apache.catalina.UserDatabase"</span><br><span class="line">              description="User database that can be updated and saved"</span><br><span class="line">              factory="org.apache.catalina.users.MemoryUserDatabaseFactory"</span><br><span class="line">              pathname="conf/tomcat-users.xml" /&gt;</span><br><span class="line">  &lt;/GlobalNamingResources&gt;</span><br><span class="line">  &lt;!--service服务组件--&gt;</span><br><span class="line">  &lt;Service name="Catalina"&gt;</span><br><span class="line">    &lt;!-- Connector主要参数说明（见下面） --&gt;</span><br><span class="line">    &lt;Connector port="8080" protocol="HTTP/1.1"</span><br><span class="line">               connectionTimeout="20000"</span><br><span class="line">               redirectPort="8443" /&gt;</span><br><span class="line">    &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;</span><br><span class="line">    &lt;Engine name="Catalina" defaultHost="localhost"&gt;</span><br><span class="line">      &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;</span><br><span class="line">        &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"</span><br><span class="line">               resourceName="UserDatabase"/&gt;</span><br><span class="line">      &lt;/Realm&gt;</span><br><span class="line">      &lt;!-- 详情常见（host参数详解）--&gt;</span><br><span class="line">      &lt;Host name="localhost"  appBase="webapps"</span><br><span class="line">            unpackWARs="true" autoDeploy="true"&gt;</span><br><span class="line">        &lt;!-- 详情见扩展（Context参数说明 ）--&gt;</span><br><span class="line">        &lt;Context path="" docBase="" debug=""/&gt;</span><br><span class="line">        &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"</span><br><span class="line">               prefix="localhost_access_log" suffix=".txt"</span><br><span class="line">               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure><h5 id="3-5-3-Connector主要参数说明"><a href="#3-5-3-Connector主要参数说明" class="headerlink" title="3.5.3 Connector主要参数说明"></a>3.5.3 Connector主要参数说明</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port:指定服务器端要创建的端口号，并在这个端口监听来自客户端的请求。</span><br><span class="line">protocol：连接器使用的协议，支持HTTP和AJP。AJP（Apache Jserv Protocol）专用于tomcat与apache建立通信的， 在httpd反向代理用户请求至tomcat时使用（可见Nginx反向代理时不可用AJP协议）。</span><br><span class="line">redirectPort：指定服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号</span><br><span class="line">maxThreads：接收最大请求的并发数</span><br><span class="line">connectionTimeout  指定超时的时间数(以毫秒为单位)</span><br></pre></td></tr></table></figure><p>&lt;Connector port=”8080” protocol=”HTTP/1.1” </p><p>​               maxThreads=”500”    —-默认是200<br>​               connectionTimeout=”20000”       ———连接超时时间。单位毫秒<br>​               redirectPort=”8443” /&gt;</p><h5 id="3-5-5-host参数详解"><a href="#3-5-5-host参数详解" class="headerlink" title="3.5.5 host参数详解"></a>3.5.5 host参数详解</h5><p>​            &lt;Host name=”localhost”  appBase=”webapps”<br>​            unpackWARs=”true” autoDeploy=”true”&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">host# 表示一个虚拟主机。</span><br><span class="line">name# 指定主机名。</span><br><span class="line">appBase# 应用程序基本目录，即存放应用程序的目录.一般为appBase="webapps"，相对于CATALINA_HOME而言的，也可以写绝对路径。</span><br><span class="line">unpackWARs# 如果为true，则tomcat会自动将WAR文件解压，否则不解压，直接从WAR文件中运行应用程序。</span><br><span class="line">autoDeploy# 在tomcat启动时，是否自动部署。</span><br></pre></td></tr></table></figure><h4 id="3-6-WEB站点部署"><a href="#3-6-WEB站点部署" class="headerlink" title="3.6  WEB站点部署"></a>3.6  WEB站点部署</h4><p>上线的代码有两种方式：</p><ul><li>直接将程序目录放在webapps目录下面。</li><li>使用开发工具将程序打包成war包，然后上传到webapps目录下面。</li></ul><h5 id="3-6-1-使用war包部署web站点"><a href="#3-6-1-使用war包部署web站点" class="headerlink" title="3.6.1 使用war包部署web站点"></a><strong>3.6.1 使用war包部署web站点</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式一：自动解压</span></span><br><span class="line">[root@java-tomcat1 ~]# wget http://updates.jenkins-ci.org/download/war/2.129/jenkins.war</span><br><span class="line">[root@java-tomcat1 ~]# ls</span><br><span class="line">jenkins.war</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入tomcat目录</span></span><br><span class="line">[root@java-tomcat1 ~]# cd /usr/local/tomcat/ </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将原来的发布网站目录备份</span></span><br><span class="line">[root@java-tomcat1 tomcat]# cp -r webapps/ /opt/    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空发布网站里面的内容</span></span><br><span class="line">[root@java-tomcat1 tomcat]# cd webapps/</span><br><span class="line">[root@java-tomcat1 webapps]# rm -rf *   </span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 将war包拷贝到当前目录</span></span><br><span class="line">[root@java-tomcat1 webapps]# cp ~/jenkins.war . </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动Tomcat实例</span></span><br><span class="line">[root@java-tomcat1 webapps]# catalina.sh start   </span><br><span class="line">Using CATALINA_BASE:   /data/application/tomcat</span><br><span class="line">Using CATALINA_HOME:   /data/application/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /data/application/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /usr/local/java</span><br><span class="line">Using CLASSPATH:       /data/application/tomcat/bin/bootstrap.jar:/data/application/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br><span class="line">[root@java-tomcat1 webapps]# ls</span><br><span class="line">jenkins  jenkins.war</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二：手动解压</span></span><br><span class="line">[root@java-tomcat1 webapps]# catalina.sh stop   #关闭tomcat</span><br><span class="line">[root@java-tomcat1 ~]# cd /usr/local/tomcat/webapps/</span><br><span class="line">[root@java-tomcat1 webapps]# rm -rf *    </span><br><span class="line">[root@java-tomcat1 webapps]# mkdir ROOT      #创建一个ROOT目录存放war包</span><br><span class="line">[root@java-tomcat1 webapps]# cd ROOT/</span><br><span class="line">[root@java-tomcat1 ROOT]# cp /root/jenkins.war .</span><br><span class="line">[root@java-tomcat1 ROOT]# unzip jenkins.war</span><br><span class="line">[root@java-tomcat01 ROOT]# catalina.sh start</span><br></pre></td></tr></table></figure><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562256628954.png" alt="1562256628954"></p><p>浏览器访问：<a href="http://IP:8080/jenkins" target="_blank" rel="noopener">http://IP:8080/jenkins</a> </p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562255930078.png" alt="1562255930078"></p><h5 id="3-6-2-自定义默认网站目录"><a href="#3-6-2-自定义默认网站目录" class="headerlink" title="3.6.2 自定义默认网站目录"></a>3.6.2 自定义默认网站目录</h5><p>1、修改默认发布目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 ~]# catalina.sh stop</span><br><span class="line">[root@java-tomcat1 ~]# mkdir -p /data/application/webapp  #创建发布目录</span><br><span class="line">[root@java-tomcat1 ~]# vim /usr/local/tomcat/conf/server.xml</span><br></pre></td></tr></table></figure><p>将原来的</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562335606126.png" alt="1562335606126"></p><p>修改为</p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562335650998.png" alt="1562335650998"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 ~]# cp /root/jenkins.war /data/application/webapp/</span><br><span class="line">[root@java-tomcat1 ~]# catalina.sh start ; tail -f /usr/local/tomcat/logs/catalina.out</span><br></pre></td></tr></table></figure><p>浏览器访问：<a href="http://IP:8080/jenkins" target="_blank" rel="noopener">http://IP:8080/jenkins</a></p><h5 id="3-6-3-部署开源站点（jspgou商城）"><a href="#3-6-3-部署开源站点（jspgou商城）" class="headerlink" title="3.6.3 部署开源站点（jspgou商城）"></a><strong>3.6.3 部署开源站点（jspgou商城）</strong></h5><p>第一：安装配置数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.使用mariadb</span><br><span class="line">[root@youngfit ~]# yum -y install mariadb mariadb-server</span><br><span class="line">[root@youngfit ~]# systemctl enable --now mariadb</span><br><span class="line">[root@youngfit ~]# mysql</span><br><span class="line">MariaDB [(none)]&gt; create database jspgou default charset=utf8;//在数据库中操作，创建数据库并指定字符集</span><br><span class="line">MariaDB [(none)]&gt; flush privileges;//(可选操作)</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>第二：jspgou商城上线</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上传jspgou商城的代码</span><br><span class="line">[root@java-tomcat1 ~]# unzip jspgouV6.1-ROOT.zip</span><br><span class="line">[root@java-tomcat01~]# cd /usr/local/tomcat/webapps/</span><br><span class="line">[root@java-tomcat01 webapps]# rm -rf *</span><br><span class="line">[root@java-tomcat01 webapps]# cp -r ROOT/ .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看JDBC连接数据库配置文件信息</span></span><br><span class="line">[root@java-tomcat01 webapps]# vim ROOT/WEB-INF/config/jdbc.properties</span><br><span class="line">jdbc.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/jspgou?characterEncoding=UTF-8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=</span><br><span class="line"></span><br><span class="line">hibernate.db=mysql</span><br><span class="line">hibernate.dialect=org.hibernate.dialect.MySQLInnoDBDialect</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将数据导入数据库:</span><br><span class="line">[root@java-tomcat1 ~]# cd DB/</span><br><span class="line">[root@java-tomcat1 DB]# ls</span><br><span class="line">jspgou.sql</span><br><span class="line">[root@java-tomcat1 DB]# mysql -uroot -p  jspgou &lt; jspgou.sql</span><br><span class="line"></span><br><span class="line">启动tomcat访问:</span><br><span class="line">[root@java-tomcat1 ~]# catalina.sh start ; tail -f /usr/local/tomcat/logs/catalina.out</span><br><span class="line">[root@java-tomcat1 ~]# netstat -lntp | grep java</span><br></pre></td></tr></table></figure><p>访问:<a href="http://IP:8080/" target="_blank" rel="noopener">http://IP:8080/</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562343793980.png" alt="1562343793980"></p><p>做一遍：要求用mysql5.7（会遇到问题，百度解决），贴近企业环境</p><h5 id="3-6-4-Tomcat多实例配置"><a href="#3-6-4-Tomcat多实例配置" class="headerlink" title="3.6.4 Tomcat多实例配置"></a>3.6.4 Tomcat多实例配置</h5><p><strong>多实例（多进程）</strong>：同一个程序启动多次，分为两种情况:</p><p>第一种：一台机器跑多个站点； </p><p>第二种：多个机器跑一个站点多个实例，配合负载均衡;</p><p>1、复制程序文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat01 ~]# cd /usr/local/</span><br><span class="line">[root@java-tomcat01 local]# cp -r tomcat/ tomcat_2</span><br><span class="line">[root@java-tomcat01 local]# rm -rf /usr/local/tomcat/webapps/*</span><br><span class="line">[root@java-tomcat01 local]# rm -rf /usr/local/tomcat_2/webapps/*</span><br><span class="line">[root@java-tomcat01 local]# cp -r /opt/webapps/* /usr/local/tomcat/webapps/</span><br><span class="line">[root@java-tomcat01 local]# cp -r /opt/webapps/* /usr/local/tomcat_2/webapps/</span><br><span class="line"></span><br><span class="line">[root@java-tomcat01 local]# vim tomcat_2/conf/server.xml</span><br><span class="line">&lt;Server port="8006" shutdown="SHUTDOWN"&gt;</span><br><span class="line">    &lt;Connector port="8082" protocol="HTTP/1.1"</span><br><span class="line">    &lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8443" /&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改端口，以启动多实例。多实例之间端口不能一致</span></span><br><span class="line">[root@java-tomcat1 local]# diff tomcat/conf/server.xml tomcat_2/conf/server.xml  #对比文件不同之处</span><br><span class="line">3c3</span><br><span class="line">&lt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt;</span><br><span class="line">---</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;Server port=<span class="string">"8006"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">19c19</span><br><span class="line">&lt;     &lt;Connector port="8080" protocol="HTTP/1.1"</span><br><span class="line">---</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;Connector port=<span class="string">"8082"</span> protocol=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line">23c23</span><br><span class="line">&lt;     &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;</span><br><span class="line">---</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;Connector port=<span class="string">"8010"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>启动tomcat多实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 local]# echo 8080 &gt;&gt; tomcat/webapps/ROOT/index.jsp </span><br><span class="line">[root@java-tomcat1 local]# echo 8082 &gt;&gt; tomcat_2/webapps/ROOT/index.jsp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动：</span></span><br><span class="line">[root@java-tomcat01 local]# /usr/local/tomcat/bin/startup.sh </span><br><span class="line">[root@java-tomcat01 local]# /usr/local/tomcat_2/bin/startup.sh</span><br></pre></td></tr></table></figure><p>检查端口查看是否启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat01 local]# ss -tunlp | grep java</span><br><span class="line">tcp    LISTEN     0      100    [::]:8080               [::]:*                   users:(("java",pid=2814,fd=49))</span><br><span class="line">tcp    LISTEN     0      100    [::]:8082               [::]:*                   users:(("java",pid=2869,fd=49))</span><br><span class="line">tcp    LISTEN     0      1        [::ffff:127.0.0.1]:8005               [::]:*                   users:(("java",pid=2814,fd=75))</span><br><span class="line">tcp    LISTEN     0      1        [::ffff:127.0.0.1]:8006               [::]:*                   users:(("java",pid=2869,fd=75))</span><br><span class="line">tcp    LISTEN     0      100    [::]:8009               [::]:*                   users:(("java",pid=2814,fd=54))</span><br><span class="line">tcp    LISTEN     0      100    [::]:8010               [::]:*                   users:(("java",pid=2869,fd=54))</span><br></pre></td></tr></table></figure><p>2、在浏览器访问，进行测试</p><p>检查多实例的启动</p><p><a href="http://IP:8080/" target="_blank" rel="noopener">http://IP:8080/</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/image-20240407154854291.png" alt="image-20240407154854291"></p><p><a href="http://IP:8082/" target="_blank" rel="noopener">http://IP:8082/</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562592140511.png" alt="1562592140511"></p><h4 id="3-7-tomcat反向代理集群"><a href="#3-7-tomcat反向代理集群" class="headerlink" title="3.7 tomcat反向代理集群"></a>3.7 tomcat反向代理集群</h4><p><strong>1、负载均衡器说明</strong></p><p>关闭防火墙和selinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum安装nginx</span></span><br><span class="line">[root@nginx-proxy ~]# cd /etc/yum.repos.d/</span><br><span class="line">[root@nginx-proxy yum.repos.d]# vim nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">[root@nginx-proxy yum.repos.d]# yum install yum-utils -y</span><br><span class="line">[root@nginx-proxy yum.repos.d]# yum install nginx -y</span><br></pre></td></tr></table></figure><p><strong>2、配置负载均衡器</strong></p><p>备份原配置文件并修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-proxy ~]# cd /etc/nginx/conf.d/</span><br><span class="line">[root@nginx-proxy conf.d]# cp default.conf default.conf.bak</span><br><span class="line">[root@nginx-proxy conf.d]# mv default.conf tomcat.conf</span><br><span class="line">[root@nginx-proxy conf.d]# vim tomcat.conf</span><br><span class="line">upstream testweb &#123;</span><br><span class="line">server 192.168.50.114:8081 weight=1 max_fails=1 fail_timeout=2s;</span><br><span class="line">server 192.168.50.114:8082 weight=1 max_fails=1 fail_timeout=2s;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    access_log  /var/log/nginx/proxy.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">       proxy_pass http://testweb;</span><br><span class="line">       proxy_set_header Host $host:$server_port;</span><br><span class="line">       proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;       </span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx-proxy ~]# systemctl start nginx</span><br></pre></td></tr></table></figure><p><strong>3、在浏览器上进行访问测试</strong></p><p><a href="http://192.168.174.20/" target="_blank" rel="noopener">http://192.168.174.20/</a></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562598544268.png" alt="1562598544268"></p><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562598580435.png" alt="1562598580435"></p><h3 id="4、Tomcat相关调优"><a href="#4、Tomcat相关调优" class="headerlink" title="4、Tomcat相关调优"></a>4、Tomcat相关调优</h3><h4 id="4-1-日志格式配置"><a href="#4-1-日志格式配置" class="headerlink" title="4.1 日志格式配置"></a>4.1 日志格式配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 ~]# cd /data/application/tomcat/conf/</span><br><span class="line">[root@java-tomcat1 conf]# vim server.xml</span><br><span class="line">&lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="/data/www/logs"</span><br><span class="line">               prefix="jenkins-" suffix="-access_log"</span><br><span class="line">               pattern="%&#123;X-Real-IP&#125;i - %v %t &amp;quot;%r&amp;quot; - %s %b %T &amp;quot;%&#123;Referer&#125;i&amp;quot; &amp;quot;%&#123;User-Agent&#125;i&amp;quot; %a &amp;quot;-&amp;quot; &amp;quot;-&amp;quot;" /&gt;</span><br><span class="line">[root@java-tomcat1 conf]# mkdir -p /data/www</span><br><span class="line"></span><br><span class="line">日志参数解释：</span><br><span class="line">    ％a - 远程IP地址</span><br><span class="line">    ％A - 本地IP地址</span><br><span class="line">    ％b - 发送的字节数，不包括HTTP头，或“ - ”如果没有发送字节</span><br><span class="line">    ％B - 发送的字节数，不包括HTTP头</span><br><span class="line">    ％h - 远程主机名</span><br><span class="line">    ％H - 请求协议</span><br><span class="line">    ％l (小写的L)- 远程逻辑从identd的用户名（总是返回' - '）</span><br><span class="line">    ％m - 请求方法</span><br><span class="line">    ％p - 本地端口</span><br><span class="line">    ％q - 查询字符串（在前面加上一个“？”如果它存在，否则是一个空字符串</span><br><span class="line">    ％r - 第一行的要求，客户端请求的第一行，包括HTTP方法、请求URL和协议版本。例如："GET /example.html HTTP/1.1"。</span><br><span class="line">    ％s - 响应的HTTP状态代码</span><br><span class="line">    ％S - 用户会话ID</span><br><span class="line">    ％t - 日期和时间，在通用日志格式，使用指定格式（例如 %t&#123;dd/MMM/yyyy:HH:mm:ss Z&#125;）</span><br><span class="line">    ％u - 远程用户身份验证</span><br><span class="line">    ％U - 请求的URL路径</span><br><span class="line">    ％v - 本地服务器名</span><br><span class="line">    ％D - 处理请求的时间（以毫秒为单位）</span><br><span class="line">    ％T - 处理请求的时间（以秒为单位）</span><br><span class="line">    ％I （大写的i） - 当前请求的线程名称</span><br></pre></td></tr></table></figure><h4 id="4-2-JVM-参数优化"><a href="#4-2-JVM-参数优化" class="headerlink" title="4.2 JVM 参数优化"></a>4.2 JVM 参数优化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 conf]# cd ../bin/</span><br><span class="line">[root@java-tomcat1 bin]# cp catalina.sh catalina.sh.bak</span><br><span class="line">[root@java-tomcat1 bin]# vim catalina.sh</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Xms1024m -Xmx1024m -XX:PermSize=512m -XX:MaxPermSize=512m"  #jdk1.7</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Xms1024m -Xmx1024m -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m"   #jdk1.8</span><br></pre></td></tr></table></figure><p>这条代码是用于设置Java虚拟机（JVM）的启动参数。让我们逐步解释：</p><ol><li><p><code>JAVA_OPTS=&quot;$JAVA_OPTS -Xms1024m -Xmx1024m -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m&quot;</code></p><p>这一行代码首先将 <code>JAVA_OPTS</code> 环境变量的值设置为其当前值（如果有的话），然后添加了一系列JVM启动参数：</p><ul><li><code>-Xms1024m</code>: 指定JVM的初始堆内存大小为1024 MB。</li><li><code>-Xmx1024m</code>: 指定JVM的最大堆内存大小为1024 MB。</li><li><code>-XX:MetaspaceSize=512m</code>: 指定元数据空间（Metaspace）的初始大小为512 MB。元数据空间用于存储类的元数据信息。</li><li><code>-XX:MaxMetaspaceSize=512m</code>: 指定元数据空间的最大大小为512 MB。</li></ul></li></ol><h4 id="4-3-开启GC日志"><a href="#4-3-开启GC日志" class="headerlink" title="4.3 开启GC日志"></a>4.3 开启GC日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 bin]# vim catalina.sh</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/data/logs/gc-%t.log"</span><br><span class="line"></span><br><span class="line">可选参数:</span><br><span class="line">-XX:+AggressiveOpts，加快编译。会增加编译时间和内存消耗</span><br><span class="line">-XX:+UseParallelGC，优化垃圾回收,通过多线程并行处理垃圾收集任务来减少停顿时间，从而提高应用程序的吞吐量。会导致一些额外的系统开销。</span><br><span class="line">[root@java-tomcat1 bin]# mkdir /data/logs</span><br></pre></td></tr></table></figure><p>这条代码是用于设置Java虚拟机（JVM）的启动参数，主要是用于配置垃圾回收（GC）日志输出。让我们逐步解释：</p><p>这一行代码首先将 <code>JAVA_OPTS</code> 环境变量的值设置为其当前值（如果有的话），然后添加了一系列JVM启动参数：</p><ul><li><code>-XX:+PrintGCDetails</code>: 启用GC日志详细输出，包括每次GC事件的详细信息，如GC类型、GC前后堆内存情况等。</li><li><code>-XX:+PrintGCDateStamps</code>: 启用GC日志输出时间戳，每条GC日志输出的前缀将包含日期和时间信息。</li><li><code>-Xloggc:/data/logs/gc-%t.log</code>: 指定GC日志文件的输出路径和文件名格式。<code>/data/logs/gc-%t.log</code> 中的 <code>%t</code> 将会被替换为当前日期时间的时间戳。</li></ul><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562242242126.png" alt="1562242242126"></p><h4 id="4-4-开启JMX端口便于监控"><a href="#4-4-开启JMX端口便于监控" class="headerlink" title="4.4 开启JMX端口便于监控"></a>4.4 开启JMX端口便于监控</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim catalina.sh</span></span><br><span class="line">CATALINA_OPTS="$CATALINA_OPTS -Dcom.sun.management.jmxremote </span><br><span class="line">-Dcom.sun.management.jmxremote.port=10028 </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false </span><br><span class="line">-Djava.rmi.server.hostname=java69-matrix.zeus.lianjia.com"</span><br></pre></td></tr></table></figure><p>这条代码是用于配置 Tomcat 服务器的启动参数，具体解释如下：</p><ol><li><p><code>-Dcom.sun.management.jmxremote</code>：启用 JMX（Java Management Extensions）远程管理功能。这允许外部监控程序（如JConsole或VisualVM）连接到Tomcat服务器并监视其状态和性能。</p></li><li><p><code>-Dcom.sun.management.jmxremote.port=10028</code>：指定 JMX 远程管理的端口号为 10028。监控程序将使用该端口连接到Tomcat服务器。</p></li><li><p><code>-Dcom.sun.management.jmxremote.authenticate=false</code>：禁用JMX远程管理的认证功能，允许任何可以连接到服务器的客户端都可以进行JMX操作。</p></li><li><p><code>-Dcom.sun.management.jmxremote.ssl=false</code>：禁用JMX远程管理的SSL安全传输，以简化连接配置。在此配置下，连接不会通过SSL进行加密。</p></li><li><p><code>-Djava.rmi.server.hostname=java69-matrix.zeus.lianjia.com</code>：指定 RMI（Remote Method Invocation）服务器的主机名或IP地址。在JMX远程管理中，这将用于通知监控程序Tomcat服务器的位置。</p></li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562242650648.png" alt="1562242650648"></p><h4 id="4-5-取消JVM-的默认DNS缓存时间"><a href="#4-5-取消JVM-的默认DNS缓存时间" class="headerlink" title="4.5 取消JVM 的默认DNS缓存时间"></a>4.5 取消JVM 的默认DNS缓存时间</h4><p>不缓存DNS记录，避免DNS解析更改后要重启JVM虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> catalina.sh  ---添加如下内容</span></span><br><span class="line">CATALINA_OPTS="$CATALINA_OPTS -Dsun.net.inetaddr.ttl=0 -Dsun.net.inetaddr.negative.ttl=0</span><br></pre></td></tr></table></figure><ol><li><code>-Dsun.net.inetaddr.ttl=0</code>：这个系统属性设置了网络地址（InetAddress）的生存时间（TTL，Time-To-Live）为0。TTL用于指定网络数据包在网络中允许存在的时间。将TTL设置为0意味着数据包一旦到达目的地，即被丢弃，不会被路由到其他节点。在这个设置下，网络地址的生存时间被设置为尽可能短，可以避免一些不必要的网络传输。</li><li><code>-Dsun.net.inetaddr.negative.ttl=0</code>：这个系统属性设置了负缓存的生存时间为0。负缓存用于缓存DNS查询的失败结果，以避免频繁地重新查询。将负缓存的生存时间设置为0意味着失败的DNS查询结果不会被缓存，每次查询都会重新进行。这可以确保Tomcat服务器及时获取到最新的DNS解析结果，而不会受到旧缓存的影响。</li></ol><p><img src="https://hjmimage.oss-cn-zhangjiakou.aliyuncs.com/1562243085427.png" alt="1562243085427"></p><h3 id="5、JVM-运维实用排障工具"><a href="#5、JVM-运维实用排障工具" class="headerlink" title="5、JVM 运维实用排障工具"></a>5、JVM 运维实用排障工具</h3><h4 id="5-1-jps"><a href="#5-1-jps" class="headerlink" title="5.1 jps"></a><strong>5.1 jps</strong></h4><p>​    <code>jps</code> 是 Java Virtual Machine Process Status Tool 的缩写，用于列出当前系统中正在运行的 Java 进程（Java虚拟机实例）。<code>jps</code> 工具在 JDK 的 <code>bin</code> 目录下，可以通过命令行运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">用来查看Java进程的具体状态, 包括进程ID，进程启动的路径及启动参数等等，与unix上的ps类似，只不过jps是用来显示java进程，可以把jps理解为ps的一个子集。</span><br><span class="line">常用参数如下:</span><br><span class="line"><span class="meta">#</span><span class="bash"> -q：只输出java进程pid</span></span><br><span class="line">[root@java-tomcat01 ~]# jps -q</span><br><span class="line">3267</span><br><span class="line">3386</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m：输出传递给main方法的参数，如果是内嵌的JVM则输出为null</span></span><br><span class="line">[root@java-tomcat01 ~]# jps -m</span><br><span class="line">3267 Bootstrap start</span><br><span class="line">3398 Jps -m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：输出完全的包名，应用主类名，jar的完全路径名</span></span><br><span class="line">[root@java-tomcat01 ~]# jps -l</span><br><span class="line">3410 sun.tools.jps.Jps</span><br><span class="line">3267 org.apache.catalina.startup.Bootstrap</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：显示java服务启动时的相关参数和启动命令或脚本</span></span><br><span class="line">[root@java-tomcat01 ~]# jps -v</span><br><span class="line">3267 Bootstrap -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp</span><br><span class="line">3422 Jps -Dapplication.home=/usr/local/jdk1.8.0_211 -Xms8m</span><br><span class="line"></span><br><span class="line">注意: 使用jps 时的运行账户要和JVM 虚拟机启动的账户一致。若启动JVM虚拟机是运行的账户为www，那使用jps指令时，也要使用www 用户去指定。 sudo -u www jps</span><br></pre></td></tr></table></figure><h4 id="5-2-jstack"><a href="#5-2-jstack" class="headerlink" title="5.2 jstack"></a>5.2 jstack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。如果现在运行的java程序呈现hung的状态，jstack是非常有用的。此信息通常在运维的过程中被保存起来(保存故障现场)，以供RD们去分析故障。</span><br><span class="line">常用参数如下:</span><br><span class="line">jstack &lt;pid&gt;</span><br><span class="line">jstack [-l] &lt;pid&gt; &#x2F;&#x2F;长列表. 打印关于锁的附加信息</span><br><span class="line">jstack [-F] &lt;pid&gt; &#x2F;&#x2F;当’jstack [-l] pid’没有响应的时候强制打印栈信息</span><br></pre></td></tr></table></figure><p>Example</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打印JVM 的堆栈信息，以供问题排查</span><br><span class="line">[root@mouse03 ~]# jstack -F 38360 &gt; /tmp/jstack.log</span><br></pre></td></tr></table></figure><h3 id="6、Tomcat安全优化"><a href="#6、Tomcat安全优化" class="headerlink" title="6、Tomcat安全优化"></a>6、Tomcat安全优化</h3><h4 id="6-1-telnet管理端口保护（强制）"><a href="#6-1-telnet管理端口保护（强制）" class="headerlink" title="6.1 telnet管理端口保护（强制）"></a>6.1 telnet管理端口保护（强制）</h4><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>telnet管理端口保护</td><td>1.修改默认的8005管理端口为不易猜测的端口（大于1024）；2.修改SHUTDOWN指令为其他字符串；</td><td><Server port="**8527**" shutdown="**dangerous**"></Server></td><td>1.以上配置项的配置内容只是建议配置，可以按照服务实际情况进行合理配置，但要求端口配置在<strong>8000~8999</strong>之间；</td></tr></tbody></table><h4 id="6-2-ajp连接端口保护（推荐）"><a href="#6-2-ajp连接端口保护（推荐）" class="headerlink" title="6.2  ajp连接端口保护（推荐）"></a>6.2  ajp连接端口保护（推荐）</h4><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>Ajp 连接端口保护</td><td>1.修改默认的ajp 8009端口为不易冲突的大于1024端口；2.通过iptables规则限制ajp端口访问的权限仅为线上机器；</td><td>&lt;Connector port=”<strong>8528</strong>“protocol=”AJP/1.3” /&gt;</td><td>以上配置项的配置内容仅为建议配置，请按照服务实际情况进行合理配置，但要求端口配置在<strong>8000~8999</strong>之间；；保护此端口的目的在于防止线下的测试流量被mod_jk转发至线上tomcat服务器；</td></tr></tbody></table><h4 id="6-3-降权启动（强制）"><a href="#6-3-降权启动（强制）" class="headerlink" title="6.3 降权启动（强制）"></a>6.3 降权启动（强制）</h4><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>降权启动</td><td>1.tomcat启动用户权限必须为非root权限，尽量降低tomcat启动用户的目录访问权限；2.如需直接对外使用80端口，可通过普通账号启动后，配置iptables规则进行转发；</td><td></td><td>避免一旦tomcat 服务被入侵，黑客直接获取高级用户权限危害整个server的安全；</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@java-tomcat1 ~]# useradd tomcat</span><br><span class="line">[root@java-tomcat1 ~]# chown tomcat.tomcat /usr/local/tomcat/ -R</span><br><span class="line">[root@java-tomcat1 ~]# su -c '/usr/local/tomcat/bin/startup.sh' tomcat </span><br><span class="line">Using CATALINA_BASE:   /data/application/tomcat</span><br><span class="line">Using CATALINA_HOME:   /data/application/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /data/application/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /usr/local/java</span><br><span class="line">Using CLASSPATH:       /data/application/tomcat/bin/bootstrap.jar:/data/application/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br><span class="line">[root@java-tomcat1 ~]# ps -ef | grep tomcat </span><br><span class="line">tomcat     1065      1 64 20:33 ?        00:00:06 /usr/local/java/bin/java -Djava.util.logging.config.file=/data/applicationtomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /data/application/tomcat/bin/bootstrap.jar:/data/application/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/data/application/tomcat -Dcatalina.home=/data/application/tomcat -Djava.io.tmpdir=/data/application/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br><span class="line">root       1112   1027  0 20:33 pts/0    00:00:00 grep --color=auto tomcat</span><br></pre></td></tr></table></figure><h4 id="6-4-起停脚本权限回收（推荐）"><a href="#6-4-起停脚本权限回收（推荐）" class="headerlink" title="6.4 起停脚本权限回收（推荐）"></a><strong>6.4 起停脚本权限回收（推荐）</strong></h4><table><thead><tr><th><strong>类别</strong></th><th><strong>配置内容及说明</strong></th><th><strong>标准配置或操作</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>起停脚本权限回收</td><td>去除其他用户对Tomcat的bin目录下shutdown.sh、startup.sh、catalina.sh的可执行权限；</td><td>chmod -R 744 tomcat/bin/*</td><td>防止其他用户有起停线上Tomcat的权限；</td></tr></tbody></table><h4 id><a href="#" class="headerlink" title></a></h4><h3 id="7、Tomcat性能优化"><a href="#7、Tomcat性能优化" class="headerlink" title="7、Tomcat性能优化"></a>7、Tomcat性能优化</h3><p><strong>上策：优化代码</strong></p><p>   该项需要开发经验足够丰富，对开发人员要求较高</p><p><strong>中策：jvm优化机制垃圾回收机制</strong> <strong>把不需要的内存回收</strong></p><p>优化jvm–优化垃圾回收策略</p><p>优化catalina.sh配置文件。在catalina.sh配置文件中添加以下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tomcat分配1G内存模板</span></span><br><span class="line">JAVA_OPTS="-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -XX:PermSize=512m -XX:MaxPermSize=512m"     </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">su -c '/home/tomcat/tomcat8_1/bin/shutdown.sh' tomcat</span><br><span class="line">su -c '/home/tomcat/tomcat8_1/bin/startup.sh' tomcat</span><br></pre></td></tr></table></figure><p><strong>下策：加足够大的内存</strong></p><p>该项的资金投入较大</p><p><strong>下下策：每天0点定时重启tomcat</strong></p><p>使用较为广泛</p><h3 id="8、扩展知识（面试会问）"><a href="#8、扩展知识（面试会问）" class="headerlink" title="8、扩展知识（面试会问）"></a>8、扩展知识（面试会问）</h3><p>WebSphere是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的软件。</p><p>WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="tomcat" scheme="https://l66stbz.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核升级</title>
    <link href="https://l66stbz.github.io/2024/07/31/Linux%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/"/>
    <id>https://l66stbz.github.io/2024/07/31/Linux%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/</id>
    <published>2024-07-31T12:18:00.000Z</published>
    <updated>2024-08-02T14:00:22.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linux内核升级"><a href="#Linux内核升级" class="headerlink" title="Linux内核升级"></a>Linux内核升级</h2><p><strong>首先需要把升级内核需要的两个rpm包拉到本地</strong></p><p><a href="https://l66stbz.github.io/2024/07/31/Linux内核升级/kernel-ml-4.19.12-1.el7.elrepo.x86_64.rpm" title="点击下载">kernel-ml-4.19.12-1.el7.elrepo.x86_64.rpm</a></p><p><a href="https://l66stbz.github.io/2024/07/31/Linux内核升级/kernel-ml-devel-4.19.12-1.el7.elrepo.x86_64.rpm" title="点击下载">kernel-ml-devel-4.19.12-1.el7.elrepo.x86_64.rpm</a></p><p><strong><img src="/2024/07/31/Linux%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/2.png" class></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 所有节点安装内核包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum localinstall -y kernel-ml*</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 所有节点更改内核启动顺序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grub2-set-default  0 &amp;&amp; grub2-mkconfig -o /etc/grub2.cfg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grubby --args=<span class="string">"user_namespace.enable=1"</span> --update-kernel=<span class="string">"<span class="variable">$(grubby --default-kernel)</span>"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 查看内核版本是否改变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grubby --default-kernel </span></span><br><span class="line"> /boot/vmlinuz-4.19.12-1.el7.elrepo.x86_64</span><br><span class="line"><span class="meta">$</span><span class="bash"> uname -r</span></span><br><span class="line"> 3.10.0-1160.el7.x86_64</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 未改变的话重启一下机器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br></pre></td></tr></table></figure><p><strong>升级内核之后，uname -r查看的话是不会直接更新的，需要再重启一下才可以，重启之后在如下页面默认选项为升级后的内核版本，如果想要使用之前的内核版本就选择下边的。</strong></p><p><strong><img src="/2024/07/31/Linux%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/1.png" class></strong></p><p><strong>升级Linux内核是保持系统安全、稳定和高效运行的重要手段之一。尽管在升级时需要注意与系统中其他组件的兼容性，但从长远来看，升级内核通常会带来多方面的好处，有助于提升整体系统性能和安全性。</strong></p><h2 id="Linux中的一些内核配置参数与详解"><a href="#Linux中的一些内核配置参数与详解" class="headerlink" title="Linux中的一些内核配置参数与详解"></a>Linux中的一些内核配置参数与详解</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1 #允许IPv4数据包转发。当这个参数设置为1时，Linux内核将允许作为路由器使用，可以将接收到的数据包从一个网络接口转发到另一个网络接口。</span><br><span class="line"></span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1  #如果使用Linux桥接技术（如虚拟化中常用的网桥），此参数启用iptables对桥接的数据包进行过滤和处理。</span><br><span class="line"></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1 #类似于上一个参数，但用于IPv6的iptables过滤和处理。</span><br><span class="line"></span><br><span class="line">fs.may_detach_mounts = 1  #允许文件系统卸载已被其他进程打开的文件。通常用于特定的文件系统管理场景。</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.route_localnet = 1  #允许接收到的数据包目标地址是本地网络的地址时被路由。</span><br><span class="line"></span><br><span class="line">vm.overcommit_memory=1  #内存过commit机制设置。当设置为1时，系统允许分配比实际可用物理内存更多的内存，但这可能导致内存不足时的OOM（Out of Memory）错误。</span><br><span class="line"></span><br><span class="line">vm.panic_on_oom=0  #当内存不足时，是否触发系统崩溃（panic）。设置为0时，系统不会在OOM时触发panic。</span><br><span class="line"></span><br><span class="line">fs.inotify.max_user_watches=89100  #允许每个用户的inotify监视器数量达到的最大值。</span><br><span class="line"></span><br><span class="line">fs.file-max=52706963  #系统中打开文件的最大数量限制。</span><br><span class="line"></span><br><span class="line">fs.nr_open=52706963  #系统中同时打开的文件描述符的最大数量。</span><br><span class="line"></span><br><span class="line">net.netfilter.nf_conntrack_max=2310720  #允许系统中同时跟踪的网络连接的最大数量。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time = 600     #TCP连接的空闲超时时间，单位为秒。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3    #在TCP keepalive期间发送的探测数目。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15    #在TCP keepalive探测之间的间隔时间，单位为秒。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 36000  #系统中保持TIME-WAIT套接字的最大数量。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1   #允许重用TIME-WAIT套接字。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_orphans = 327680   #允许系统同时存在的TCP孤立连接的最大数量。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_orphan_retries = 3    # TCP孤立连接的重试次数。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = 1    #启用TCP SYN cookies，用于防范SYN洪水攻击。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384   #TCP半连接队列（SYN队列）的最大长度。</span><br><span class="line"></span><br><span class="line">net.ipv4.ip_conntrack_max = 65536   #同时跟踪的IP连接的最大数量（已废弃，一般使用`net.netfilter.nf_conntrack_max`）。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_timestamps = 0  #禁用TCP时间戳，用于保护系统免受某些网络攻击。</span><br><span class="line"></span><br><span class="line">net.core.somaxconn = 16384  #系统中允许在处于TCP连接队列中的未完成连接的最大数量。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;-EOF &gt;&gt;/etc/security/limits.conf</span></span><br><span class="line">* soft nofile 655360   #设置所有用户（*）的软件（soft）文件描述符限制（nofile）为 655360。这意味着任何进程在运行时可以打开的文件数量的软限制被设置为 655360。</span><br><span class="line">* hard nofile 131072   #设置所有用户（*）的硬件（hard）文件描述符限制（nofile）为 `131072`。硬限制是软限制的上限，即用户可以通过重新设置来增加其软限制，但不能超过硬限制。</span><br><span class="line">* soft nproc 655350    #设置所有用户（*）的软件进程数（nproc）限制为 655350。软进程数限制是系统允许的最大进程数量。</span><br><span class="line">* hard nproc 655350    #设置所有用户（*）的硬件进程数（nproc）限制为 655350。硬进程数限制同样作为软限制的上限。</span><br><span class="line">* soft memlock unlimited  #设置所有用户（*）的软件内存锁定限制为无限制。这表示任何用户的进程可以锁定（即防止被交换到磁盘上）任意量的内存。</span><br><span class="line">* hard memlock unlimited  #设置所有用户（*）的硬件内存锁定限制为无限制。硬内存锁定限制同样作为软限制的上限。</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">注:/etc/security/limits.conf 是一个配置文件，用于设置系统用户的资源限制。这些资源限制包括打开的文件数、可创建的进程数、内存锁定量等。这些限制对于管理系统资源和提高系统安全性都非常重要。具体来说，这个文件允许系统管理员为各个用户或用户组设置以下类型的限制：</span><br><span class="line"></span><br><span class="line">软限制（soft limit）：软限制是用户当前可以使用的资源的最大值，通常可以通过用户自己修改。</span><br><span class="line">硬限制（hard limit）：硬限制是软限制的上限，即用户可以通过重新设置来增加其软限制，但不能超过硬限制。只有超级用户（root）可以增加硬限制。</span><br><span class="line"></span><br><span class="line">这些限制在多用户系统中特别有用，可以防止个别用户占用过多的系统资源，保证系统的稳定性和可靠性。常见的限制参数包括打开文件数、进程数、内存锁定、CPU时间等。</span><br><span class="line">编辑/etc/security/limits.conf 文件需要超级用户权限，因为这些限制对系统整体性能有较大的影响，需要慎重设置。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>shell自动化脚本学习要点笔记</title>
    <link href="https://l66stbz.github.io/2024/07/30/shell%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
    <id>https://l66stbz.github.io/2024/07/30/shell%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/</id>
    <published>2024-07-30T12:18:00.000Z</published>
    <updated>2024-08-24T09:33:14.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一些常见的预定义变量的含义"><a href="#一些常见的预定义变量的含义" class="headerlink" title="一些常见的预定义变量的含义"></a>一些常见的预定义变量的含义</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">预定义的变量是由Shell自身维护的特殊变量，它们通常保存了一些特定的系统信息。</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">HOME：当前用户的主目录。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">USER：当前用户的用户名。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">PATH：可执行文件的搜索路径。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">PWD：当前工作目录。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">OLDPWD：前一个工作目录。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">SHELL：当前使用的Shell。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">?：最后执行的命令的退出状态（返回值）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">$：当前Shell的进程ID。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">!：最后运行的后台命令的进程ID。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="comment">#：传递给脚本或函数的参数个数。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">@：以独立字符串显示每个参数。</span></span><br></pre></td></tr></table></figure><h4 id="获取变量长度的常用方法"><a href="#获取变量长度的常用方法" class="headerlink" title="获取变量长度的常用方法"></a>获取变量长度的常用方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;#变量名&#125;</span><br><span class="line">输出变量的长度(必须大括号包起来)</span><br><span class="line"></span><br><span class="line">或wc -L也可以获取长度</span><br><span class="line"></span><br><span class="line">如:echo $变量名|wc -L</span><br><span class="line"></span><br><span class="line">wc -l 获取行数</span><br><span class="line">例:cat /var/log/messages</span><br><span class="line">或wc -l &lt;/var/log/messages</span><br><span class="line"></span><br><span class="line">wc的一些比较常用的参数:</span><br><span class="line">-c, --bytes：统计字节数。</span><br><span class="line"></span><br><span class="line">-m, --chars：统计字符数。</span><br><span class="line"></span><br><span class="line">-w, --words：统计字数。</span><br><span class="line"></span><br><span class="line">-l, --lines：统计行数。</span><br><span class="line"></span><br><span class="line">-L, --max-line-length：统计最长行的长度。</span><br></pre></td></tr></table></figure><h4 id="测试主机某端口放开情况的一些方法"><a href="#测试主机某端口放开情况的一些方法" class="headerlink" title="测试主机某端口放开情况的一些方法"></a>测试主机某端口放开情况的一些方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">echo &amp;&gt;/dev/null  &gt;/dev/tcp/192.168.100.50/23 测试别的主机的端口是否可达</span><br><span class="line">&amp;&gt;/dev/null &gt;/dev/tcp/192.168.100.50/23 </span><br><span class="line">(可以不加echo,&amp;&gt;/dev/null不可以放后边，放后边失败依然会有回显)</span><br><span class="line"></span><br><span class="line">telnet IP port 如:telnet 192.168.100.50 23(成功的话会不好退出，测试不建议使用这个)</span><br><span class="line"></span><br><span class="line">nc -z -w2 192.168.100.50 22</span><br><span class="line">-z 只用于测试，不发送任何数据，无论成功与否不会有任何回显。</span><br><span class="line">-w2 超时时间，如果超过2秒没有反馈，则认为该端口没有放开。</span><br></pre></td></tr></table></figure><h4 id="if中判断正则一些符号和参数的解释"><a href="#if中判断正则一些符号和参数的解释" class="headerlink" title="if中判断正则一些符号和参数的解释"></a>if中判断正则一些符号和参数的解释</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if  [ $&#123;#passwd&#125; -gt 8 ]  &amp;&amp; [[ $&#123;passwd&#125; =~ [a-z] ]] &amp;&amp; [[ $&#123;passwd&#125; =~ [A-Z] ]]</span><br><span class="line">if [[ $IP =~ ^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$ ]]</span><br><span class="line">if [[ "$number" =~ ^[0-9]+$ ]] &amp;&amp; [ "$number" -ne 0 ]</span><br><span class="line">if [[ $num =~ ^[1-9][0-9]*$ ]]  #表示第一个数字匹配1-9之间的数字，之后匹配任意数量的数字（包括零个数字）0-9之间的数字。</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#passwd&#125; 表示变量passwd的长度</span></span></span><br><span class="line">=~ 是 Bash 中用来进行正则表达式匹配的操作符</span><br><span class="line">^ 表示匹配输入字符串的开始位置。</span><br><span class="line">[0-9]&#123;1,3&#125; 表示一个由1到3个数字（0-9之间的任意数字）组成的匹配模式。</span><br><span class="line">[0-9]+ 表示匹配一个或多个数字（0到9之间的任意数字），至少匹配一个数字。</span><br><span class="line">[0-9]* 表示匹配任意数量的数字（包括零个数字）。</span><br><span class="line"><span class="meta">$</span><span class="bash"> 表示匹配输入字符串的结束位置。</span></span><br><span class="line">正则表达式是需要用[[]]包起来，[[]]能用正则，而[]不行。</span><br><span class="line">不能直接将 &amp;&amp; 换成 -a，因为 [[ ]] 结构不支持 -a。尽管条件一不是[[]]结构！</span><br><span class="line">.表示匹配任意字符</span><br><span class="line"></span><br><span class="line">-a用来连接多个条件判断的逻辑与</span><br><span class="line">&amp;&amp; 是逻辑与操作符，用于连接命令或者条件判断，表示前一个命令或条件成功后，才会执行后面的命令或条件。</span><br></pre></td></tr></table></figure><h4 id="回车符和换行符解释"><a href="#回车符和换行符解释" class="headerlink" title="回车符和换行符解释"></a>回车符和换行符解释</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 回车符（\r）：这个符号用于表示光标返回到当前行的开头，如果有新的字符输入，将覆盖已存在的字符。在shell命令中，\r可以用于在同一行上连续输出不同的内容，例如：</span><br><span class="line"></span><br><span class="line">echo -e “Hello\rWorld”</span><br><span class="line"></span><br><span class="line">输出结果为：World。</span><br><span class="line"></span><br><span class="line">2. 换行符（\n）：这个符号用于表示光标移至下一行的开头，如果有新的字符输入，将在新的行上输出。在shell命令中，\n可以用于将一行分割成多行以提高可读性，例如：</span><br><span class="line"></span><br><span class="line">echo -e “This is line 1.\nThis is line 2.”</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">This is line 1.</span><br><span class="line">This is line 2.</span><br></pre></td></tr></table></figure><h4 id="for循环的常见写法"><a href="#for循环的常见写法" class="headerlink" title="for循环的常见写法"></a>for循环的常见写法</h4><p>下面以求1到5的和为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从范围中取值</span></span><br><span class="line">sum=0</span><br><span class="line">for i in &#123;1..5&#125;  </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">for</span> i <span class="keyword">in</span> 192.168.174.&#123;2..254&#125;  增加了前缀</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -w 0 05`  -w：表示宽度，它会在生成的数字前面补零，以保证输出的宽度一致。</span></span><br><span class="line">do</span><br><span class="line">        let sum=$sum+$i</span><br><span class="line">done</span><br><span class="line">        echo $sum</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum=0</span><br><span class="line">for i in `seq 1 1 5` #表示在1-5中取值，中间的1表示间隔为1的取值，不写默认为1</span><br><span class="line">do</span><br><span class="line">        let sum=$sum+$i</span><br><span class="line">done</span><br><span class="line">        echo $sum</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum=0</span><br><span class="line">for((i=1;i&lt;=5;i++))</span><br><span class="line">do</span><br><span class="line">        let sum=$sum+$i</span><br><span class="line">done</span><br><span class="line">        echo $sum</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置池，从池中读取值</span></span><br><span class="line">sum=0</span><br><span class="line">port="1 2 3 4 5"</span><br><span class="line">for i in $port</span><br><span class="line">do</span><br><span class="line">        let sum=$sum+$i</span><br><span class="line">done</span><br><span class="line">        echo $sum</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从文件中读取</span></span><br><span class="line">sum=0</span><br><span class="line">read -p "请输入文件路径:" file</span><br><span class="line">for i in `cat $file`</span><br><span class="line">do</span><br><span class="line">        let sum=$sum+$i</span><br><span class="line">done</span><br><span class="line">        echo $sum</span><br></pre></td></tr></table></figure><h4 id="for循环范例和两种无交互修改密码的方法"><a href="#for循环范例和两种无交互修改密码的方法" class="headerlink" title="for循环范例和两种无交互修改密码的方法"></a>for循环范例和两种无交互修改密码的方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">范例:新建10个用户给他们设置随机密码并将用户名密码记录到/tmp/userpassword文件中</span></span><br><span class="line">for u in `seq -w 0 09`</span><br><span class="line">do</span><br><span class="line">    #创建用户</span><br><span class="line">    useradd user_$u</span><br><span class="line">    #生成密码</span><br><span class="line">    p=`mkpasswd -s 0 -l 10`</span><br><span class="line">    #-s 参数用于指定密码中特殊字符的最少位数，设置为0表示不要求密码中包含特殊字符</span><br><span class="line">    #-l 参数表示密码长度为10位</span><br><span class="line">    #从标准输入中读取密码进行修改（不安全）</span><br><span class="line">    echo $p|passwd --stdin user_$u</span><br><span class="line">    #常规修改密码</span><br><span class="line">    echo -e "$p\n$p"|passwd user_$u</span><br><span class="line">    #将创建的用户及对应的密码记录到日志文件中</span><br><span class="line">    echo "user_$u $p" &gt;&gt; /tmp/userpassword</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环的常见写法"><a href="#while循环的常见写法" class="headerlink" title="while循环的常见写法"></a>while循环的常见写法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">常规<span class="keyword">while</span>循环</span></span><br><span class="line">while 条件测试操作</span><br><span class="line">do</span><br><span class="line">  命令序列</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">while</span>的死循环</span></span><br><span class="line">while  :</span><br><span class="line">do</span><br><span class="line">    循环体</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">while</span>循环+<span class="built_in">read</span>读取文件(其为一行一行读取进行循环)</span></span><br><span class="line">while  read  变量</span><br><span class="line">do</span><br><span class="line">    循环体</span><br><span class="line">done  &lt;文件路径</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">cat 文件路径 |while read 变量</span><br><span class="line">do</span><br><span class="line">    循环体</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">两种写法均可实现读取文件的效果！！！</span><br></pre></td></tr></table></figure><h4 id="cat和重定向结合使用的几种形式"><a href="#cat和重定向结合使用的几种形式" class="headerlink" title="cat和重定向结合使用的几种形式"></a>cat和重定向结合使用的几种形式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; file:</span><br><span class="line">将输入重定向到文件，并覆盖原有内容。即将用户在终端中输入的内容写入文件中，并覆盖文件中原有的内容。</span><br><span class="line">**举例来说，执行命令cat &gt; example.txt，然后输入一些文本内容并按下回车键，输入完成后使用 Ctrl+D 结束输入，此时该文本内容就被覆盖写入了example.txt文件中。</span><br><span class="line"></span><br><span class="line">cat &lt; file &lt;&lt; EOF:</span><br><span class="line">从文件中读取输入，并直到遇到EOF（End Of File）为止。即从指定的文件中读取内容，并将其传递给cat命令作为标准输入，直到遇到EOF时结束输入。EOF是自定义的结束标识符，可以使用任意字符或字符串代替，只需保证开始和结束时使用相同的字符或字符串即可。</span><br><span class="line"></span><br><span class="line">**举例来说，执行命令cat &lt;&lt; EOF，然后在终端中输入一些文本内容并按下回车键，然后输入EOF作为结束标识符，输入完成后使用 Ctrl+D结束输入，此时该文本内容就被作为标准输入传递给了cat命令。</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;- EOF:</span><br><span class="line">从文件中读取输入，并直到遇到EOF为止。和上述方式类似，区别在于在EOF前添加了一个“-”号，表示忽略所有的前导制表符（Tab）字符。`这个方式通常用于在shell脚本中输入多行文本内容。用来打印菜单，常与case结合使用`</span><br><span class="line"></span><br><span class="line">**举例来说，执行命令cat &lt;&lt;- EOF，然后在终端中输入一些文本内容并按下回车键，然后输入EOF作为结束标识符，输入完成后使用 Ctrl+D结束输入，此时该文本内容就被作为标准输入传递给了cat命令，并忽略了所有的前导制表符（Tab）字符。</span><br></pre></td></tr></table></figure><h4 id="利用grep或egrep过滤文件中的空行和注释行-常用"><a href="#利用grep或egrep过滤文件中的空行和注释行-常用" class="headerlink" title="利用grep或egrep过滤文件中的空行和注释行(常用)"></a>利用grep或egrep过滤文件中的空行和注释行(常用)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@mycat 2024-07-29]# egrep -v "^(#|$)" /etc/rc.d/rc.local  #过滤注释行和空行</span><br><span class="line">touch /var/lock/subsys/local   </span><br><span class="line"></span><br><span class="line">或[root@mycat ~]# grep -vE "^($|#)" anaconda-ks.cfg</span><br></pre></td></tr></table></figure><h4 id="sed使用实例的详解"><a href="#sed使用实例的详解" class="headerlink" title="sed使用实例的详解"></a>sed使用实例的详解</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sed -e "s|^mirrorlist=|#mirrorlist=|g" \</span><br><span class="line">    -e "s|^#baseurl=http://mirror.centos.org/centos/\$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/6.10|g" \</span><br><span class="line">    -e "s|^#baseurl=http://mirror.centos.org/\$contentdir/\$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/6.10|g" \</span><br><span class="line">    -i.bak \</span><br><span class="line">    /etc/yum.repos.d/CentOS-*.repo</span><br><span class="line"></span><br><span class="line">详解如下:</span><br><span class="line">-e 多重编辑</span><br><span class="line">-e "s|^mirrorlist=|#mirrorlist=|g"  这个部分用于注释掉以 mirrorlist= 开头的行，将其替换为#mirrorlist=。这样做的目的是禁用使用镜像列表的方式获取软件包信息。</span><br><span class="line"></span><br><span class="line">-e "s|^#baseurl=http://mirror.centos.org/\$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/6.10|g"   这个部分用于替换以 #baseurl=http://mirror.centos.org/\$releasever 开头的行，将其替换为指向清华大学 TUNA 镜像站点的 URL。$releasever 将会被当前 CentOS 版本号替换。</span><br><span class="line"></span><br><span class="line">-e "s|^#baseurl=http://mirror.centos.org/\$contentdir/\$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/6.10|g"  这个部分用于替换以 #baseurl=http://mirror.centos.org/\$contentdir/\$releasever 开头的行，同样将其替换为指向清华大学 TUNA 镜像站点的 URL。这里也使用了 $contentdir 和 $releasever 的变量，会被相应的值替换。</span><br><span class="line"></span><br><span class="line">-i.bak：这个选项让 sed 在编辑文件时备份原始文件，备份文件的扩展名为 .bak。</span><br><span class="line"></span><br><span class="line">/etc/yum.repos.d/CentOS-*.repo：这是指定要操作的目标文件，它匹配所有以 CentOS- 开头且以 .repo 结尾的文件名，通常是 CentOS YUM 仓库的配置文件。</span><br><span class="line"></span><br><span class="line">每一行末尾的反斜杠 \ 是用来续行的标记。在Shell脚本或命令行中，反斜杠 \ 可以用来告诉解释器，当前行的命令在下一行继续。这是为了提高可读性，尤其是当命令很长时。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://l66stbz.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://l66stbz.github.io/tags/Shell/"/>
    
  </entry>
  
</feed>
